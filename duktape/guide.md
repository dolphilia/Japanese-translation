# Duktapeプログラマーズ・ガイド 日本語訳

[原文](https://duktape.org/guide.html)

## はじめに

Version: 2.6.0 (2020-10-13)


### ドキュメントの範囲

このガイドではあなたのプログラムでDuktapeを使用するための入門書を提供します。基本的な使い方に慣れてきたら、APIの詳細を調べるための簡潔な[APIリファレンス](https://duktape.org/api.html)があります。[Duktape Wiki](http://wiki.duktape.org/)では、より詳細な例やベストプラクティスを提供しています。

この文書ではDuktapeの内部構造はカバーしていません。内部構造をいじりたい場合は、[Duktapeのリポジトリ](https://github.com/svaarala/duktape/tree/master/doc)を参照してください。


### Duktapeとは？

Duktapeは、移植性とコンパクトなフットプリントを重視した、組み込み可能なECMAScript®エンジンです。DuktapeをC/C++プログラムに組み込むことで、スクリプトによる機能拡張を簡単に行うことができます。また、プログラムの主要な制御フローをECMAScriptで構築し、重い処理を行うために高速なCコード関数を使用することも可能です。

Duktapeを組み込むアプリケーションは、どのネイティブ・バインディングをどのような方法で提供するかを制御することができます。例えば、コンソールへのテキスト出力やファイル・システムとのやり取りに関するデフォルトのバインディングは存在しません。Duktapeの配布パッケージにはサンプル・プロバイダーが含まれており、ニーズに合わせて簡単に統合することができます。

ECMAScriptとJavascriptという用語は、しばしば多かれ少なかれ同等だと考えられていますが、Javascriptとその亜種は技術的にはECMAScript言語が使用される環境の一つに過ぎません。ブラウザ以外の ECMAScript 環境でも、ブラウザ固有のビルトインが提供されていることがよくあるので、両者の境界は実際にはあまり明確ではありません。それでも、Duktapeが実装している言語を指すために、ここではECMAScriptという用語を使用します。


## 準拠

DuktapeはES5.0/ES5.1に準拠し、必要に応じてES2015以降からセマンティクスを更新しています。

- [ECMAScript言語仕様書第5版](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf)
- [ECMAScript®言語仕様5.1版](http://www.ecma-international.org/ecma-262/5.1/)

Duktapeは、セマンティクスとビルトインに関する最新のECMAScript仕様を追跡しています（ただし、ES2015以降のサポートはまだ不完全です）、ご参照ください。

- [ECMAScript® 2015言語仕様](http://www.ecma-international.org/ecma-262/6.0/)
- [ECMAScript® 2016言語仕様](http://www.ecma-international.org/ecma-262/7.0/)

特定のケースでは、Duktapeは仕様のドラフトに従うことがあります（[TC39/ecma262](https://github.com/tc39/ecma262)で進行中の作業を参照）。これは、最新仕様の機能が現実のコードと衝突する場合に行われます（例えば、[RegExp.prototypeのissues](https://github.com/tc39/ecma262/pull/263)を参照）。

TypedArrayのサポートはES2016 TypedArrayに基づいています。初期の実装はKhronos TypedArrayの仕様に基づいていました。

- [TypedArray Specification (Editor's Draft 18 July 2013)](https://www.khronos.org/registry/typedarray/specs/latest/) (注: リンクは最新版です)
- svn co -r 30720 https://cvs.khronos.org/svn/repos/registry/trunk/public/typedarray

Node.jsのBufferサポートは、以下のものをベースにしています。

- [Buffer Node.js v6.9.1](https://nodejs.org/docs/v6.9.1/api/buffer.html)

TextEncoder()とTextDecoder()のバインディングは、以下を参考にしています。

- [Encoding API](https://encoding.spec.whatwg.org/#api), WHATWG Encoding Living Standard

Performance.now()バインディングは、以下をベースにしています。

- [High Resolution Time Level 2](https://www.w3.org/TR/hr-time/#dom-performance-now)


## 機能紹介

Duktapeは、ECMAScriptの標準的な機能の他に、以下の追加機能を備えています（一部はアプリケーションから見えるもの、その他は内部的なものです）。

- ES2015 [TypedArray](https://www.khronos.org/registry/typedarray/specs/latest/)および[Node.js Buffer](https://nodejs.org/docs/v6.9.1/api/buffer.html)バインディング、プレーンなバッファタイプ(軽量なUint8Array)
- ECMAScript 2015 (ES6) から: setPrototypeOf/\_\_proto\_\_, Proxyオブジェクトのサブセット, Reflect, 計算されたプロパティ名, 最小限のconstサポート
- ECMAScript 2016 (ES7) から: 指数演算子 (\*\*, \*\*=)
- WHATWG Encoding Living Standardに基づく[エンコーディングAPI](https://encoding.spec.whatwg.org/#api)バインディング
- Duktape固有のビルトイン：Duktapeグローバル・オブジェクトによって提供されます。
- 拡張型：カスタムの「バッファ」と「ポインタ」型、任意のバイナリ文字列と非[BMP](http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane)文字列をサポートする拡張文字列型（標準ECMAScriptは16ビットコードポイントしかサポートしていません）。
- 参照カウントとマーク＆スイープガベージコレクションの組み合わせ、ファイナライザーと緊急ガベージコレクション（マーク＆スイープだけで構築することも可能です）
- コルーチンのサポート
- テールコールのサポート
- デバッガプロトコルに基づく内蔵デバッガフレームワーク
- プラットフォーム依存のない組み込みの正規表現エンジン
- プラットフォームに依存しない組込みの Unicode サポート
- プラットフォームに依存しない組込みの数値解析と書式設定
- バイナリシリアライゼーション用の組込みCBORバインディング
- 追加のカスタムJSONフォーマット（JXとJC）
- コンパイル済み関数をキャッシュするためのバイトコードダンプ/ロード機構


## 目標

__コンプライアンス。__ ECMAScript E5/E5.1 と実世界でのコンプライアンス。ECMAScriptのコンプライアンスには、正規表現とUnicodeのサポートが必要です。可能であれば、最新またはドラフトECMAScript仕様から機能を実装し、Duktapeカスタム機能を最小化する。

__移植性。__ Duktapeは、システム・ライブラリへの依存を最小限に抑えることで、移植性を高めています。例えば、数値のフォーマットやパース、正規表現、Unicodeは、すべてDuktapeが内部で実装しています。完全に排除できない数少ない依存性の1つが、Date組み込みによるシステムの日付／時刻の統合です。Duktapeは主要なプラットフォームを直接サポートしていますが、エキゾチックなプラットフォームでは、外部のDateプロバイダーを使用することも可能です。

__簡単なC言語インターフェース。__ DuktapeとC言語プログラムとの間のインターフェースは、自然でエラーに強いものであるべきです。特に、文字列の表現がUTF-8であり、C言語の一般的な使用法に適合するように、自動的にNULターミネータが付加される必要があります。

__フットプリントが小さいこと。__ 小さなプログラムであっても、コードとデータのフットプリントは可能な限り小さくすべきです。Duktapeは、標準ライブラリのない「ベアメタル」ターゲットにも移植可能です。これは性能よりも重要なことです。なぜなら、非常に高速なエンジンはすでにいくつかありますが、非常にコンパクトでポータブルなエンジンは少ないからです。

__適度な性能。__ フットプリントが小さい（そしてある程度ポータビリティがある）ため、おそらく競争力のあるJITベースのエンジンの可能性はなく、SpiderMonkey（およびその最適化バージョン）やGoogle V8などの非常に高度なJITベースのエンジンと競争する現実的な方法はありません。それでも、典型的な組み込みプログラムでは、性能は妥当なものであるはずです。この点では、[Lua](http://www.lua.org/)が良いベンチマークになります。(オプションで、JIT化やオフラインコンパイルのサポートを追加するのも良いでしょう)。

__ASCII文字列の性能。__ プレーンなASCII文字列を扱う操作が非常に高速であることは重要です。ASCIIはほとんどの組み込み用途で支配的です。ASCII以外の文字列を扱う操作は、それなりに高速である必要がありますが、重要ではありません。これは必要なトレードオフです。C互換文字列を使うということは、本質的にUTF-8文字列表現を使うということであり、文字列インデックスや他の多くの操作が、固定サイズの文字表現を使う場合よりも遅くなるのです。それでも、文字列を順次（どちらかの方向に）効率的に反復するような一般的なイディオムをサポートすることは重要です。


## ドキュメントの構成

本書ではDuktapeのダウンロードからコンパイル、そしてプログラムへの組み込みまでを説明します。また、スクリプト機能をどのようにプログラムに組み込むか、具体的な例を示しています。

プログラミングモデル、スタック型。C型では、ヒープ、コンテキスト、バリュースタック、Duktape API、Duktape/C関数など、Duktapeの中核となる概念について説明します。Duktapeのスタック型とC言語の型ラッパーについても詳しく説明しています。

Duktape特有のECMAScriptの機能については、複数のセクションで説明しています。型アルゴリズム（カスタム型用）、Duktape組み込み機能（追加の組み込み機能）、Post-ES5機能（ES2016以降に実装された機能）、カスタム動作（標準とは異なる動作）、カスタムJSON形式、カスタムディレクティブ、バッファオブジェクト、エラーオブジェクト（プロパティとトレースバックサポート）、関数オブジェクト（プロパティ）、日付と時刻、乱数、デバッグ、モジュール、最終化、コルーチン、仮想プロパティ、記号、バイトコードダンプ/読み込み、スレッド化、サンドボックス化。

パフォーマンス」では、パフォーマンスを向上させ、パフォーマンスの落とし穴を回避するためのDuktape固有のヒントをいくつか提供しています。Memory usage（メモリー使用法） Duktapeのメモリー使用法を要約し、使用量を最小限に抑えるためのポインターを提供します。コンパイル アプリケーションの一部としてDuktapeを構成し、コンパイルする方法について説明しています。移植性 プラットフォームやコンパイラーに特有の問題や、その他の移植性に関する問題を扱います。互換性 DuktapeのECMAScript方言、拡張機能、フレームワークとの互換性について説明します。バージョン管理 Duktapeのバージョン管理について、またどのようなバージョン互換性が期待されるかについて説明します。制限事項 現在知られている制限事項を要約し、可能な回避策を提供します。

Luaとの比較では、LuaとDuktapeの違いについて説明します。すでにLuaに慣れている方には、有益な情報かもしれません。


## はじめに


### ダウンロード

Download ページからソース配布物をダウンロードします。


### テスト用コマンドラインツール

配布物を解凍します。

```sh
$ cd /tmp
$ tar xvfJ duktape-<version>.tar.xz
```


提供されたMakefileを使用して、コマンドラインツールをコンパイルしてください。

```sh
$ cd /tmp/duktape-<version>/
$ make -f Makefile.cmdline
```


Makefileはgccがインストールされていることを前提にしています。そうでない場合は、Makefileをあなたのコンパイラに合わせて編集すればよいのです（Makefileは非常にシンプルです）。

> Duktapeは移植性の問題を避けるため、ファイルやコンソールのI/Oに対する組み込みのバインディングを提供していません（例えば、I/O APIが全くないプラットフォームもあります）。コマンドライン・ユーティリティは、extras/print-alert を使って print() と alert() のバインディングを提供し、簡単に遊べるようにしています。配布物には、以下のような便利な(オプションの)バインディングを提供する「extras」があります。
>
> - print() や alert()
> - コンソールオブジェクト、例：console.log()
> 
> __このガイドの例では、説明のために print() バインディングを想定しています。__

> コマンドラインツールは、デフォルトでプラットフォーム依存を回避しています。Makefile を編集することで、linenoise による行編集のサポートを追加することができます。
> - DDUK_CMDLINE_FANCY を追加する。
> - linenoise.hのヘッダに-Ipath/to/linenoiseを追加する。
> - ソースリストに path/to/linenoise.c を追加する。
> - LinenoiseはPOSIX環境でのみ動作し、Cコンパイラが必要です(C++ではありません)


ECMAScriptのコードをインタラクティブに実行できるようになりました。

```sh
$ ./duk
((o) Duktape 2.6.0 (v2.6.0)
duk> print('Hello world!')
Hello world!
= undefined
```


また、ECMAScriptのコードをファイルから実行することができるので、機能やアルゴリズムで遊ぶのに便利です。例として、fib.js を作成します。

```javascript
// fib.js
function fib(n) {
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    return fib(n-1) + fib(n-2);
}

function test() {
    var res = [];
    for (i = 0; i < 20; i++) {
        res.push(fib(i));
    }
    print(res.join(' '));
}

test();
```


コマンドラインからスクリプトをテストします。

```sh
$ ./duk fib.js
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
```


### Duktapeをプログラムに組み込む

コマンドラインツールは、Duktapeを組み込んだプログラムの一例です。Duktapeをあなたのプログラムに組み込むのは非常に簡単です。

- duktape-N.N.N/tools/configure.pyを実行して、ビルドのためにDuktapeを設定する。その結果、duktape.c, duktape.h, duk_config.h を含むディレクトリができます。
- duktape.c, duktape.h, duk_config.hをビルドに追加し、プログラムの他の場所からDuktape APIを呼び出してください。

Duktapeの配布物（duktape-N.N.N.tar.xz）のsrc/ディレクトリには、Duktapeのデフォルト設定のための事前設定済みのヘッダーファイルとソースファイルが含まれており、通常はそのまま使用することができます。必要であれば、設定ツールを使って、Duktapeを低メモリ・ターゲット用に最適化したり、機能を有効化／無効化したりといったDuktapeのオプションをカスタマイズすることができます。詳細と例については、Compiling and Configuring Duktape for build（ビルドのためのDuktapeのコンパイルと設定）を参照してください。

配布物には、このプロセスを説明する非常に簡単なサンプル・プログラム hello.c が含まれています。あらかじめ設定されたDuktapeのヘッダーとテストプログラムは、Duktapeコンテキストを作成し、それを使っていくつかのECMAScriptコードを実行します。
ソース・ファイルを使って、テスト・プログラムを例えば以下のようにコンパイルします。

```sh
$ cd /tmp/duktape-<version>/
$ gcc -std=c99 -o hello -Isrc src/duktape.c examples/hello/hello.c -lm
```


Duktapeの設定をカスタマイズするには、configure.pyを使います。

```sh
$ cd /tmp/duktape-<version>/
# Here we disable ECMAScript 6 Proxy object support
$ python2 tools/configure.py --output-directory duktape-src -UDUK_USE_ES6_PROXY
$ gcc -std=c99 -o hello -Iduktape-src duktape-src/duktape.c examples/hello/hello.c -lm
```


テストプログラムは、Duktapeコンテキストを作成し、それを使っていくつかのECMAScriptコードを実行します。

```sh
$ ./hello
Hello world!
2+3=5
```


Duktapeはエンベデッドエンジンなので、プログラムの基本的な制御フローを変更する必要はありません。基本的なやり方は

- プログラムの初期化時などに、Duktapeコンテキストを作成します（スクリプトが必要な場合は、オンデマンドでも構いません）。通常、初期化時にスクリプトをロードしますが、これはオンデマンドで行うこともできます。
- コードの中でスクリプトを使用したい箇所を特定し、そこにスクリプト関数の呼び出しを挿入します。
- スクリプト関数の呼び出しを行うには、まずDuktape APIを使って呼び出しの引数をDuktapeコンテキストのバリュー・スタックにプッシュします。その後、別のDuktape APIコールを使って実際の呼び出しを開始します。
- スクリプトの実行が終了すると、制御がプログラムに戻り（APIコールが戻り）、Duktapeコンテキストのバリュー・スタックに戻り値が残されています。C言語コードは、Duktape APIを使ってこの戻り値にアクセスすることができます。

より広い意味で、Duktapeをネイティブ・コードで使用する方法には、いくつかのアプローチがあります。

- メイン・アプリケーションはC/C++コードで実行し、基本機能の拡張のためにDuktapeを呼び出す（例：プラグインやコンフィギュレーションなど）。
- メイン・アプリケーションはECMAScriptコードで実行し、I/Oやパフォーマンス重視の操作などでは、シンプルなC/C++ネイティブ・バインディングを呼び出す。ネイティブバインディングはしばしばステートレスに保たれ、ステートロジックがスクリプトコードから見えないようにします。
- ECMAScript コードでメインアプリケーションを実行し、パフォーマンス重視の操作にはより複雑でステートフルな C/C++ ネイティブバインディングを使用します。例えば、グラフィックエンジンはネイティブオブジェクトとして実装することができます。

詳しい例は、以下のWiki記事を参照してください。

- はじめに: ラインプロセッシング
- はじめに: プライマリティテスト


## プログラミングモデル


### 概要

Duktapeを使ったプログラミングは非常に簡単です。

- Duktapeのソース (duktape.c) とヘッダ (duktape.h と duk_config.h) をビルドに追加してください。もし、デフォルトの設定が適切でなければ、 python2 tools/configure.py を使って、カスタム設定用の Duktape ソースとヘッダを準備します。
- Duktapeヒープ（ガベージコレクション領域）と初期コンテキスト（基本的にスレッドハンドル）をプログラム内に作成します。
- 必要なECMAScriptスクリプト・ファイルをロードし、Duktape/C関数を登録します。Duktape/C関数は、ECMAScriptコードから呼び出すことができるC関数で、性能向上やネイティブ・ライブラリへのバインディングなどのために利用できます。
- ECMAScriptの関数を呼び出すには、適宜、Duktape APIを使用してください。Duktape APIは、関数との間で値を受け渡しするために使用されます。値は、C言語の表現とDuktape内部（ECMAScript互換）の表現との間で変換されます。
- Duktape APIは、（ECMAScriptから呼び出された）Duktape/C関数が呼び出しの引数にアクセスしたり、戻り値を提供したりする際にも使用されます。

それでは、すべてのステップとそれに関連する概念をより詳しく見ていきましょう。


### ヒープとコンテキスト

Duktapeのヒープとは、ガベージコレクションのための1つの領域です。ヒープは、文字列やECMAScriptオブジェクト、その他の可変サイズのガベージコレクション・データのためのストレージを割り当てるために使用されます。ヒープ内のオブジェクトは、参照カウント、マーク＆スイープ・ガベージコレクション、オブジェクトのファイナライゼーションなどに必要な情報を提供する内部ヒープ・ヘッダを備えています。ヒープオブジェクトは互いに参照し合うことができ、ガベージコレクションの観点から到達可能性グラフが作成される。例えば、ECMAScript オブジェクトのプロパティは、そのオブジェクトのプロパティセットのキーと値の両方を参照します。複数のヒープを持つことができますが、異なるヒープにあるオブジェクトはお互いを直接参照することができません。ヒープ間で値を渡すにはシリアライズを使用する必要があります。

DuktapeコンテキストはECMAScriptの「実行スレッド」であり、特定のDuktapeヒープに住んでいるものです。Duktape APIでは、コンテキストは duk_context * で表され、Duktape内部のコルーチン（協調スレッドの一種）に関連付けられます。各コンテキストはグローバル・オブジェクトからなる環境とも関連付けられています。コンテキストは同じグローバル環境を共有することもできますが、異なる環境を持つこともできます。コンテキスト・ハンドルはほぼ全てのDuktape APIコールに与えられており、呼び出し側はDuktapeコルーチンの値スタックと対話することができます：値の挿入や問い合わせ、関数の呼び出しなど。

各コルーチンは、実行を制御するコールスタックを持ち、ECMAScript エンジン内のネイティブまたは ECMAScript の関数呼び出しを追跡します。各コルーチンはまた、コルーチンのアクティブなコールスタックのすべての ECMAScript 値を格納する値スタックを持っています。値スタックは常に最新の関数呼び出しのアクティブ・スタック・フレームを持ちます（関数呼び出しが行われていない場合、アクティブ・スタック・フレームはそのまま値スタックとなります）。Duktape APIの呼び出しは、ほとんど現在アクティブなスタック・フレームだけで動作します。また、try-catch-finallyなどを使ってエラー・キャッチのサイトを確立するための内部ブックキーピングもあります。

複数のコンテキストが同じDuktapeヒープを共有することができます。より具体的に言うと、これは複数のコンテキストが同じガベージコレクションの状態を共有でき、安全にオブジェクト参照を交換できることを意味します。異なるヒープにあるコンテキストは、直接オブジェクト参照を交換することはできません。すべての値は、何らかの方法でシリアライズされなければなりません。

Duktape APIが提供するほぼすべてのAPIコールは、その最初の引数としてコンテキスト・ポインタを取ります。グローバル変数や状態は使用されず、複数の独立したDuktapeヒープとコンテキストを同時に実行することに何の制限もありません。ただし、マルチスレッドに関する制限はあります。1つのヒープ内で任意のコードを実行できるネイティブ・スレッドは1つだけです。

Duktapeヒープとヒープ内の初期コンテキストを作成するには、単純に次のようにします。

```c
duk_context *ctx = duk_create_heap_default();
if (!ctx) { exit(1); }
```


独自のメモリ割り当て関数や致命的なエラーハンドラ関数を用意する場合（推奨）は

```c
duk_context *ctx = duk_create_heap(my_alloc,
                                   my_realloc,
                                   my_free,
                                   my_udata,
                                   my_fatal);
if (!ctx) { exit(1); }
```


同じヒープ内に新しいコンテキストを作成し、そのコンテキストが同じグローバルオブジェクトを共有するようにします。

```c
duk_context *new_ctx;

(void) duk_push_thread(ctx);
new_ctx = duk_get_context(ctx, -1 /*index*/);
```


同じヒープ内に新しいコンテキストを作成するが、グローバルオブジェクトのセットは新しいものにする。

```c
duk_context *new_ctx;

(void) duk_push_thread_new_globalenv(ctx);
new_ctx = duk_get_context(ctx, -1 /*index*/);
```


コンテキストは到達不可能になった時点で自動的にガベージコレクションされます。これはまた、もしあなたのCコードがduk_context *を保持しているなら、対応するDuktapeコルーチンはガベージコレクションの観点から到達可能でなければならない（MUST）ことを意味します。

ヒープは、呼び出し元がそれを使い終わったときに明示的に破棄されなければなりません。

```c
duk_destroy_heap(ctx);
```

これにより、割り当てられたすべてのヒープオブジェクトが解放され、そのようなオブジェクトへのポインタがすべて無効になる。特に、呼び出し元のプログラムが、ヒープに関連付けられたコンテキストの値スタックに存在する値への文字列ポインタを保持していた場合、そのポインタは無効になり、ヒープ破棄呼び出しが戻った後は決して再参照してはならない。


### コールスタック（コンテキスト）

コンテキストのコールスタックは、呼び出し元からは直接見えません。これは、あるコンテキストで現在実行されている C または ECMAScript の関数呼び出しの連鎖を記録しています。この簿記の主な目的は、関数の呼び出し元と呼び出し先の間で引数と結果の受け渡しを容易にし、関数呼び出しの間で値スタックがどのように分割されたかを追跡することです。また、コールスタックによって、Duktapeはエラー時のトレースバックを構築することができます。

Duktapeはテールコールをサポートしているため、コールスタックは必ずしも真のコールチェインを正確に表しているとは限りません。

> Cスタックと混同しないように。


### (コンテキストの)値スタックと値スタックインデックス

コンテキストの値スタックは、コルーチンの現在の実行状態に関連するタグ付き型の値の配列である。使用されるタグ付き型は、undefined, null, boolean, number, string, object, buffer, pointer, and lightfunc です。利用可能なタグ付き型の詳細については、「型」を参照してください。

値スタックは、コルーチンのコールスタック上の現在アクティブな関数呼び出し（アクティベーション）間で分割されます。いつでも、スタック上の要素をインデックスするための原点を提供するアクティブなスタックフレ ームがあります。より具体的には、Duktape APIではインデックス・ゼロで参照されるボトム（底）が常に存在します。また、現在使用されている最も高い要素のすぐ上にあるスタック要素を特定する概念的なトップがあります。以下の図がこれを示しています。

```
 Value stack
 of 15 entries
 (absolute indices)

.----.
| 15 |
| 14 |
| 13 |
| 12 |      Active stack frame (indices
| 11 |      relative to stack bottom)
| 10 |
|  9 |      .---.   Stack top is 6 (relative to stack bottom).
|  8 | <--- | 5 |   API index 5 is highest used (at value stack index 8).
|  7 |      | 4 |
|  6 |      | 3 |
|  5 |      | 2 |
|  4 |      | 1 |
|  3 | <--- | 0 |   API index 0 is bottom (at value stack index 3).
|  2 |      `---'
|  1 |
|  0 |
`----'
```

内部値スタックの要素を参照する直接的な方法はありません。Duktape APIは、常に現在アクティブなスタック・フレームを扱います。Duktape APIは、常に現在アクティブなスタック・フレームを扱うため、文書全体を通してスタック・フレームは水平に表示されます。例えば、上図のアクティブなスタック・フレームは、次のように表示されます。

```
| 0 | 1 | 2 | 3 | 4 | 5 |
```


スタック・インデックスは、Duktape APIで使用される符号付き整数のインデックスで、現在のアクティブなスタック・フレームの要素を、現在のフレームの底から相対的に参照するために使用されます。

負ではない（>= 0）のインデックスは、フレームの底を基準として、現在のスタック・フレーム内のスタック・エントリーを参照します。

```
| 0 | 1 | 2 | 3 | 4 | <5> |
```


負の（< 0）インデックスは、スタックの先頭からの相対的なエントリーを指します。

```
| -6 | -5 | -4 | -3 | -2 | <-1> |
```


特殊定数 DUK_INVALID_INDEX は、無効なスタックインデックスを示す負の整数である。これは API 呼び出しから返され、また API 呼び出しに与えて "値がない" ことを示すことができます。

スタックトップ(または単に "トップ")は、最も使用されているインデックスのすぐ上の仮想要素の非負のインデックスである。例えば、最も使用されているインデックスの上は 5 であるので、スタックトップは 6 である。 トップは現在のスタックサイズを示し、またスタックにプッシュされる次の要素のインデックスである。

```
| 0 | 1 | 2 | 3| 4 | <5> | (6) |
```

> API のスタック操作は、常に現在のスタックフレームに限定される。現在のフレームより下のスタックエントリを参照する方法はない。これは意図的なものであり、コールスタック内の関数が互いの値に影響を与えないようにするためである。

> Cスタックと混同しないように。


### バリュースタックを成長させる

コンテキストの値スタックは、いつでもある最大数のエントリに割り当てられています。割り当てられたサイズを超えて値をプッシュしようとすると、エラーがスローされ、値スタックが自動的に拡張されることはありません。これは、内部実装を単純化し、また、関数中にある数のエントリが必要であることが事前に分かっている場合に、再割り当てを最小限に抑えることでパフォーマンスを向上させるものです。

値スタックが作成されるとき、あるいは Duktape/C 関数が入力されるとき、値スタックは常に呼び出し引数と DUK_API_ENTRY_STACK （現在 64）要素のための空間を持つことが保証されています。一般的なケースでは、これは十分すぎるほどで、Duktape/C関数の大部分は値スタックを拡張する必要がありません。より大きなスペースを必要とする関数、あるいは入力に依存したスペースを必要とする関数だけが、値スタックを拡張する必要があります。

duk_check_stack() または (通常より好ましくは) duk_require_stack() で明示的にスタック割り当てを拡張することができます。いったん拡張に成功すると、指定された数の要素をスタックにプッシュできることが再び保証されます。Duktape/C関数から戻る以外、割り当てを縮小する方法はありません。

例えば、入力された ASCII 文字列を大文字に変換する次のような関数を考えてみましょう。この例では、必要な値スタックのエントリ数が入力に依存することが示されています（そうでなければ、これは文字列を大文字にするためのあまり良い方法とは言えません）。

```c
/* uppercase.c */
#include <stdio.h>
#include <stdlib.h>
#include "duktape.h"

static int dummy_upper_case(duk_context *ctx) {
    size_t sz;
    const char *val = duk_require_lstring(ctx, 0, &sz);
    size_t i;

    /* スタックに 'sz' 個の追加エントリが必要です。 */
    duk_require_stack(ctx, sz);

    for (i = 0; i < sz; i++) {
        char ch = val[i];
        if (ch >= 'a' && ch <= 'z') {
            ch = ch - 'a' + 'A';
        }
        duk_push_lstring(ctx, (const char *) &ch, 1);
    }

    duk_concat(ctx, sz);
    return 1;
}

int main(int argc, char *argv[]) {
    duk_context *ctx;

    if (argc < 2) { exit(1); }

    ctx = duk_create_heap_default();
    if (!ctx) { exit(1); }

    duk_push_c_function(ctx, dummy_upper_case, 1);
    duk_push_string(ctx, argv[1]);
    duk_call(ctx, 1);
    printf("%s -> %s\n", argv[1], duk_to_string(ctx, -1));
    duk_pop(ctx);

    duk_destroy_heap(ctx);
    return 0;
}
```


Duktapeは、ユーザー予約要素に加えて、全てのAPIコールがさらなる割り当てなしに動作するのに十分なバリュー・スタック・スペースを確保するために、自動的に内部のバリュー・スタック・リザーブを保持します。また、メモリの再割り当てを最小限に抑えるため、値スタックはある程度大きなステップで拡張・縮小されます。その結果、呼び出し元が指定した余分な値を超えて利用可能な値スタック要素の内部数は、かなり変化します。呼び出し元はこれを考慮する必要はなく、利用可能な追加要素に依存するべきでは決してない。


### ECMAScriptの配列インデックス

ECMAScript のオブジェクトおよび配列のキーは、文字列またはシンボルのみとする。配列のインデックス (例: 0, 1, 2) は、それぞれの数値の標準文字列表現 (例: "0", "1", "2") として表現されます。より技術的には、範囲 [0, 2**32-2] の整数のすべての標準文字列表現が有効な配列インデックスとなります。

ECMAScript の配列インデックスの取り扱いを説明するために、次の例を考えてみましょう。

```javascript
var arr = [ 'foo', 'bar', 'quux' ];

print(arr[1]);     // refers to 'bar'
print(arr["1"]);   // refers to 'bar'

print(arr[1.0]);   // refers to 'bar', canonical encoding is "1"
print(arr["1.0"]); // undefined, not an array index
```


ECMAScript の配列上で動作するいくつかの API 呼び出しは、配列の数値インデックス引数を受け付けます。これは実際には、その数値の文字列変換を示すショートハンドに過ぎません。例えば、APIに整数の123が与えられた場合、これは実際にはプロパティ名 "123 "を指します。

内部的には、Duktapeは可能な限り数値インデックスを実際の文字列に変換することを避けようとします。したがって、関連する場合は配列インデックスAPIコールを使用することが望ましいです。同様に、ECMAScriptのコードを書く場合にも、文字列インデックスではなく、数値を使うことが望ましいです。


### Duktape API

Duktape APIは、duktape.hで定義され、APIリファレンスで文書化されたユーザー呼び出し可能なAPIコールの集合体です。

Duktape APIコールは一般的にエラーに寛容で、全ての引数にエラー（NULLポインタなど）がないかをチェックします。しかし、フットプリントを最小にするため、ctx引数はチェックされず、呼び出し側は NULLコンテキストでDuktape APIコールを呼び出してはいけません(MUST NOT)。

すべてのDuktape APIコールは、潜在的にマクロです。呼び出し側のコードは、Duktape APIコールが関数ポインタとして利用可能であることに 依存してはいけません。あるAPIコールの実装は、互換性のあるリリース間であっても、マクロと実際の関数の間で変更される可能性があります。Duktape APIは、マクロに対して以下の保証を行います。

- 引数は2回以上評価されない(明示的に記述されていない限り)。ただし、現在のバージョンで引数が無視される場合、引数は全く評価されない可能性があります。
- 戻り値のあるAPIコールは、式として使用できる。APIマクロが複数のステートメントを含む場合、カンマ式（例：(foo, bar, quux)）として実装される。
- 戻り値が void の API 呼び出しは、必ずしも式の一部として動作しない場合がある。APIマクロは、ブロック文またはダミーの do {...} while (0) ループとして実装されることがある。


### Duktape/C 関数

Duktape/C APIシグネチャを持つC関数は、ECMAScript関数オブジェクトと関連付けることができ、ECMAScript関数オブジェクトが呼び出されたときに呼び出されます。Duktape/C API関数は、以下のような形をしています。

```c
duk_ret_t my_func(duk_context *ctx) {
    duk_push_int(ctx, 123);
    return 1;
}
```

この関数は、ECMAScript の呼び出し引数を ctx の値スタックで取得し、 duk_get_top() は、値スタック上に存在する引数の数を示します。このバインディングは、自動的に値スタックにプッシュされません; 必要であれば、それにアクセスするために duk_push_this() を使用してください。Duktape/C 関数に関連付けられた ECMAScript 関数オブジェクトを作成する際に、希望する引数の数を選択することができます。余分な引数は削除され、足りない引数は undefined に置き換えられます。関数は、（引数数としてDUK_VARARGSを与えることにより）vararg関数として登録することもでき、この場合、呼び出し引数はC関数入力前に修正されません。

この関数は、以下のいずれかを返すことができる。

- 戻り値 1 は、スタックの一番上の値が戻り値として解釈されることを示す。
- 戻り値 0 は、値スタック上に明示的な戻り値がないことを示し、undefined が呼び出し元に返される。
- 負の戻り値は、自動的にエラーが投げられることを示す。DUK_RET_xxx というエラーコードは、特定の種類のエラーに対応します（正の値である DUK_ERR_xxx と混同しないでください）。これはオプションの省略記法で、フットプリントは小さいですが、いくつかの欠点もあります (例えば、エラーメッセージがないなど)。
- ECMAScript は Edition 5.1 では複数の戻り値をサポートしていないので、1 以上の戻り値は現在未定義です (1 以上の値は、ECMAScript Edition 6 で複数の戻り値をサポートするようになるかもしれません。)。

Duktape/C関数が戻るとき、値スタックは自動的に巻き戻されるので、関数が戻ったときに値スタックを手動でクリーンアップする必要はありません。

負のエラー返り値は、一般的なエラー処理を簡素化することを目的としており、Duktape APIコールで明示的にエラーを構築して投げることの代替となります。Duktapeが自動的にメッセージを作成するため、エラーメッセージを与えることはできません。例えば

```c
duk_ret_t my_func(duk_context *ctx) {
    if (duk_get_top(ctx) == 0) {
        /* 引数が与えられない場合、TypeErrorを投げる */
        return DUK_RET_TYPE_ERROR;
    }
    /* ... */
}
```


すべてのDuktape/C関数は、ECMAScriptの意味においてストリクト（厳密）であるとみなされます。DuktapeのAPIコールは、たとえDuktape/C関数の外部で、つまりコールスタックが空の状態でAPIコールが行われたとしても、常にECMAScriptのstrictモードのセマンティックに従います。例えば、duk_del_prop()を使って設定不可能なプロパティを削除しようとすると、エラーがスローされます。これは、ECMAScriptの厳密な関数でも同様です。

```javascript
function f() {
    'use strict';
    var arr = [1, 2, 3];
    return delete arr.length;  // 配列 'length' は設定不可
}

print(f());  // f() がストリクトであるため、エラーを発生させます。
```


Duktape/C関数の厳密性のもう一つの帰結は、Duktape/C関数に与えられたこのバインディングが強制されないということです。これはECMAScriptの厳密なコードにも当てはまります。


```javascript
function strictFunc() { 'use strict'; print(typeof this); }
function nonStrictFunc() { print(typeof this); }

strictFunc.call('foo');     // prints 'string' (uncoerced)
nonStrictFunc.call('foo');  // prints 'object' (coerced)
```


Duktape/Cの関数は、現在のところ常にコンストラクタブルで、つまりnew Foo()式の中で常に使用することが可能です。ある関数がコンストラクタ・モードで呼び出されたかどうかは、以下のようにして確認することができます。


```c
static duk_ret_t my_func(duk_context *ctx) {
    if (duk_is_constructor_call(ctx)) {
        printf("called as a constructor\n");
    } else {
        printf("called as a function\n");
    }
}
```


メモリを節約するために、Duktape/C関数はデフォルトでprototypeプロパティを持たないので、デフォルトのオブジェクト・インスタンス（thisとしてコンストラクタに与えられる）はObject.prototypeを継承しています。カスタム・プロトタイプを使用するには、Duktape/C関数に対して明示的にプロトタイプを定義します。ECMAScript関数と同様に、コンストラクターがオブジェクトの値を返す場合、その値はデフォルトのオブジェクト・インスタンスを置き換え、新しい式の値となります。

> このバインディングは自動的に値スタックにプッシュされないので、アクセスするには duk_push_this() を使ってください。


### Duktape/C関数の状態を格納する

Duktape/C関数にアウトオブバンドで、つまり明示的な呼び出し引数以外で、パラメータや追加ステートを提供したい場合があります。これを実現するためには、いくつかの方法があります。

#### 関数のプロパティ

まず、Duktape/C関数はそのFunctionオブジェクトを使って、状態やパラメーターを保存することができます。ある Duktape/C 関数（実際の C 関数）は常に ECMAScript の Function オブジェクトで表され、内部的に基礎となる C 関数と関連付けられています。Functionオブジェクトは、その関数の特定のインスタンスに関連するプロパティを保存するために使用することができます。ある Duktape/C 関数は、複数の独立した Function オブジェクトに関連付けることができ、したがって、独立した状態にすることができることに注意してください。

Duktape/C関数に関連するECMAScript Functionオブジェクトにアクセスするのは簡単です。

```c
duk_push_current_function(ctx);
duk_get_prop_string(ctx, -1, "my_state_variable");
```


#### 'this'バインディング

状態を保存するためのもう一つの方法は、Duktape/C関数をメソッドとして呼び出し、状態を保存するためにthisバインディングを使用することです。例えば、asと呼ばれるDuktape/C関数を考えてみましょう。

```javascript
foo.my_c_func()
```


Duktape/C関数は呼び出されると、このバインディングとしてfooを取得し、fooに直接ステートを格納することができます。関数オブジェクトのアプローチと異なるのは、すべてのメソッドで同じオブジェクトが共有される点です。

thisバインディングにアクセスするのは簡単です。

```c
duk_push_this(ctx);
duk_get_prop_string(ctx, -1, "my_state_variable");
```


#### 隠されたシンボルのプロパティ

データをオブジェクトと関連付ける必要があるが、ECMAScript コードから隠されている場合、隠し[シンボル]()をプロパティキーとして使用することができます。このキーは、C API から ECMAScript コードに渡されない限り、C API を介してのみアクセス可能です。一般的な使用例としては、C メモリへのポインタ/データのバッキングを関連付けることです。シンボルは文字列として作成されますが、シンボルとしてマークするマクロで区別されます。

例えば、この上に隠されたシンボルを設定したり、取得したりする。

```c
my_context_data_t *my_context_data = malloc(sizeof(my_context_data_t));
duk_push_this(ctx);
duk_push_pointer(ctx, my_context_data);
duk_put_prop_string(ctx, -2, DUK_HIDDEN_SYMBOL("my_context_data"));
/* ... */
duk_push_this(ctx);
duk_get_prop_string(ctx, -1, DUK_HIDDEN_SYMBOL("my_context_data"));
my_context_data_t *my_context_data = duk_get_pointer(ctx, -1);
```


#### 関数のマジックバリュー

Duktape/C関数オブジェクトは、16ビット符号付き整数の「マジック」値（デフォル トではゼロ）を、余分なメモリー・コストなしに内部に保存することができます。このマジック・バリューは、フラグや小さな値を最小限のコストで Duktape/C 関数に渡すために使用でき、これにより、単一のネイティブ関数が複数の関数 オブジェクトに対してわずかに異なる動作を提供することができます。

```c
/* Magic value example: two lowest bits are used for a prefix index, bit 2 (0x04)
 * is used to select newline style for a log write helper.
 */
const char *prefix[4] = { "INFO", "WARN", "ERROR", "FATAL" };
duk_int_t magic = duk_get_current_magic(ctx);

printf("%s: %s", prefix[magic & 0x03], duk_safe_to_string(ctx, 0));
if (magic & 0x04) {
    printf("\r\n");
} else {
    printf("\n");
}
```


APIの使用例については、テストケースである [test-get-set-magic.c]() を参照してください。Duktapeは、コンパイルされたコードのサイズを最小化するために、内部的に マジック値を多用しています（例えば、[duk_bi_math.c]()を参照してください）。

> マジック・バリューの仕組みは、Duktapeのメジャー・バージョン間で変更される可能性があり、利用可能な予備ビットの数が変わるからです。マジック・バリューを使うのは、フットプリントが本当に重要なときだけにしてください。関数オブジェクトに保存されるプロパティは、より安定した代替手段です。


#### ヒープスタッシュ

ヒープ・スタッシュは、Cコードからだけ見えるオブジェクトです。これは Duktape ヒープに関連付けられ、Duktape/C コードが ECMAScript コードに公開されない「アンダー・ザ・フード」状態データを保存することを可能にします。これは [duk_push_heap_stash()]() API 呼び出しでアクセスします。


#### グローバルスタッシュ

グローバルスタッシュはヒープスタッシュと似ていますが、グローバルオブジェクトと関連付けられています。[duk_push_global_stash()]() APIコールでアクセスできます。同じヒープ内に、異なるグローバル・オブジェクトを持つ複数の環境が存在することがあります。


#### スレッド隠し場所

スレッド・スタッシュはヒープ・スタッシュと似ていますが、Duktapeスレッド（つまりctxポインタ）に関連付けられます。[duk_push_thread_stash()]() APIコールでアクセス可能です。


### Duktapeのバージョン固有コード

Duktapeのバージョンは、DUK_VERSION定義を通じて、 (major * 10000) + (minor * 100) + patchという数値で利用可能です。同じ値は、Duktape.versionを通じて、ECMAScriptコードで利用可能です。呼び出し側のコードは、Duktapeのバージョンに特化したコードのために、この定義を利用することができます。

Cコードの場合。

```c
#if (DUK_VERSION >= 20403)
/* Duktape 2.4.3 or later */
#elif (DUK_VERSION >= 10500)
/* Duktape 1.5.0 or later */
#else
/* Duktape lower than 1.5.0 */
#endif
```

ECMAScriptのコード用（[Duktape build-ins]()も参照）。

```javascript
if (typeof Duktape !== 'object') {
    print('not Duktape');
} else if (Duktape.version >= 20403) {
    print('Duktape 2.4.3 or higher');
} else if (Duktape.version >= 10500) {
    print('Duktape 1.5.0 or higher (but lower than 2.4.3)');
} else {
    print('Duktape lower than 1.5.0');
}
```


### 数値エラー・コード

Duktape API でエラーが発生した場合、呼び出し側はそのエラーに数値のエラー・コードを 割り当てなければなりません。エラーコードは正の整数であり、現時点では 24 ビットに制限されています。組み込みのエラーコードは duktape.h で定義されており、例えば DUK_ERR_TYPE_ERROR がある。

残りの上位ビットは、例えば追加のフラグを運ぶために内部的に使用される。負のエラー値は、Duktape/C APIにおいて、自動的にエラーを投げるための省略記法として使用されます。


### エラー・ハンドリング

Duktape APIにおけるエラー処理は、ECMAScriptがエラーを処理する方法と似ています：エラーは明示的または暗黙的にスローされ、その後キャッチされ処理されます。エラーは明示的または暗黙的にスローされ、その後キャッチされ処理されます。Cコードはtry-catch文の代わりに[protected]() Duktape APIコールを使って、Cコード内でエラーをキャッチし処理できるポイントを確立します。保護された呼び出しを除く全てのDuktape APIコールは、エラーを投げる可能性があります。ほとんどのECMAScript操作は、状況によってはエラースローを引き起こす可能性があり、メモリ不足エラーはほとんど全ての状況で起こり得ます。throw サイトと catch サイト間の長い制御転送は、 setjmp()/longjmp() (またはそのプラットフォーム固有のバージョン)、または C++ 例外スロー (DUK_USE_CPP_EXCEPTIONS が有効な場合) に基づいています、[長い制御転送]()を参照してください。

捕捉されないエラーは致命的なエラーハンドラを呼び出しますが、これは回復不可能な状況とみなされ、通常は避けるべきです。致命的なエラーを回避するために、一般的なアプリケーション・コードでは、他のDuktape APIを呼び出す前に、エラー・キャッチ・サイトを確立する必要があります。これは、例えば保護されたDuktape APIコールを使って行われます。

コードの評価 ([duk_peval()]())、コードのコンパイル ([duk_pcompile()]())、関数の呼び出し ([duk_pcall()]()) には protected コールを使用する。
単一の [duk_safe_call()]() を使って、安全でないプリミティブを安全な呼び出しの内部で自由に使えるように、エラー・キャッチャーを確立する。

最初の手法の例。

```javascript
/* Use duk_safe_call() to wrap all unsafe code into a separate C function.
 * This approach has the advantage of covering all API calls automatically
 * but is a bit more verbose.
 */

static duk_ret_t unsafe_code(duk_context *ctx, void *udata) {
    /* Here we can use unprotected calls freely. */

    (void) udata;  /* 'udata' may be used to pass e.g. a struct pointer */

    push_file_as_string(ctx, "myscript.js");
    duk_eval(ctx);

    /* ... */

    return 0;  /* success return, no return value */
}

/* elsewhere: */

if (duk_safe_call(ctx, unsafe_code, NULL /*udata*/, 0 /*nargs*/, 1 /*nrets */) != 0) {
    /* The 'nrets' argument should be at least 1 so that an error value
     * is left on the stack if an error occurs.  To avoid further errors,
     * use duk_safe_to_string() for safe error printing.
     */
    printf("Unexpected error: %s\n", duk_safe_to_string(ctx, -1));
}
duk_pop(ctx);
```


プロテクトされたコール内でも、内部エラーのように致命的なエラーを引き起こすか、プロテクトされたAPIコールから外部にエラーを伝播させるような稀なケースがあります。これらは異常時にのみ発生し、回復可能とはみなされません。これらのケースをうまく処理するために、生産品質のアプリケーションは常に致命的なエラーを処理するための合理的な戦略を持つ致命的なエラーハンドラを持つべきです。そのような戦略は、必然的にアプリケーションに依存しますが、次のようなものになるでしょう。

- 組み込みデバイスでは、致命的なエラーハンドラは致命的なエラー情報をフラッシュファイルに書き込んで、デバイスをリブートすることができます。リブート後、致命的なエラーを診断サーバーに報告し、調査できるようにする。
- UNIX システムでは、致命的エラーハンドラは単にプロセスを終了させ (デフォルトの致命的ハンドラは abort() を使用します)、 ラッパースクリプトにアプリケーションを再開させることができます。

アプリケーションによっては、エラー・キャッチャーなしでAPIコールを行い、 致命的なエラーにつながるキャッチできないエラーを投げる危険性があることは、 問題にならないかもしれないことに注意してください。致命的なエラーが発生した後、実行を継続することは安全ではないので、そのようなアプリケーションは、致命的なエラーが発生した場合、通常、単に終了します。実際の回復手段がない場合でも、致命的なエラーハンドラを使用して、例えばプロセス終了前に標準エラーに致命的なエラー情報を書き込む必要があります。


### 通常エラーと致命的エラー

通常のエラーは throw 文、[duk_throw()]() API 呼び出し（または類似のもの）、あるいは内部で回復可能な Duktape エラーによって発生します。通常のエラーは、ECMAScript コードでは try-catch で、C コードでは [duk_pcall()]() (API calls tagged [protected]() を参照)で捕捉できます。

致命的なエラーは、キャッチできないエラー、アサーションの失敗（有効な場合）、[duk_fatal()]()への明示的なコール、Duktape内部の回復不能なエラーによって引き起こされます。

各Duktapeヒープは、[duk_create_heap()]()で登録されたヒープ全体の致命的なエラー・ハンドラを持っています。ハンドラが与えられない場合、組み込みのデフォルト・ハンドラが使用されます。

- デフォルト設定: 組み込みのデフォルトの致命的なエラーハンドラは、デバッグログメッセージを書きますが、標準出力や標準エラーには何も書きません。デバッグログはデフォルトで無効になっており、致命的なエラーメッセージはデフォルトでは表示されません。ハンドラは次にabort()を呼び出します。abort() が何らかの理由で終了した場合、ハンドラは無限ループに入り、致命的なエラーの後に実行が再開されないことを保証します。
- DUK_USE_CPP_EXCEPTIONS が有効: 組み込みのデフォルトの致命的なエラーハンドラは duk_fatal_exception を投げます。この例外は std::runtime_error を継承しているので簡単に捕捉でき、致命的なエラーメッセージを読み込むための ::what() メソッドを提供します。致命的なエラーをキャッチした後に実行を継続するのは安全ではありません。
- DUK_USE_FATAL_HANDLER が定義されている場合、C++ 例外を有効にしても、常に組み込みのデフォルトの致命的なエラーハンドラとして使用されます。

> (1) ヒープ生成時にカスタム致命的エラーハンドラを提供する、 (2) duk_config.h の DUK_USE_FATAL_HANDLER() オプションを使って、 組み込みのデフォルト致命的エラーハンドラを置き換える、の両方を強くお勧めします。


致命的なエラーの後に実行を再開する安全な方法はありません。そのため、致命的なエラー・ハンドラは戻ったりDuktape APIを呼び出してはいけません。その代わり、ハンドラは例えばコンソールやログ・ファイルにメッセージを書き出し、その後プロセスを終了（または組み込みデバイスを再起動）する必要があります。これは、C++の例外を長い制御転送メカニズムとして使用する場合にも適用されます。致命的なエラーの後、アプリケーションが実行を継続すると、すべての賭けがなくなります。メモリリークが発生する可能性があり、メモリ安全性が損なわれるかもしれません。

致命的なエラーは、ヒープコンテキスト無しで発生することもあり、その場合 Duktapeはヒープ固有の致命的なエラー・ハンドラを探すことができません。その場合、Duktapeは常に組み込みのデフォルトの致命的エラーハンドラを呼び出します(handler userdata引数をNULLに設定した場合)。この方法で処理される致命的なエラーは、現在のところアサーションの失敗に限られています。そのため、アサーションを有効にしない場合、そのようなエラーは現在発生せず、すべての致命的なエラー処理は、アプリケーションが直接制御するヒープに関連する致命的なエラー・ハンドラを通じて行われます。

より詳細な情報や例については、[致命的なエラーの処理方法]()を参照してください。


### ロング・コントロール・トランスファー

Duktapeがエラーのスローやキャッチのために内部で使用している特定の長い制御転送メカニズムは、アプリケーション・コードからは直接見えません。アプリケーション・コードはエラーをキャッチするために[保護された]()呼び出しを使用し、エラーはDuktapeまたはアプリケーションによって、例えばduk_error（）などの様々なDuktape API呼び出しを使用してスローされます。


#### DUK_USE_CPP_EXCEPTIONS を使用しないデフォルトの構成

デフォルトの構成では、Duktape API の保護された呼び出しは setjmp() を使用してキャッチ・サイトを確立します。エラースローサイトでは、longjmp()を使用して、ネイティブCスタックを巻き戻し、(最も近い)キャッチサイトに戻ります。いくつかのプラットフォームでは、sigsetjmp() や siglongjmp などの呼び出しの変種が使用されています。呼び出しの亜種の間には、例えばパフォーマンスやシグナル処理に関して、小さな違いがあります。呼び出しの種類は duk_config.h で選択されます。

longjmp() は、longjmp() と setjmp() の間のすべてのネイティブ C スタックフレームを巻き戻しま す。しかし、この巻き戻し処理は C++ の自動デストラクタを呼び出さないので、C++ アプリケーションによっては重大な制限となる可能性があります。

致命的なエラー、例えば捕捉されないエラーについては、デフォルトの致命的なエラーハンドラは abort() を使用します、[正常なエラーと致命的なエラー]()を参照してください。


#### C++モード、DUK_USE_CPP_EXCEPTIONSを使用した場合

DUK_USE_CPP_EXCEPTIONSが有効な場合、長い制御転送はC++の例外スローに基づいて行われます。保護された呼び出しは、C++のトライ・キャッチを使用してキャッチ・サイトを確立します。これはDuktape内部で発生し、アプリケーションからは見えないことに注意してください。エラースローサイトはduk_internal_exceptionをスローし、（最も近い）Duktapeのキャッチサイトによってキャッチされます。アプリケーション・コードでは、この例外をキャッチ（スロー）してはいけません。そのリスクを最小限にするために、この例外は標準的な例外クラスを継承していないので、お決まりの std::exception catch サイトで捕捉されることはありません。

致命的なエラー、例えばキャッチされないエラーの場合、duk_fatal_exception はデフォルトの致命的なエラーハンドラによって投げられます。この例外は std::runtime_error を継承しており、ユーザコードで捕捉されることを意図しています。この例外は、致命的なエラーメッセージを返す ::what() メソッドを提供します。致命的なエラーは捕捉可能であっても、エラーを捕捉した後に実行を継続することは安全ではありません。[正常なエラーと致命的なエラー]()を参照してください。

どちらの C++ 例外タイプでも、C++ ネイティブのスタック巻き戻し処理は、throw サイトと catch サイトの間のスタックフレームの自動デストラクタをサポートしています。


## スタックタイプ

### 概要

| Type | Type constant | Type mask constant | Description |
| ---- | ---- | ----- | -----|
| (none)    | DUK_TYPE_NONE      | DUK_TYPE_MASK_NONE      | no type (missing value, invalid index, etc) |
| undefined | DUK_TYPE_UNDEFINED | DUK_TYPE_MASK_UNDEFINED | undefined |
| null      | DUK_TYPE_NULL      | DUK_TYPE_MASK_NULL      | null |
| boolean   | DUK_TYPE_BOOLEAN   | DUK_TYPE_MASK_BOOLEAN   | true and false |
| number    | DUK_TYPE_NUMBER    | DUK_TYPE_MASK_NUMBER    | IEEE double |
| string    | DUK_TYPE_STRING    | DUK_TYPE_MASK_STRING    | immutable (plain) string or (plain) Symbol |
| object    | DUK_TYPE_OBJECT    | DUK_TYPE_MASK_OBJECT    | object with properties |
| buffer    | DUK_TYPE_BUFFER    | DUK_TYPE_MASK_BUFFER    | mutable (plain) byte buffer, fixed/dynamic/external; mimics an Uint8Array |
| pointer   | DUK_TYPE_POINTER   | DUK_TYPE_MASK_POINTER   | opaque pointer (void *) |
| lightfunc | DUK_TYPE_LIGHTFUNC | DUK_TYPE_MASK_LIGHTFUNC | plain Duktape/C function pointer (non-object); mimics a Function |


### メモリ割り当て

以下のスタックタイプは、追加のヒープ割り当てを伴います。

- 文字列: 1回の割り当てで、ヒープと文字列ヘッダが結合され、その後に不変の文字列データが続きます。外部文字列が使用される場合（デフォルトでは有効ではありません、一般的に低メモリ環境では）、文字列データは外部である可能性もあります。
- オブジェクト：1つのアロケーションは、ヒープとオブジェクトヘッダを組み合わせたものに使用され、もう1つのアロケーションはオブジェクトプロパティに使用されます。プロパティの割り当てには、配列エントリと通常のプロパティの両方が含まれ、オブジェクトが十分に大きい場合は、検索を高速化するためにハッシュテーブルが含まれます。
- バッファ：固定バッファの場合、単一のアロケーションは、ヒープとバッファヘッダを組み合わせたものを含み、その後に変更可能な固定サイズのバッファが続きます。動的バッファの場合、現在のバッファは別々に割り当てられます。外部バッファの場合、単一のヒープオブジェクトが割り当てられ、ユーザバッファを指します。

文字列とバッファはプリミティブ (pass-by-value) 型とみなされますが、メモリ割り当ての観点からはヒープで割り当てられる型です。


### ポインタの安定性

Duktapeによって割り当てられたヒープ・オブジェクトは、安定したポインターを持ちます：ガベージ・コレクションの観点から到達可能である間は、オブジェクトはメモリー内で再配置されません。これはメイン・ヒープ・オブジェクトの場合ですが、ダイナミック・プロパティ・ テーブルやダイナミック・バッファ・データ領域のような、オブジェクトに関連する追加割 り当てについては、必ずしもそうとは限りません。ヒープオブジェクトは、到達可能なスレッドの値スタックに存在するか、グローバルオブジェクトを通じて到達可能である場合などに到達可能です。ヒープオブジェクトが到達不可能になると、そのオブジェクトを参照するユーザCコードによって保持されるポインタは安全でなくなり、もはや再参照されるべきではなくなります。

実際には、ユーザコードが直接参照するヒープ割り当てデータは、文字列、固定バッファ、ダイナミックバッファだけです。文字列と固定バッファのデータ領域は安定しています。Duktape/C関数が戻った後でも、文字列や固定バッファがガベージコレクションの観点から常に到達可能である限り、そのデータを参照するCポインタを保持することは安全です。ただし、Duktape/Cの値スタック引数などについては、特別な取り決めがない限り、この限りではありません。

ダイナミックバッファのデータ領域は安定したポインタを持ちません。バッファ自体は安定したアドレスを持つヒープヘッダを持っていますが、現在のバッファは別に割り当てられ、バッファのサイズが変更されたときに再配置される可能性があります。Duktape/C関数が戻った後にポインタを保持するのは、おそらく避けた方が良いでしょう（バッファがサイズ変更されていないことを確認する簡単な方法がないため）。

外部バッファの場合、データ・ポインタの安定性は、ポインタを設定・更新するユーザ・コードに依存します。


### タイプマスク

タイプ・マスクを使用すると、呼び出し側のコードで、ある型が特定の型セットに属しているかどうかを簡単にチェックできます。例えば、あるスタック値が数値、文字列、またはオブジェクトであることをチェックするためです。

```c
if (duk_get_type_mask(ctx, -3) & (DUK_TYPE_MASK_NUMBER |
                                  DUK_TYPE_MASK_STRING |
                                  DUK_TYPE_MASK_OBJECT)) {
    printf("type is number, string, or object\n");
}
```


さらに便利にタイプのセットをマッチングさせるための特定のAPIコールがあります。

```c
if (duk_check_type_mask(ctx, -3, DUK_TYPE_MASK_NUMBER |
                                 DUK_TYPE_MASK_STRING |
                                 DUK_TYPE_MASK_OBJECT)) {
    printf("type is number, string, or object\n");
}
```


これらは、代替品よりも高速でコンパクトです。

```c
// alt 1
if (duk_is_number(ctx, -3) || duk_is_string(ctx, -3) || duk_is_object(ctx, -3)) {
    printf("type is number, string, or object\n");
}

// alt 2
int t = duk_get_type(ctx, -3);
if (t == DUK_TYPE_NUMBER || t == DUK_TYPE_STRING || t == DUK_TYPE_OBJECT) {
    printf("type is number, string, or object\n");
}
```


### None

none 型は実際には型ではなく、値が存在しないこと、スタックインデックスが無効であること等を示すために API で使用されます。


### Undefined(未定義)

undefined型は ECMAScript の未定義に対応し、ヌルとは区別されます。

アクティブな値スタックの範囲外から読み込まれた値は、undefinedとして読み返される。


### Null

Null 型は ECMAScript の null にマップされます。


### Boolean

Boolean型は、C API では整数として表現されます：ゼロは偽、非ゼロは真です。

API 呼び出しの引数として boolean 値を与える場合、0 以外の値はすべて "true" 値として扱われます。APIコールが真偽値を返す場合、常に値1が "true "の値として使用される。これにより、ある種のC言語のイディオムが使用できるようになる。例えば、以下のように、APIコールの戻り値から直接ビットマスクを構築することができる。

```c
/* this works and generates nice code */
int bitmask = (duk_get_boolean(ctx, -3) << 2) |
              (duk_get_boolean(ctx, -2) << 1) |
              duk_get_boolean(ctx, -1);

/* more verbose variant not relying on "true" being represented by 1 */
int bitmask = ((duk_get_boolean(ctx, -3) ? 1 : 0) << 2) |
              ((duk_get_boolean(ctx, -2) ? 1 : 0) << 1) |
              (duk_get_boolean(ctx, -1) ? 1 : 0);

/* another verbose variant */
int bitmask = (duk_get_boolean(ctx, -3) ? (1 << 2) : 0) |
              (duk_get_boolean(ctx, -2) ? (1 << 1) : 0) |
              (duk_get_boolean(ctx, -1) ? 1 : 0);
```

### 数値

数値型は IEEE の double であり、±無限大と NaN 値を含む。ゼロの符号も保存される。IEEE doubleは、53ビットまでのすべての整数を正確に表現する。

IEEE doubleは、NaN値に対して追加の信号ビットを持つことができる。これらのビットは、Duktape内部のタグ付き型表現（8バイトのパック値使用時）で使用されるため、Duktape APIにおけるNaN値は正規化されます。具体的には、あるNaN値を値スタックにプッシュすると、別の（正規化された）NaN値が出てくることがあります。NaN がそのままの形で保存されることを当てにしないように。


### 文字列

文字列スタックタイプは、プレーン文字列とプレーンシンボル（ES2015 で導入）の両方を表現するために使用されます。文字列は、ある長さの任意のバイト列であり、内部に NUL (0x00) 値を含むことができます。文字列は、C言語のコーディングの便宜上、常に自動的にNULで終端されます。NULターミネーターは文字列の長さの一部としてカウントされません。例えば、文字列 "foo" はバイト長 3 で、メモリには { 'f', 'o', 'o', '\0' } という形式で格納されます。NUL終端が保証されているため、アプリケーションで内部NULが問題にならない限り、文字列は常に単純なconst char *を使って指定することができます。呼び出し側のコードは、Duktapeが保持する文字列データを直接参照することができます。このような文字列データ・ポインタは、Duktapeヒープ内で文字列に到達可能である限り有効です（そして安定しています）。

文字列は効率化のために内部化されており、ある文字列のコピーは一度に1つだけ存在します。文字列は不変であり、Cコードを呼び出しても絶対に変更してはいけません。変更すると、診断が困難な非常に不可思議な問題が発生します。

ECMAScript の文字列は、U+0000 から U+FFFF までの任意の 16 ビットのコードポイントを含むことができますが、BMP 以外のコードポイントを表現することはできません。これは、ECMAScriptの標準では文字列がこのように定義されているためです。Duktapeでは、ECMAScriptの文字列はCESU-8エンコーディングでエンコードされています。CESU-8は、サロゲートペアの範囲（U+D800からU+DFFF）のコードポイントを直接エンコードすることができる（UTF-8では禁止）ことを除いて、UTF-8と一致しています。CESU-8 は、UTF-8 と同様、すべての 7 ビ ッ ト ASCII キ ャ ラ ク タ を そ の ま ま符号化 し ますので、 C コ ー ド に と っ ては好都合です。例えば

- U+0041 ("A") は 41 にエンコードされます。
- U+1234 (ETHIOPIC SYLLABLE SEE) は e1 88 b4 にエンコードする。
- U+D812 (高位サロゲート) は ed a0 92 にエンコードされる。これは無効なUTF-8となる。

また、Duktapeは内部で拡張文字列を使用しています。U+10FFFFまでのコードポイントはUTF-8で表現でき、それ以上のコードポイントは32ビットいっぱいまで拡張UTF-8で表現できます。Duktapeが使用する拡張UTF-8のエンコーディングは、以下の表の通りです。先頭バイトは2進数で示し（データビットを示す "x"）、継続バイトは "C "で示します（ビット列10xxxxxxxを示す）。


| Codepoint range | Bits | Byte sequence | Notes |
| ---- | ---- | ---- | ---- |
| U+0000 to U+007F             | 7  | 0xxxxxxx             | |
| U+0080 to U+07FF             | 11 | 110xxxxx C           | |	
| U+0800 to U+FFFF             | 16 | 1110xxxx C C         | U+D800 to U+DFFF allowed (unlike UTF-8) |
| U+1 0000 to U+1F FFFF        | 21 | 11110xxx C C C       | Above U+10FFFF allowed (unlike UTF-8) |
| U+20 0000 to U+3FF FFFF      | 26 | 111110xx C C C C     | |	
| U+400 0000 to U+7FFF FFFF    | 31 | 1111110x C C C C C   | |
| U+8000 0000 to U+F FFFF FFFF | 36 | 11111110 C C C C C C | Only 32 bits used in practice (up to U+FFFF FFFF) |


U+7FFFFFFFF以上のコードポイントに対するエンコーディングの欠点は、先頭バイトが0xFEになることで、ユニコードのバイトオーダーマーカーエンコーディングと矛盾することです。これは、Duktapeの内部使用では実用的な懸念事項ではありません。

最後に、無効な拡張UTF-8バイト・シーケンスは、Symbol値を表すなどの特別な目的で使用されます。無効な拡張UTF-8/CESU-8バイト・シーケンスは、（CESU-8である）標準のECMAScript文字列と衝突することはなく、オブジェクトのプロパティ・テーブル内できれいに分離されたまま残ります。詳しくは Symbols と symbols.rst を参照してください。

無効な拡張 UTF-8 シーケンスを持つ文字列は、C コードから値スタックにプッシュでき、ECMAScript 関数に渡すこともできますが、2 つの注意点があります。

- 無効なバイト列が Symbol を表現するために使用される内部フォーマットに一致する場合、その値は ECMAScript コードに対して文字列ではなく Symbol として表示されます。例えば、typeof val は symbol となる。
- 無効なバイト列に対する文字列操作の挙動は十分に定義されておらず、結果は様々で、Duktapeのマイナーバージョンアップでも変更される可能性があります。


### オブジェクト

オブジェクト型には、ECMAScript のオブジェクトや配列、関数、スレッド（コルーチン）、バッファ・オブジェクトが含まれます。言い換えれば、プロパティを持つものはすべてオブジェクトです。プロパティは、文字列のキーと任意の値（未定義を含む）を持つキーと値のペアである。

オブジェクトはガベージコレクションのファイナライゼーションに参加することができます。


### バッファ

プレーン バッファ タイプは、ユーザー データ用の生のバッファです。Uint8Array や Node.js Buffer のような標準的なバッファ・オブジェクト・タイプよりもメモリ効率がよいです。プレーンバッファーのサブタイプは3つあります。



| Buffer sub-type | Data pointer | Resizable | Memory managed by | Description |
| ---- | ---- | ---- | ---- | ---- |
| Fixed | Stable, non-NULL | No | Duktape | バッファのサイズは作成時に固定され、メモリはDuktapeによって自動的に管理されます。固定バッファは、不変の（安定した）非NULLデータポインタを持ちます。 |
| Dynamic | Unstable, may be NULL | Yes | Duktape | バッファサイズは作成後に変更可能、メモリはDuktapeが自動管理。サイズ変更を可能にするために、内部で2つのメモリ割り当てが必要。バッファのサイズを変更すると、データ・ポインタが変更される可能性があります。ゼロ・サイズのバッファは、NULLデータ・ポインタを持つ可能性があります。 |
| External | Unstable, may be NULL | Yes | Duktape and user code | バッファ・データは外部で確保されます。Duktapeはヒープに割り当てられたバッファ・ヘッダ構造を割り当て、管理し ます。一方、データ領域のポインタと長さはユーザー・コードによって明示的に設定 されます。外部バッファは、バッファが Duktape ヒープ外のデータ構造（例えば、グラフィック・ライブラリによって割り当てられたフレーム・バッファ）を指すようにするのに便利です。ゼロ・サイズのバッファは、NULLデータ・ポインタを持つ可能性があります。 |


文字列とは異なり、バッファのデータ領域は自動的にNUL終端とならないため、呼び出し側のコードは現在割り当てられているバッファのサイズを超えるバイトにアクセスしてはいけません。ゼロサイズの動的バッファや外部バッファのデータポインタは NULL である可能性がありますが、固定バッファは常に NULL でないデータポインタを持ちます。

固定バッファと動的バッファは自動的にガベージコレクションされます。これはまた、Cコードが、バッファがDuktapeから到達可能でない限り、バッファ・データ・ポインタを保持してはならないことを意味します（例えば、アクティブな値スタックに存在する場合など）。外部バッファのデータ領域は自動的にガベージ・コレクトされないため、ユーザー・コードにはそのライフ・サイクルを管理する責任があります。また、ユーザー・コードは、外部バッファがもはや有効でない（あるいはまだ有効でない）ときに、外部バッファの値がアクセスされないようにする必要があります。

プレーンなバッファは Uint8Array オブジェクトを大きく模倣しており、ArrayBuffer や型付き配列などを扱う際の、非標準的でメモリ効率の良い代替手段となっています。標準のバッファオブジェクトはプレーンバッファの上に実装されており、例えば ArrayBuffer はプレーンバッファにバックアップされています。より詳細な説明は Buffer objects を参照してください。


いくつかの注意点があります。

バッファのインデックスに書き込まれる値は番号強制なので、一文字の値を代入しても期待通りにはいかないことが多い。例えば、 buf[123] = 'x' とすると、 ToNumber('x') = 0 としてバッファに 0 が書き込まれる。分かりやすくするために、 buf[123] = 0x78 のような数値のみを代入すると良い。

例えば、x = buf[123] または buf[123] = x のように、プレーンバッファの値の数値インデックスの読み書きのための高速なパスが存在します。

バッファの仮想プロパティは現在 defineProperty() に実装されていませんので、 defineProperty() でバッファのインデックスやバッファの長さを書き込むことはできません (書き込もうとすると TypeError が発生します)。


### ポインター

ポインター型は生の、解釈されないCポインターで、本質的にはvoid *です。ポインターはネイティブ・オブジェクト（メモリ割り当て、ハンドルなど）を指すために使用できますが、Duktapeはその用途を知らないので、自動的にガベージ・コレクトされることはありません。しかし、1つ以上のポインターをオブジェクトの中に入れて、オブジェクト・ファイナライザーを使って、ポインターに関連するネイティブ・リソースを解放することができます。


### Lightfunc（軽量関数）

lightfunc 型は、Duktape/C の関数ポインタと小さな制御フラグのセットを、ヒープを個別に割り当てる必要のない単一のタグ付き値にパックしたものです。制御フラグ(現在16ビット)は、以下のものをコード化します。(1) Duktape/C関数が期待するスタック引数の数（0～14またはvarargs）、 (2) 仮想長プロパティ値（0～15）、および (3) マジック値（-128～127）です。

Lightfuncsは、Duktape C APIでは別のタグ付きタイプですが、ECMAScriptコードでは、ほとんどFunctionオブジェクトのように振る舞います。通常のFunctionオブジェクトと比較すると、大きな制限があります。

- Lightfuncs は、独自のプロパティを保持することができません。Lightfuncs には、トレースバックに表示される固定の仮想 .name プロパティと、仮想 .length プロパティがあります。その他のプロパティは Function.prototype から継承されます。
- Lightfuncs はコンストラクタ関数として使用できますが、.prototype プロパティを持つことはできません。Object.prototype （デフォルト）を継承しないオブジェクトを構築する必要がある場合は、（a）コンストラクタで明示的にインスタンスを構築して返すか、（b）コンストラクタでデフォルト インスタンスの内部プロトタイプを明示的にオーバーライドする必要があります。
- Lightfunc はアクセサ・プロパティ（ゲッター/セッター）として使用できますが、実際の関数に変換されるため、メモリの利点が失われます。test-dev-lightfunc-accessor.js を参照してください。
- Lightfunc はプリミティブな型なのでファイナライザを持つことができず、参照カウントフィールドを持たず、ガベージコレクションにも参加しません。test-dev-lightfunc-finalizer.js を参照してください。

Lightfuncs は、通常の Function オブジェクトのメモリへの影響が問題となるような、非常に低メモリの環境で有用です。詳しくは Function objects を見てください。


## API の C 型

Duktape API は、エキゾチックなプラットフォームへの移植性を確保するために、 duk_int_t, duk_idx_t, duk_ret_t のような typedef-wrapped C 型をほぼ独占的に使用しています。ほとんどのプラットフォームでは、これらは符号付きまたは符号なしintに直接対応します。ラッパーは、通常の型の仮定（32ビットintを持つような）が保持されないプラットフォームをサポートすることを可能にします。詳細な議論はWikiのAPI C typesを参照してください。

ベストプラクティスのまとめ。

- 変数の宣言時には、移植性を高めるために、duk_idx_tやduk_ret_tのようなDuktape API型を使ってください。あるいは、（longのような）普通の型を使うこともできますが、コードの移植性は低下し、警告を避けるためにキャストを使用する必要があるかもしれません。
- printf()とduk_push_sprintf()のフォーマットでは、Duktape型をワイド整数型にキャストし、標準的なフォーマット指定子を使用します。例： printf("Result: %ld\n", (long) duk_get_int(ctx, -3));.
- 移植性を高めるため、16ビット以上の定数にはL（またはUL）接尾辞を使用します。int型と同様に、接尾辞のない整数型定数は16ビット幅しか保証されません。サフィックス L をつけると、最低でも 32 ビット幅の定数が保証されます。例： duk_push_int(ctx, 1234567L);.


## タイプ・アルゴリズム

このセクションでは、比較や強制などの型に関連するECMAScriptアルゴリズムが、どのようにDuktapeカスタム型に拡張されるかについて説明します。Duktape特有の型アルゴリズム（ToBuffer()とToPointer()）も説明します。


### 表記方法

値がどのように比較されるかを示すために、次のような省略記法が使われます。

| 値 | 説明 |
| ---- | ---- |
| t | 真と比較する |
| f | 偽と比較する |
| s | 単純比較：ブーリアン同士、文字列同士（文字列の内容を比較する）|
| n | 数値の比較。NaN 値は偽を比較し、0 は符号に関係なく真を比較します (例: +0 == -0)。 |
| N | SameValue での数値比較。NaN 値は真を比較し、0 は符号に関係なく比較します (例: SameValue(+0,-0) は偽) |
| p | ヒープポインタの比較 |
| L | lightfuncの比較： Duktape/Cの関数ポインタと内部制御フラグ（「マジック」値を含む）が等しいと見なすには、一致する必要があります。 |
| 1 | string vs. number: ToNumber()で文字列を強制し、比較を再試行。 |
| 2 | boolean vs. any: ToNumber() で boolean を 0 または 1 に固定し、比較を再試行。 |
| 3 | object vs. string/number: ToPrimitive() で object を強制し、比較を再試行。 |

> Booleanオブジェクト、Stringオブジェクト、Numberオブジェクトは、自動的にアンボックスされるのではなく、他のオブジェクトと同様に比較されることに注意してください。例えば、非厳格な等式では、プレーンな文字列の値をバイト単位で比較しますが、Stringオブジェクトはオブジェクト参照で比較します（他のオブジェクトと同様）。


### 等価性（非厳格）

非厳格な等式比較は、標準型についてはThe Abstract Equality Comparison Algorithmで規定されています。カスタム型の動作は以下の通りです。

- Buffer: プレーンバッファーはヒープポインタ（参照）によって比較され、内容の比較は行われません。これはUint8Arrayの動作と一致します。
- ポインター：他の型との比較はfalseを返します。ポインタとの比較は、ポインタの値が同じ場合にのみ、真を返します。特に、数値とポインタの比較はfalseを返すことに注意してください。これは少し直感的でないように思えますが、数値は 64 ポインターを正確に表すことができないので、数値とポインターを比較するとエラーが発生しやすくなる可能性があります。
- Lightfunc: 他の型と比較すると、false が返されます。lightfuncとの比較は、Duktape/C関数ポインタと内部制御フラグ（「マジック」値を含む）の両方が一致する場合にのみ、真を返します。たとえ、Functionオブジェクトがlightfuncをオブジェクトに強制することによって作成されたとしても、lightfuncは通常のFunctionオブジェクトと等しく比較されないことに注意してください。

標準的な動作とDuktapeカスタム・タイプの動作は、以下の表にまとめられています。


|  | und | nul | boo | num | str | obj | buf | ptr | lfn |
| ---- | ---- | ---- | ---- | ---- | ---- | ----| ---- | ---- | ---- |
| und | t | t | f | f | f | f | f | f | f |
| nul |   | t | f | f | f | f | f | f | f |
| boo |   |   | s | 2 | 2 | 2 | f | f | f |
| num |   |   |   | n | 1 | 3 | f | f | f |
| str |   |   |   |   | s | 3 | f | f | f |
| obj |   |   |   |   |   | p | f | f | f |
| buf |   |   |   |   |   |   | p | f | f |
| ptr |   |   |   |   |   |   |   | s | f |
| lfn |   |   |   |   |   |   |   |   | L |


### 厳密な等価性

厳密な等式はより単純で、単純さとパフォーマンスのために可能な限り望ましいものです。これは、標準的な型のための厳密な等式比較のアルゴリズムで説明されています。カスタム型の動作は以下の通りです。

- バッファ: 非厳格な等式と同様です。
- ポインタ：非厳格な等価性のようなもの。
- Lightfunc: 非厳格な等価性のようなものです。

標準の動作とDuktapeカスタム型の動作は、以下の表にまとめられています。

|  | und | nul | boo | num | str | obj | buf | ptr | lfn |
| ---- | ---- | ---- | ---- | ---- | ---- | ----| ---- | ---- | ---- |
| und | t | f | f | f | f | f | f | f | f |
| nul |   | t | f | f | f | f | f | f | f |
| boo |   |   | s | f | f | f | f | f | f |
| num |   |   |   | n | f | f | f | f | f |
| str |   |   |   |   | s | f | f | f | f |
| obj |   |   |   |   |   | p | f | f | f |
| buf |   |   |   |   |   |   | p | f | f |
| ptr |   |   |   |   |   |   |   | s | f |
| lfn |   |   |   |   |   |   |   |   | L |


### セイムバリュー

SameValue アルゴリズムは、ユーザー・コードから呼び出すのは簡単ではありません。これは、例えば Object.defineProperty() で、プロパティの値が変更されようとしているかどうかをチェックするときに使用されます。SameValue は厳密な等値比較よりもさらに厳しく、最も顕著なのは数値の比較方法が異なることです。これは、The SameValue algorithm for standard typesで規定されています。カスタム型の動作は以下の通りです。

- バッファ：非厳格（および厳密）等値のようなものです。
- ポインター：非厳格な（および厳密な）等価性のようなものです。
- Lightfunc: 非厳格な(および厳密な)等式と同じです。

標準の動作とDuktapeカスタム型の動作は、以下の表にまとめられています。


|  | und | nul | boo | num | str | obj | buf | ptr | lfn |
| ---- | ---- | ---- | ---- | ---- | ---- | ----| ---- | ---- | ---- |
| und | t | f | f | f | f | f | f | f | f |
| nul |   | t | f | f | f | f | f | f | f |
| boo |   |   | s | f | f | f | f | f | f |
| num |   |   |   | N | f | f | f | f | f |
| str |   |   |   |   | s | f | f | f | f |
| obj |   |   |   |   |   | p | f | f | f |
| buf |   |   |   |   |   |   | p | f | f |
| ptr |   |   |   |   |   |   |   | s | f |
| lfn |   |   |   |   |   |   |   |   | L |


### 型の変換とテスト

カスタム型は、型変換とテストについて説明したECMAScriptの強制力に対して、以下のように動作します（すでに上で説明したSameValueは除く）。

|                      | buffer                                                                  | pointer                                      | lightfunc                                    |
| -------------------- | ----------------------------------------------------------------------- | -------------------------------------------- | -------------------------------------------- |
| DefaultValue         | Usually "[object Uint8Array]"; like Uint8Array                          | TypeError                                    | "light_\<PTR\>_\<FLAGS\>" (toString/valueOf) |
| ToPrimitive          | Usually "[object Uint8Array]"; like Uint8Array                          | identity                                     | "light_\<PTR\>_\<FLAGS\>" (toString/valueOf) |
| ToBoolean            | true                                                                    | false for NULL pointer, true otherwise       | true                                         |
| ToNumber             | ToNumber(String(buffer)), usually ToNumber("[object Uint8Array]") = NaN | 0 for NULL pointer, 1 otherwise              | NaN                                          |
| ToInteger            | same as ToNumber; usually 0                                             | same as ToNumber                             | 0                                            |
| ToInt32              | same as ToNumber; usually 0                                             | same as ToNumber                             | 0                                            |
| ToUint32             | same as ToNumber; usually 0                                             | same as ToNumber                             | 0                                            |
| ToUint16             | same as ToNumber; usually 0                                             | same as ToNumber                             | 0                                            |
| ToString             | Usually [object Uint8Array]; like Uint8Array                            | sprintf() with %p format (platform specific) | "light_\<PTR\>_\<FLAGS\>"                    |
| ToObject             | Uint8Array object (backs to argument plain buffer)                      | Pointer object                               | Function object                              |
| CheckObjectCoercible | allow (no error)                                                        | allow (no error)                             | allow (no error)                             |
| IsCallable           | false                                                                   | false                                        | true                                         | 
| SameValue            | (covered above)                                                         | (covered above)                              | (covered above)                              |


バッファが文字列強制されると、Uint8Arrayのように振る舞い、その結果は通常"[object Uint8Array]"となります。この動作はDuktape 2.0で変更されました。バッファの内容から文字列を生成するには、Node.jsのBufferバインディングやEncoding APIなどを使用します。

バッファがオブジェクト強制されると、新しい Uint8Array オブジェクトが作成され、新しい ArrayBuffer がプレーン バッファにバックアップされます (コピーは作成されません)。

Lightfunc が ToPrimitive() で強制されると、普通の関数のように動作します。それは Function.prototype.toString() で強制され、結果は（通常） ToString() 強制と同じになります。

lightfunc がオブジェクト強制されると、新しい Function オブジェクトが作成され、仮想プロパティ (name と length) と内部の "magic" 値が Function オブジェクトにコピーされます。


### カスタム強制（ToBuffer, ToPointer）

ToBuffer() は、例えば duk_to_buffer() API 呼び出しで、値がバッファ型に強制されるときに使用されます。強制は以下の通りです。

- バッファはそれ自身に強制される(identity)。同じバッファの値が返されます。
- その他の型（ポインタと lightfunc を含む）は、まず ToString で文字列強制され、次に結果の文字列がバイト単位で固定サイズのバッファにコピーされます。

ToPointer() の強制は、例えば、duk_to_pointer() の呼び出しで使用されます。この強制は次のようなものです。

- ポインタはそれ自身に強制される。
- ヒープで確保された型(文字列、オブジェクト、バッファ)は、その内部ヒープヘッダーを指すポインタ値に強制されます。このポインタは診断値のみを持つ。特に、バッファや文字列に対して返されるポインタは、バッファや文字列のデータ領域を指さないことに注意してください。(この強制はマイナーバージョンでも変更される可能性がありますので、依存しないようにしてください）。
- その他の型 (数値を含む) は、NULL ポインタを指すように強制されます。
- Lightfunc は NULL ポインタに強制されます。これは、C 関数ポインターを移植可能な方法で void * に強制できないためです。

オブジェクトが作成され、仮想プロパティ（名前と長さ、および内部の「マジック」値）が Function オブジェクトにコピーされます。


|          | ToBuffer                                     | ToPointer       |
| -------- | -------------------------------------------- | --------------- |
|undefined | buffer with "undefined"                      | NULL            |
|null      | buffer with "null"                           | NULL            |
|boolean   | buffer with "true" or "false"                | NULL            |
|number    | buffer with string coerced number            | NULL            |
|string    | buffer with copy of string data              | ptr to heap hdr |
|object    | buffer with ToString(value)                  | ptr to heap hdr |
|buffer    | identity                                     | ptr to heap hdr |
|pointer   | sprintf() with %p format (platform specific) | identity        |
|lightfunc | buffer with ToString(value)                  | NULL            |

> 現在、ToLightFunc()の強制はありません。Lightfuncは、Duktape C APIを使ってのみ作成することができます。


### 加算演算子

ECMAScript の加算演算子は The Addition operator (+) で指定されています。加算は、どちらかの引数が文字列である場合に特別な動作をします：もう一方の引数は文字列に強制され、その後文字列は連結されます。この動作は、以下のようにカスタム型にも拡張されます。

- 標準の型では、オブジェクトの値は最初に ToPrimitive() で強制され、プレーン バッファと lightfuncs は通常 ToString() で強制されます。プレーン バッファの場合、結果は通常 "[object Uint8Array]" になり、lightfuncs の場合は "[object Function]" になります。
- ポインタの値は、デフォルトの数値加算のケースに該当します。これらは ToNumber() で強制された後、数値として追加されます。NULL ポインタは 0 に、NULL 以外は 1 になります。

加算は、一般にカスタム型には有用ではありません。たとえば、2 つのプレーンなバッファを加算すると、結果は通常 "[object Uint8Array] [object Uint8Array]" となり、これは 2 つの Uint8Array インスタンスに対する標準的な加算の動作と同じになります。


### プロパティ・アクセス

プロパティ・アクセスのベース値としてプレーン・バッファまたはポインタが使用 される場合、プロパティは（初期の）組み込みプロトタイプ・オブジェクト（Uint8Array.prototype または Duktape.Pointer.prototype）から検索されることになります。これは、標準的な型の動作を模倣しています。

例えば

```sh
duk> buf = Duktape.dec('hex', '414243');  // plain buffer
= ABC
duk> buf.subarray();
= function subarray() {"native"}
duk> typeof buf.toString();
= string
```

Lightfuncs は、設定や書き込みができない仮想プロパティ（name と length）をいくつか持ち、残りのプロパティは Function.prototype を継承し、継承された通常の Function メソッドを呼び出すことができるようになっています。

```javascript
var bound = myLightFunc.bind('dummy', 123);
```


## Duktapeのビルトイン

このセクションでは、Duktape 固有の、そして ECMAScript 以外の組み込みオブジェクト、メソッド、および値についてまとめます。


### グローバルオブジェクトプロパティの追加

| プロパティ | 説明 |
| ---- | ---- |
| globalThis | グローバル・オブジェクト自体を参照します。proposal-global を参照してください。 |
| Duktape | Duktape組み込みオブジェクト。雑多な実装固有のものが含まれています。 |
| CBOR | cbor-jsをベースにしたCBOR実験用API。 |
| TextEncoder | WHATWG Encoding API の TextEncoder()。UTF-8エンコーディングで文字列をバッファに変換します。 |
| TextDecoder | TextDecoder() WHATWG Encoding APIより。UTF-8エンコーディングを使って、バッファを文字列に変換します。 |
| performance | High Resolution Time Level 2のperformance.now()。Navigation Timing の performance.timing のようなバインディングはサポートされていません。 |


### globalThis

グローバルオブジェクトそのものを参照します（proposal-globalを参照）。(バインディングは当初'global'という名前でしたが、いくつかのWebサイトが壊れたため変更されました。)。


### Duktapeオブジェクト

| プロパティ | 説明 |
| ----  | ---- |
| version | Duktapeのバージョン番号：(メジャー * 10000) + (マイナー * 100) + patch. |
| env | エンディアンとアーキテクチャのような最も重要で効果的なオプションのバージョン依存の要約。 |
| fin | オブジェクトのファイナライザーを設定または取得する。 |
| enc | 値をエンコードする(hex, base-64, JX, JC)。Duktape.enc('hex', 'foo')。 |
| dec | 値（hex、base-64、JX、JC）をデコードする。Duktape.dec('base64', 'Zm9v')。 |
| info | 値の内部情報（ヒープアドレスやアロックサイズなど）をバージョン固有のフォーマットで取得する。C API の同等品は duk_inspect_value() である。 |
| act | コールスタックエントリに関する情報を取得する。C APIでは、duk_inspect_callstack_entry()がこれに相当する。 |
| gc | マーク・アンド・スイープ・ガベージ・コレクションをトリガする。 |
| compact | 値（オブジェクト）に割り当てられたメモリをコンパクトにする。 |
| errCreate | 作成されたエラーを修正/置換するためのコールバック。 |
| errThrow | スローされようとしているエラーを修正／置換するためのコールバック。 |
| Pointer | ポインタのコンストラクタ(関数)。 |
| Thread | スレッド コンストラクタ（関数）。 |


#### version

versionプロパティは、バージョンに基づく機能の検出と動作を可能にします。バージョン番号は直接比較することができます：論理的に高いバージョンは、数値的にも高くなります。例えば

```javascript
if (typeof Duktape !== 'object') {
    print('not Duktape');
} else if (Duktape.version >= 20403) {
    print('Duktape 2.4.3 or higher');
} else if (Duktape.version >= 10500) {
    print('Duktape 1.5.0 or higher (but lower than 2.4.3)');
} else {
    print('Duktape lower than 1.5.0');
}
```


プレリリースのバージョンの値は、実際のリリースより1つ少なくなります。例えば、0.12.0プレリリースは1199、1.3.0プレリリースは10299となります。バージョニングを参照してください。

機能検出を行う際には、Duktapeが存在するかどうかを確認することを忘れないでください。あなたのコードは通常、できるだけ多くのエンジンで動作するはずです。チェックの際に、識別子の直接参照を使うというよくある落とし穴は避けてください。

```javascript
// Bad idea: ReferenceError if missing
if (!Duktape) {
    print('not Duktape');
}

// Better: check through 'this' (bound to global)
if (!this.Duktape) {
    print('not Duktape');
}

// Better: use typeof to check also type explicitly
if (typeof Duktape !== 'object') {
    print('not Duktape');
}
```


#### env

envは、最も重要で効果的なコンパイルオプションを、バージョン固有の、かなり不可解な方法で要約したものです。この形式はバージョンに依存し、プログラム的に解析することは意図されていません。これは主に開発者のために役立ちます（値を設定するコードについては duk_hthread_builtins.c を参照してください）。

Duktape 1.1.0 の例です。

```c
ll u n p2 a4 x64 linux gcc     // l|b|m integer endianness, l|b|m IEEE double endianness
                               // p|u packed/unpacked tval
                               // n|various, memory optimization options (n = none)
                               // p1|p2|p3 prop memory layout
                               // a1|a4|a8: align target
                               // x64|x86|arm|etc: architecture
                               // linux|windows|etc: operating system
                               // gcc|clang|msvc|etc: compiler
```


エンディアンは、lがリトルエンディアン、bがビッグエンディアン、mがミックスエンディアン（レガシーARMデバイス、The FPAアーキテクチャなど参照）を表わします。


#### fin()

単一の引数で呼び出された場合、オブジェクトの現在のファイナライザを取得します。

```javascript
var currFin = Duktape.fin(o);
```


2つの引数で呼ばれた場合、オブジェクトのファイナライザを設定する（未定義を返す）。

```javascript
Duktape.fin(o, function(x) { print('finalizer called'); });
Duktape.fin(o, undefined);  // disable
```

#### enc

enc() は、その引数の値を選択されたフォーマットにエンコードします。最初の引数はフォーマット（現在サポートされているのは "hex", "base64", "jx", "jc"）、2番目の引数はエンコードする値、それ以降の引数はフォーマットに依存するものである。

hex "と "base64 "の場合、バッファの値はそのままエンコードされ、その他の値は文字列強制された後、内部バイト表現（拡張UTF-8）がエンコードされる。その結果が文字列となる。例えば、ある文字列をbase64にエンコードする場合。

```javascript
var result = Duktape.enc('base64', 'foo');
print(result);  // prints 'Zm9v'
```


jx"、"jc "の場合、フォーマット名に続く引数リストは、JSON.stringify()と同様、value、replacer（オプション）、スペース（オプション）である。たとえば

```javascript
var result = Duktape.enc('jx', { foo: 123 }, null, 4);
print(result);  // prints JX encoded {foo:123} with 4-space indent
```


#### dec()

dec() は enc() の逆機能を提供します。

hex" と "base64" については、入力値はまず文字列強制されます (文字列をデコードすることにのみ意味があります)。結果は常にプレーンなバッファとなります。たとえば

```javascript
var result = Duktape.dec('base64', 'Zm9v');
print(typeof result, result);  // prints 'object foo'
```


もし、プレーンなバッファよりも完全なUint8Arrayを好むのであれば、以下のように結果を強制することができます。

```javascript
var result = Object(Duktape.dec('base64', 'Zm9v'));
print(typeof result, result);  // prints 'object foo'
```


文字列の値を取得したい場合は、以下のようにプレーンバッファを文字列に変換することができます。

```javascript
// Use TextDecoder which decodes the input as UTF-8.  You can also use
// the Node.js Buffer binding to achieve a similar result.

var result = new TextDecoder().decode(Duktape.dec('base64', 'Zm9v'));
print(typeof result, result);  // prints 'string foo'
```


jx"、"jc "の場合、フォーマット名に続く引数リストは、JSON.parse()と同様、text、reviver（オプション）である。例えば

```javascript
var result = Duktape.dec('jx', "{foo:123}");
print(result.foo);  // prints 123
```


#### info()

Duktape.info()は、その引数値に関連する内部情報を公開するオブジェクトを返します。現在のフィールドの説明については、 duk_inspect_value() を参照してください。

> 結果オブジェクトのプロパティはバージョン保証の対象外であり、マイナーバージョン（パッチバージョンは除く）であっても互換性のない形で変更される可能性があります。


#### act()

コールスタックのエントリに関する情報を取得します。1 は最上位 (最内周) のエントリ、-2 はその下のエントリなどです。コールスタックエントリを記述したオブジェクトを返すか、エントリが存在しない場合は未定義を返す。現在のフィールドの説明については、 duk_inspect_callstack_entry() を参照してください。

> 結果オブジェクトのプロパティはバージョン保証の対象外であり、マイナーバージョンでも互換性のない形で変更される可能性がある（パッチバージョンは不可）。

例:

```javascript
function dump() {
    var i, t;
    for (i = -1; ; i--) {
        t = Duktape.act(i);
        if (!t) { break; }
        print(i, t.lineNumber, t.function.name, Duktape.enc('jx', t));
    }
}

dump();
```


この例をコマンドラインツールで実行すると、現在、次のようなものが表示されます。

```javascript
-1 0 act {lineNumber:0,pc:0,function:{_func:true}}
-2 4 dump {lineNumber:4,pc:16,function:{_func:true}}
-3 10 global {lineNumber:10,pc:5,function:{_func:true}}
```


興味深い項目は lineNumber と function で、これは例えば関数名などを提供します。

Duktape.act() を使って、現在の行番号を取得するヘルパーを実装することも可能です。

```javascript
function getCurrentLine() {
    'use duk notail';

    /* Tail calls are prevented to ensure calling activation exists.
     * Call stack indices: -1 = Duktape.act, -2 = getCurrentLine, -3 = caller
     */

    var a = Duktape.act(-3) || {};
    return a.lineNumber;
}
print('running on line:', getCurrentLine());
```


#### gc()

強制的なマーク＆スイープ収集のトリガーをかける。この呼び出しは、オプションで整数の flags フィールドを取る。定数については、 duktape.h を参照のこと。


#### compact()

ターゲットオブジェクトに割り当てられたメモリを最小にする。C API コール duk_compact() と同じですが、ECMAScript コードからアクセス可能です。オブジェクト以外の引数で呼び出された場合、この呼び出しはノー・オペレーションです。引数の値は関数によって返され、これにより、以下のようなコードが可能になります。

```javascript
var obj = {
    foo: Duktape.compact({ bar: 123 })
}
```


この呼び出しは、オブジェクトが新しいプロパティを獲得する可能性が低いことがわかっているが、万が一獲得した場合にオブジェクトを封印またはフリーズしたくない場合に有用である。


#### errCreate() と errThrow()

これらは、ユーザーコードによって設定され、エラー作成時（errCreate）またはエラースロー時（errThrow）に処理/置換することができる。どちらの値も初期状態では存在しません。

詳細はエラーハンドラ(errCreateとerrThrow)を参照してください。


### Duktape.Pointer (コンストラクタ) 

| プロパティ | 説明 |
| ---- | ---- |
| prototype | Pointer オブジェクトのプロトタイプ |


Pointer コンストラクタは、通常の関数としてもコンストラクタとしても呼び出すことができる関数です。

- 関数として呼び出された場合は、カスタムの ToPointer クラスタを使って最初の引数をポインタに変換します。戻り値は普通のポインタです（Pointerオブジェクトではありません）。
- コンストラクタとして呼び出された場合、カスタムのToPointer強制を使って最初の引数をポインタに強制変換します。内部値は、強制終了の結果得られたポインタである Pointer オブジェクトを返す。新しく作成されたPointerの内部プロトタイプはDuktape.Pointer.prototypeオブジェクトになります。


### Duktape.Pointer.prototype

| プロパティ | 説明 |
| ---- | ---- |
| toString | Pointer を印字可能な文字列に変換する |
| valueOf | Pointer が保持するプリミティブポインタの値を返す |


toString() と valueOf は、プレーンなポインタと Pointer オブジェクトの両方をこのバインディングとして受け付けます。これにより、次のようなコードが可能になります。

```javascript
var plain_ptr = Duktape.Pointer({ test: 'object' });
print(plain_ptr.toString());
```


### Duktape.Thread (コンストラクタ)

| プロパティ | 説明 |
| ---- | ---- |
| prototype | Thread オブジェクトのプロトタイプ |
| resume | 値またはエラーでターゲットスレッドを再開する。引数： ターゲットスレッド、値、値を投げるかどうかを示すフラグ（オプション、デフォルトfalse） |
| yield | 現在のスレッドから値またはエラーを投げる。引数： value、value を投げるかどうかのフラグ（オプション、デフォルトfalse） |
| current | 現在実行中のスレッドオブジェクト |


Threadコンストラクタは、通常の関数としてもコンストラクタとしても呼び出すことができる関数です。動作はどちらの場合も同じです。

最初の引数は関数であるかどうかチェックされます（もしそうでなければ TypeError が投げられます）。この関数は ECMAScript の関数でなければなりません（バインドまたは非バインド）。戻り値は、初期関数が引数関数であると記録された新しいスレッドである（この関数は新しいスレッドが最初に再開されたときに実行を開始する）。新しく作られたスレッドの内部プロトタイプは、Duktape.Thread.prototypeオブジェクトになります。


### Duktape.Thread.prototype

| Property | Description |
| ---- | ---- |
| No properties at the moment. | |


### CBOR

CBOR (Concise Binary Object Representation) は、任意の構造化された値のためのコンパクトなバイナリ符号化方式です。JSONよりも高速で、一部のECMAScriptの値をより正確に符号化することができる。JSONの代替として、状態のシリアライゼーションやIPCなどに適している。参照。

CBOR - Concise Binary Object Representation (cbor.io) を参照。
コンサイスバイナリオブジェクト表現(CBOR) (RFC 7049)
CBORオブジェクトは、任意のECMAScriptの値をCBORに、またはその逆に変換するエンコード/デコード関数を提供します。公式のCBOR APIはまだないので、今のところAPIはcbor-jsをベースにしています。また、CBORのためのC言語のAPIもあります。

> このバインディングは現在実験的なものであり、詳細は時間の経過とともに変更される可能性があります。例えば、ECMAScript の値をより正確にシリアライズするためのカスタム CBOR タグが登録されつつあります。

例:

```javascript
var enc = CBOR.encode([ 'foo', 'bar', { quux: true } ]);
print(Duktape.enc('hex', enc));  // = 8363666f6f63626172a16471757578f5
var dec = CBOR.decode(enc);
print(Duktape.enc('jx', dec));   // = ["foo","bar",{quux:true}]
```


### TextEncoder

TextEncoder() は WHATWG エンコーディング API の一部で、 文字列を UTF-8 エンコーディングでバッファ (Uint8Array) に格納するためのクリーンな方法を提供します。サロゲートペアは処理中に結合されます。例えば

```javascript
var str = '\u{1f4a9}';                   // non-BMP codepoint
print(str.length);                       // length is 2, represented as a surrogate pair
var u8 = new TextEncoder().encode(str);
print(u8.length);                        // length is 4, a single UTF-8 codepoint
print(Duktape.enc('jx', u8));            // |f09f92a9|, UTF-8 bytes F0 9F 92 A9
```


# TextDecoder

TextDecoder() は WHATWG エンコーディング API の一部で、バッファを UTF-8 エンコーディングの文字列にデコードするためのすっきりした方法を提供します。BMP 以外のコードポイントは、結果の文字列の中でサロゲートペアとして表現されます。例えば

```javascript
var u8 = new Uint8Array([ 0xf0, 0x9f, 0x92, 0xa9 ]);  // a single non-BMP codepoint
var str = new TextDecoder().decode(u8);
print(str.length);                       // length is 2, represented as a surrogate pair
print(str.charCodeAt(0));                // 55357, high surrogate
print(str.charCodeAt(1));                // 56489, low surrogate
```


### performance

performance.now() は、指定されない原点からのミリ秒単位の単調時間 (利用可能な場合は端数を含む) を提供します。返り値は DUK_USE_GET_MONOTONIC_TIME() のもので、 DUK_USE_DATE_GET_NOW() にフォールバックしています。実際のモノトニック時間プロバイダが利用可能な場合、戻り値は日付/時間の調整による「タイムジャンプ」なしでリアルタイムで進むことが保証されます。これは、パフォーマンス測定、壁時計時間ではなく現在時刻を基準としたイベントのスケジューリング、レート制限などに有用です。例

```javascript
function testFunction() {
    for (var i = 0; i < 1e6; i++) {}
}

var t1 = performance.now();
testFunction();
var t2 = performance.now();
print('test took:', (t2 - t1), 'milliseconds');
```


performance.timeOriginは、現在（Duktape 2.2.0）、Duktapeでのセマンティクスが決定されるまで、意図的に欠落させています。

performance.timingのようなNavigation Timingバインディングは、現在サポートされていません。


## ポストES5の特徴

DuktapeはES2015（ES6）、ES2016（ES7）、およびそれ以降の仕様ドラフトからの機能を実装しています。現在の状況については、Wikiの記事「Post-ES5 features」を参照してください。

Duktapeのステータスはkangax/compat-tableの新しいリリースでも更新されます。


## カスタム動作

E5.1やその他の関連仕様から逸脱したDuktapeの動作についてまとめます。


### Duktapeビルトインとカスタム・タイプ 

Duktape組み込みは（もちろん）非標準であり、Duktape固有の機能へのアクセスを提供します。また、バッファ、ポインター、lightfunc タイプはカスタムです。


### 隠しシンボル

オブジェクトは、隠された Symbol キーを持つプロパティを持つことができます。これらは ES2015 Symbols に似ていますが、列挙されたり、Object.getOwnPropertySymbols()からも返されません。キーが意図的に無効な (拡張) UTF-8 表現を使用しているため、通常の ECMAScript コードはこのようなプロパティを参照することができません。


### "use duk notail" ディレクティブ

use duk notail" 指令は非標準です。これは、関数がテールコールされるのを防ぐものです。

### "const" はほとんど "var" のように扱われます

const キーワードは、最小限の非標準のセマンティクスでサポートされています (ECMAScript 6 で公式に定義されています)。詳しくは Const 変数を参照してください。

### Error オブジェクトと Function オブジェクトの追加プロパティ

Error オブジェクトと Function オブジェクトを参照してください。

非厳格な関数インスタンスは、E5/E5.1 仕様では呼び出し元のプロパティを持ちません。現実のコードではこのプロパティを期待するものがありますので、 DUK_USE_NONSTD_FUNC_CALLER_PROPERTY という設定オプションで有効にすることができます。

### 関数文

E5.1では、関数宣言がプログラムまたは関数のトップレベル表現の外側に現れることを許可していません。

```javascript
function test() {
    // point A
    try {
        throw new Error('test');
    } catch (e) {
        // This is a SyntaxError in E5.1
        function func() {
            print(typeof e);
        }
        // point B
    }
    // point C
}
```


これらの宣言は「関数文」とも呼ばれ、実世界のコード（test262テスト・スイートを含む）では非常に頻繁に登場するので、Duktapeでは許可しています。残念ながら、Javascriptエンジンによって使用されるセマンティクスがいくつかあります（ES2015では、残念ながら関数文のセマンティクスは指定されていません）。Duktapeは、V8の関数文の挙動に従います。

- Strict function: SyntaxErrorが投げられます（標準的な動作）。
- 非厳格な関数：関数文を通常の関数宣言のように扱い、概念的には関数の先頭に「持ち上げる」。
例として、上記の例では以下のような挙動となります。

```javascript
function test() {
    function func() {
        print(typeof e);
    }
 
    try {
        throw new Error('test');
    } catch (e) {
    }
}
```

上記の例のfunc()は、すでにポイントAで宣言され、呼び出し可能であり、ポイントA、B、Cのいずれにおいてもeバインディングにアクセスすることはできないだろう。


### RegExpのリニエンシー

ほとんどの ECMAScript エンジンは ECMAScript E5.1 仕様 (セクション 15.10.1 パターン) で保証されているよりも多くの構文をサポートしています。その結果、厳密な ECMAScript E5.1 正規表現構文では動作しないコードがかなり多くなっています。ウェブブラウザエンジンに期待される追加構文の多くは、ES2015 Annex B.1.4 Regular Expression Patterns に記載されています。しかし、Annex B Additional ECMAScript Features for Web Browsers の機能は、新しいコードには推奨されないことに注意してください。「これらの機能は、ECMAScript のコア言語の一部とはみなされません。プログラマは新しい ECMAScript コードを書くときに、これらの機能や動作を使用したり仮定したりしてはいけません。ECMAScript の実装は、その実装が Web ブラウザの一部であるか、または Web ブラウザが遭遇するのと同じレガシー ECMAScript コードを実行する必要がある場合を除いて、これらの機能を実装しないように推奨されています。"

Duktapeは、既存のコードをより良くサポートするために、一部のES2015 Annex Bの構文も許可しています。この非標準的な動作は、必要に応じて設定オプションでオフにすることができます。サポートされる追加構文の例をいくつか挙げます。

```javascript
  /{(\d+)}/    // unescaped left curly, digits, unescaped right curly; ES2015 Annex B
  /\{(\d+)\}/  // same, ES5 compliant

  /]/          // unescaped right bracket; ES2015 Annex B
  /\]/         // same, ES5 compliant

  /\$/         // literal dollar using escape; ES2015 Annex B
  /\u0024/     // same, ES5 compliant
```


### Setter/getter key 引数

ECMAScript の標準的な動作は、セッターとゲッターにはアクセスされるプロパティの名前を与えないことです。このため、複数のプロパティに対して一つのセッターやゲッターを再利用することができません。各プロパティに対して別々の関数が必要となり、不便であったり、メモリを浪費したりします。

Duktapeでは、プロパティ・キー名をセッターやゲッター関数への非標準の追加引数として提供しています。詳しくは、test-dev-nonstd-setget-key-argument.jsとProperty virtualizationを参照してください。DUK_USE_NONSTD_GETTER_KEY_ARGUMENT と DUK_USE_NONSTD_SETTER_KEY_ARGUMENT という設定オプションを無効にすると、標準に準拠した厳格な動作が可能になります。


### Object.setPrototypeOf and Object.prototype.__proto__ (ES2015)

[Object.setPrototypeOf and Object.prototype.\_\_proto\_\_]() を参照


### プロキシオブジェクト(ES2015)

Proxyオブジェクト（サブセット）を参照。


### JSON.stringify() は U+2028 と U+2029 をエスケープする

JSON.stringify()の標準的な動作は、U+2028とU+2029をエスケープせずに出力することです。これは、出力がウェブ・ページで使われたり、eval()で解析されたりしたときに、直感に反する動作につながります：U+2028とU+2029文字は行末とみなされ、構文エラー（終端がない文字列）につながります。Duktapeはこの問題を避けるために、デフォルトでU+2028とU+2029をエスケープします。設定オプションDUK_USE_NONSTD_JSON_ESC_U2028_U2029を無効にすると、準拠した動作をオンにすることができます。


### String.fromCharCode()は32ビットコードポイントを受け付けます

String.fromCharCode() の標準的な動作は、コードポイント値に対して ToUInt16() 強制を使用することです。DuktapeはデフォルトでToUint32()を使用し、非BMP文字列をより良くサポートします。DUK_USE_NONSTD_STRING_FROMCHARCODE_32BIT という設定項目を無効にすれば、強制的に準拠した動作をさせることが可能です。

### 配列インスタンスの数値インデックスの書き込み

デフォルトでは、Duktapeは、Arrayインスタンスへの書き込みに高速パスを提供します。高速パスは、数値インデックスが使用され（例： arr[7] = 'foo'）、いくつかの内部条件が満たされたときに有効になります。高速パスが採用された場合、DuktapeはArray.prototypeに矛盾するプロパティがないかチェックしません（実際のコードでは非常に稀です）。これにより、一般的な配列の書き込みが高速になります。この動作は非準拠ですが、Array.prototypeが数値キーを持つプロパティを持たない限り、外見上の差はありません。DUK_USE_NONSTD_ARRAY_WRITE と DUK_USE_ARRAY_PROP_FASTPATH という設定オプションを無効にすると、準拠した挙動をオンにすることができます。高速パスの動作の詳細については、以下を参照してください： test-misc-array-fast-write.js.


### TypedArrayバインディング

DuktapeはES2015 TypedArrayバインディングを提供しますが、いくつかの詳細はまだ修正されていません。例えば、オフセットと長さの値に対する引数の強制の小さな違いなどです。

プレーンバッファーのカスタムタイプは、ECMAScriptコードではUint8Arrayオブジェクトのように振る舞いますが、Duktape C APIでは別のタイプを持っています。


### Node.jsのBufferバインディング §。

DuktapeはNode.jsライクなBufferバインディングを提供します。Node.jsの動作とDuktapeの動作には、いくつかの違いがあります。これらの違いは以下の通りです。

- 他のバッファ・タイプとの相互運用性。ArrayBuffer、DataView、または型付き配列（Uint8Arrayなど）は、Node.jsのBufferが許されるところであれば、通常どこでも許されます。
^ バッファのデータは、割り当て時および連結時の totalLength が入力バッファの合計サイズを超えたときに、常にゼロになります。
- 読み込み/書き込みのオフセットと長さの引数は、noAssert が真であっても、メモリセーフな動作を保証するために常に検証されます。読み出しに失敗した場合はNaNを、書き込みに失敗した場合は0を返す。
- 部分的な読み込み/書き込みは決して行われない: 読み込み/書き込みの一部が有効なバッファの外にある場合、それは拒否される。
- オフセットや長さなどの引数の強制に若干の違いがある。
- 例えば、writeUInt8()を使って0x100を書き込む場合、TypeErrorを投げるのではなく、0x00に静かに強制されます。
- Duktapeは "utf8 "エンコーディングのみをサポートします（そして、スペリングのバリエーションは一切受け付けません）。ほとんどのAPIコールはエンコーディングの引数を無視し、文字列からバッファへの強制変換に暗黙のうちにUTF-8を使用します。
- UTF-8デコードの置換文字のアプローチは、Unicode Technical Committee Recommended Practice for Replacement Charactersに従っており、WHATWG Encoding API仕様と一致していますが、Node.js（少なくともバージョンv6.9.1まで）とは異なっています。


### Shebang コメントのサポート

duk_compile() フラグ DUK_COMPILE_SHEBANG により、shebang コメントのパースが可能になります。最初の行の最初のカラムに #!を付けると、その行はコメントとして扱われます。例えば

```ruby
#!/usr/bin/duk
print('Hello world!');
```


この機能は、DUK_USE_SHEBANG_COMMENTS の定義を解除することで無効にすることができます。


## カスタム JSON フォーマット

### ECMAScript の JSON の欠点

標準の JSON フォーマットは、ECMAScript で使用する場合、いくつかの欠点があります。

-未定義値や関数値はサポートされていません。
-NaN と無限大の値はサポートされていません。
-Duktapeのカスタム・タイプは、もちろんサポートされていません。
-BMP以上のコードポイントは、サロゲート・ペアとしてしか表現できない
-U+10FFFF以上のコードポイントは、サロゲート・ペアとしても表現できません。
-出力が印刷可能なASCIIでないため、不便なことが多い

これらの制限は、ECMAScript仕様の一部であり、より甘い動作を明示的に禁止しています。Duktapeは、よりプログラマフレンドリーな2種類のカスタムJSONフォーマットを提供しています。JXとJCで、以下に説明します。

### カスタムJXフォーマット

JXは、すべての値を非常に読みやすい方法でエンコードし、ほとんどすべての値を忠実にパースして返します（関数値は最も重要な例外です）。出力は純粋に印刷可能なASCIIで、U+FFFF以上のコードポイントはカスタムエスケープ形式でエンコードされ、オブジェクトキーの周りの引用符はほとんどの場合省略されます。JXはJSON互換ではありませんが、非常に読みやすいフォーマットで、デバッグやロギングなどに最も適しています。

JXは以下のように使用します。

```javascript
var obj = { foo: 0/0, bar: [ 1, undefined, 3 ] };
print(Duktape.enc('jx', obj));
// prints out: {foo:NaN,bar:[1,undefined,3]}

var dec = Duktape.dec('jx', '{ foo: 123, bar: undefined, quux: NaN }');
print(dec.foo, dec.bar, dec.quux);
// prints out: 123 undefined NaN
```


### カスタム JC フォーマット§。

JCは、すべての値を標準的なJSONにエンコードします。標準的なJSONでサポートされていない値は、アンダースコアで始まるマーカーキーを持つオブジェクトとしてエンコードされます（例： {"_ptr": "0xdeadbeef"}）。このような値は、通常のオブジェクトとしてパースバックされます。しかし、多かれ少なかれ、手動でそれらを復活させることができます。U+FFFF以上のコードポイントは、"U+nnnnn "のフォーマットでプレーンな文字列データとしてエンコードされます(例: U+0010fedc)。

JCは以下のように使用します。

```javascript
var obj = { foo: 0/0, bar: [ 1, undefined, 3 ] };
print(Duktape.enc('jc', obj));
// prints out: {"foo":{"_nan":true},"bar":[1,{"_undef":true},3]}

var dec = Duktape.dec('jc', '{ "foo": 123, "bar": {"_undef":true}, "quux": {"_nan":true} }');
print(dec.foo, dec.bar, dec.quux);
// prints out: 123 [object Object] [object Object]
```


JCデコーダは、現時点では、基本的に標準のJSONデコーダと同じです。すべてのJC出力は有効なJSONであり、カスタム構文は必要ありません。例で示したように、カスタム値（{"_undef":true}など）は自動的には復活しません。それらは、代わりに普通のオブジェクトとしてパースバックされます。


### U+FFFF以上のコードポイントと無効なUTF-8データについて

すべての標準ECMAScript文字列は、内部的には有効なCESU-8データなので、U+FFFF以上のコードポイントに対する動作は、コンプライアンス上の問題を引き起こすことはありません。しかし、Duktapeの文字列は、拡張UTF-8コードポイントを含み、さらに無効なUTF-8データを含む可能性があります。

標準のECMAScript JSON APIを含むDuktape JSON実装は、無効なUTF-8データを処理するために置換文字を使用します。結果として得られる文字列は少し奇妙に見えるかもしれませんが、この動作はエラーを投げるよりも望ましいものです。


### JSONフォーマット例

以下の表は、各エンコーディングで異なる値がどのようにエンコードされるかをまとめたものです。


| Value        | Standard JSON  | JX            | JC                    | Notes |
| ------------ | -------------- | ------------- | --------------------- | ----- |
| undefined    | n/a            | undefined     | {"_undef":true}       | Standard JSON: encoded as null inside arrays, otherwise omitted |
| null         | null           | null          | null                  | standard JSON |
| true         | true           | true          | true                  | standard JSON |
| false        | false          | false         | false                 | standard JSON |
| 123.4        | 123.4          | 123.4         | 123.4                 | standard JSON |
| +0           | 0              | 0             | 0                     | standard JSON |
| -0           | 0              | -0            | -0                    | Standard JSON allows -0 but serializes negative zero as 0 (losing the sign unnecessarily) |
| NaN          | null           | NaN           | {"_nan":true}         | Standard JSON: always encoded as null |
| Infinity     | null           | Infinity      | {"_inf":true}         | Standard JSON: always encoded as null |
| -Infinity    | null           | -Infinity     | {"_ninf":true}        | Standard JSON: always encoded as null |
| "köhä"       | "köhä"         | "k\xf6h\xe4"  | "k\u00f6h\u00e4"      |   |
| U+00FC       | "\u00fc"       | "\xfc"        | "\u00fc"              |   |
| U+ABCD       | "\uabcd"       | "\uabcd"      | "\uabcd"              |   |
| U+1234ABCD   | "U+1234abcd"   | "\U1234abcd"  | "U+1234abcd"          | Non-BMP characters are not standard ECMAScript, JX format borrowed from Python |
| object       | {"my_key":123} | {my_key:123}  | {"my_key":123}        | ASCII keys matching identifer requirements encoded without quotes in JX |
| array	       | ["foo","bar"]  | ["foo","bar"] | ["foo","bar"]         |   |	
| buffer	   | n/a            | \|deadbeef\|  | {"_buf":"deadbeef"}   |   |
| pointer	   | n/a            | (0xdeadbeef)  | {"_ptr":"0xdeadbeef"} |   |
|              |                | (DEADBEEF)    | {"_ptr":"DEADBEEF"}   | Representation inside parentheses or quotes is platform specific |
| NULL pointer | n/a            | (null)        | {"_ptr":"null"}       |   |
| function     | n/a            | {_func:true}  | {"_func":true}        | Standard JSON: encoded as null inside arrays, otherwise omitted |
| lightfunc    | n/a            | {_func:true}  | {"_func":true}        | Formats like ordinary functions |


### 制限事項

いくつかの制限事項があります。

- 列挙可能な自身のプロパティのみが、どのフォーマットでもシリアライズされます。
- 配列のプロパティ（エントリ以外）はシリアライズされません。これは、例えばロギングなどで [1,2,3, "type": "point"] のように有用でしょう。
- 配列のギャップは保存されず、未定義としてパースバックされます。
- JCデータの解析時に、特殊な値を自動的に復活させることはありません。
- 正規のエンコーディングがない。これは、エンコード時にオブジェクトのキーをソートする簡単なオプションで簡単にアレンジできるだろう。

(今後の課題については、内部ドキュメントを参照してください)。


## カスタムディレクティブ

ECMAScript E5/E5.1 では、バージョンまたは実装固有の機能を有効にするために、ディレクティブプロローグを採用しています。標準では "use strict "という1つのディレクティブしか提供しませんが、asm.jsでは "use asm "を使用します。Duktapeのカスタムディレクティブについては、このセクションで説明します。


### use duk notail （ユースデューク・ノテイル）

use duk notailディレクティブは、その関数が決してテールコールされてはならないことを示します。テールコールはコールスタックに影響を与えるので、スタックトレースで見ることができ、 (通常は無害です) また、例えば Duktape.act() を使ってコールスタックを検査する関数に影響を与えます。このディレクティブは、コールスタックが既知の形状であることを保証するために、特殊なケースで有用です。例

```javascript
function noTailCall() {
    'use duk notail';

    // ...
}
```

ネイティブ関数はテールコールされないので、対応する宣言は必要ない。


## バッファ・オブジェクト

### バッファ・タイプの概要

Duktapeは、以下のバッファ・タイプおよびバッファ関連タイプを提供します。

| Type                          | Standard            | Duktape version | Description |
| ----------------------------- | ------------------- | --------------- | ---- |
| Plain buffer                  | No Duktape specific |	1.0             | Plain, primitive buffer value (not an object), similar to how a plain string relates to a String object. Behaves like an Uint8Array instance where possible, object coerces to an actual Uint8Array. |
| ArrayBuffer object            | Yes ES2015          | 1.3             | Standard object type for representing a byte array. References an underlying plain buffer. |
| DataView, typed array objects | Yes ES2015          | 1.3             | View objects to access an underlying ArrayBuffer. References an underlying plain buffer. |
| Node.js Buffer object         | No Node.js-like     | 1.3             | Object with Node.js Buffer API, inherits from Uint8Array.prototype. References an underlying plain buffer. |


バッファの種類とそのプロパティの詳細な表など、詳しい説明はbuffers.rstを参照してください。


### プレーン バッファ

プレーンバッファーは、バッファーのデータを表現するための非標準的なメモリ効率の良い方法です。プレーンバッファーは Uint8Array.prototype を継承し、型付き配列のコンストラクターの引数として受け付けられるなど、Uint8Array オブジェクトを模倣しています。プレーンバッファーはプロパティテーブルを持たず、それ自身のプロパティを保持できませんが、以下の仮想または継承されたプロパティを持っています（例の値は24バイトのバッファーのものです）。

| Property name     | Example value | Description |
| ----------------- | ------------- | ----------- |
| \[index\]         | 0-255         | Index properties in the range [0, length-1]. Reads and writes behave like for Uint8Array. |
| length            | 24            | Length of buffer in bytes. Length is not writable, so you can't resize a buffer by assigning its length. |
| byteOffset        | 0             | Always 0, present to match typed arrays. |
| byteLength        | 24            | Same as .length. |
| BYTES_PER_ELEMENT | 1             | Always 1, present to match typed arrays. |
| buffer            |               | Getter property which returns a new ArrayBuffer instance backing to the plain buffer without making a copy. Because plain buffers don't have a property table, a new ArrayBuffer is created on every property read. Absent if buffer object support is disabled in Duktape configuration. |


ArrayBuffer や Node.js Buffer などのバッファオブジェクトは、プレーンなバッファ値の上に実装され、ビュー/スライスのサポート、型付きアクセッサ、異なるエンディアンのデータを操作するメソッドなどの追加機能を提供します。しかし、これらはプレーンなバッファよりもオーバーヘッドがあります。

詳しくは、以下を参照してください。

- バッファの扱い方
- 型付けアルゴリズム
- buffers.rst


### バッファを使った作業

バッファの値は C と ECMAScript の両方のコードで動作します。

- ECMAScript コードでは、ほとんどの動作は関連する API 標準で定義されていますが、異なるバッファ・タイプの混在のような Duktape 固有の機能については例外があります。
- Cコードでは、プレーン・バッファとバッファ・オブジェクトを操作するためのAPIコールがあります。

例としては、How to work with buffers (バッファの扱い方) を参照してください。


> 特殊なケースでは、バッファ・オブジェクトをバックアップするプレーン・バッファが、バッファ・オブジェクトの見かけ上のサイズをカバーするのに十分な大きさでないことがあります。Duktapeはこのようなバッファに対してメモリセーフな動作を保証していますが、それ以外の動作は呼び出しによって異なります。例えば、ある呼び出しがこの状況を無視して黙ってundefined、NaN、または0を返すこともあれば、TypeErrorを投げることもあります。アンバックアップバッファの動作はバージョン保証の対象外であり、マイナーバージョン間で変更される可能性があります。


### 現在の制限事項

- TypedArrayバインディングのカスタム動作を参照してください。
- Node.jsのBufferバインディングのカスタム動作を参照してください。


## エラー・オブジェクト

### プロパティの概要

ECMAScript Error オブジェクトには標準的なプロパティがほとんどないため、多くの ECMAScript 実装がかなりの数のカスタムプロパティを追加しています。Duktape は標準の Error プロパティを使用しますが、他の実装で使用されている最も有用なプロパティも借用しています。エラー・オブジェクトの "独自の "プロパティの数は、エラー・オブジェクトをできるだけ小さく保つために最小化されています。

エラー・オブジェクトは以下のプロパティを持ちます（ほとんどが継承されます）。


| Property name | Compatibility | Description |
| ------------- | ------------- | ---- |
| name          | standard      | Name of error, e.g. TypeError, inherited |
| message       | standard      | Optional message of error, own property, empty message inherited if absent |
| fileName      | Rhino         | Filename related to error source, inherited accessor |
| lineNumber    | Rhino         | Linenumber related to error source, inherited accessor |
| stack         | V8            | Traceback as a multi-line human redable string, inherited accessor |


> 最も有用なfileNameとlineNumberの割り当ては、やや複雑です。関連する問題と現在の動作は、error-objects.rstに記述されています。

Duktapeがトレースバック・サポート付きでコンパイルされている場合。

- stack, fileName, lineNumber は Error.prototype から継承されたアクセサー・プロパティです。これらのプロパティは、単純に代入することでオーバーライドできます。継承されたセッターは書き込みをキャプチャしますが、通常の代入が行われたように独自のプロパティを作成します。この動作はDuktape 1.4.0で変更され、他のエンジンとより良くマッチするようになりました。
- アクセッサ・プロパティが必要とする生のトレースバック・データは、内部プロパティ (\x82Tracedata) に格納され、ECMAScript コードからは通常アクセスできません。

Duktapeがトレースバック・サポートなしでコンパイルされた場合。

- スタックアクセサーはError.prototype.toString()と同等になり、スタックトレースの印刷は常に有用で人間が読め る結果を生成するようになります。
fileName と lineNumber は、Error オブジェクトのプロパティです。このプロパティは、代入によってオーバーライドすることができます。
- エラー・オブジェクトがCコードからDuktape APIを使用して作成され、呼び出し元がメッセージのフォーマット文字列を与えない場合、messageプロパティはAPI呼び出しで与えられた数値のエラー・コードに設定されます。この場合、メッセージのタイプは数値になります。通常、エラー・メッセージは文字列です。最小化されたDuktapeビルドでは、Duktapeが内部的に生成するすべてのエラーは、数値エラー・コードのみを使用します。

オブジェクトは、その内部プロトタイプ・チェーンが（オリジナルの）Error.prototypeオブジェクトを含んでいれば、「エラー・オブジェクト」と見なされます。この基準に一致するオブジェクトだけが、例えばトレースバック・データで補強されます。


### トレースバック

stack プロパティは、エラーに関連する印刷可能なトレースバックを提供するアクセッサ (セッター/ゲッター) プロパティです。トレースバックは、エラー・オブジェクトが作成された (スローされなかった) 時のコール・スタックを反映します。トレースバックデータは自動的に収集され、オブジェクトに追加されます。

- Error インスタンスが構築されたとき。
- Duktape APIを使用したCコードからエラーがスローされたとき。
- Duktape内部からエラーがスローされたとき。

トレースバックの作成に使用されるデータは、内部プロパティ( \x82Tracedata) に格納され、内部およびバージョンに依存した形式で error-objects.rst に記述されま す。トレースバックデータに直接アクセスしてはいけません。

印刷可能なトレースバックのフォーマットは、人間が読むことだけを目的としています。バージョン間で変更される可能性があるため、正確なトレースバック形式に依存してはいけません (例えば、トレースバックは 1.5.0 リリースで改善されました)。現在のトレースバック形式の例として、プログラム。

```javascript
// shortened from tests/ecmascript/test-dev-traceback-example.js
try {
    decodeURIComponent('%e1%a9%01');  // invalid utf-8
} catch (e) {
    print(e.stack);
}
```

このようなものが印刷されるでしょう。

```sh
URIError: invalid input
    at [anon] (duk_bi_global.c:343) internal
    at decodeURIComponent () native strict preventsyield
    at global (test.js:3) preventsyield
```


トレースバックが無効なビルドでは、スタックアクセサは、エラー時に toString() を呼び出すのと同じ値を返します。つまり、いつでも e.stack を表示して、有用な出力を得ることができるのです。

最も移植性の高いトレースバックの印刷方法は、次のようなものです。

```javascript
try {
    decodeURIComponent('%e1%a9%01');  // invalid utf-8
} catch (e) {
    // Print stacktrace on at least Duktape and V8, or a standard error
    // string otherwise.
    print(e.stack || e);
}
```


スタックへの書き込みの試みは、継承されたセッターによって捕捉され、通常の割り当てが行われたかのように、独自のプロパティを作成します。この動作は、スタックがエラーインスタンスの独自のプロパティであるV8とは異なります。


### エラー・ハンドラ（errCreate と errThrow）

Duktape.errCreate が設定されている場合、Duktape がオブジェクトにトレースバック情報を追加した直後に呼び出され、さらにエラーを処理したり、エラー値を完全に置き換えたりすることができます。エラー・ハンドラはErrorインスタンスでのみ呼び出され、その戻り値が最終的なエラー値として使用されます。エラーハンドラがエラーをスローした場合、そのエラーは元のエラーに置き換わります。エラーハンドラは通常、1つのエラーにつき1回だけ呼び出されます。しかし、コンストラクタのコーナーでは、エラーハンドラは 1 つのエラー値に対して複数回呼び出されることがあります。

エラーハンドラは、オブジェクトにすでに存在するプロパティを上書きすることは避けなければなりません。一般に、エラーハンドラはエラーを投げることを避けるべきです。なぜなら、そのエラーは元のエラーに取って代わるからです。具体的な例としては、拡張不可能なオブジェクトに新しいプロパティを追加しようとすると TypeError が発生するので、エラーハンドラはそれを回避しなければならない。

以下は、エラー発生時に作成タイムスタンプを追加するエラーハンドラの例である。

```javascript
Duktape.errCreate = function (e) {
    if (!(e instanceof Error)) {
        // this check is not really needed because errCreate only gets
        // called with Error instances
        return e;
    }
    if ('created' in e) {
        // already augmented or conflicting property present
        return e;
    }
    if (!Object.isExtensible(e)) {
        // object not extensible, don't try to add a new property
        return e;
    }
    e.created = new Date();
    return e;
}
```


ハンドラを削除するには、そのプロパティを削除してください（例えばnullに設定しても機能せず、Duktapeがnull値を呼び出そうとするとTypeErrorが発生します）。

``` javascript
// Remove error handler for error creation
delete Duktape.errCreate;
```


同様に、Duktape.errThrow が設定されている場合、エラーがスローされる直前に呼び出され、エラー値を処理したり置き換えたりすることができます。ECMAScript は任意の値の型を投げることができるので、エラーハンドラは任意の入力値（Error インスタンスだけでなく）で呼び出されるかもしれません。また、エラーは何度も再スローできるため、同じ値で複数回呼ばれることもあります。

たとえば、エラーに throw タイムスタンプ (オブジェクトが最初にスローされたときの記録) を追加するには、次のようにします。

```javascript
Duktape.errThrow = function (e) {
    if (!(e instanceof Error)) {
        // refuse to touch anything but Error instances
        return e;
    }
    if ('thrown' in e) {
        // already augmented or conflicting property present
        return e;
    }
    if (!Object.isExtensible(e)) {
        // object not extensible, don't try to add a new property
        return e;
    }
    e.thrown = new Date();
    return e;
}
```

繰り返しになりますが、ハンドラを削除するには、プロパティを削除してください。

```javascript
// Remove error handler for error throwing
delete Duktape.errThrow;
```


### 現在の制限事項

- コーズチェーンのサポートがない。原因チェーンは便利ですが、ECMAScript には原因チェーンはありませんし、そのためのデファクトスタンダードもないようです。
- これらは現在、バージョン互換性のある方法で、プログラム的にトレースバック要素にアクセスする方法はありません。しかし、_Tracedata hidden Symbol (C コードから DUK_HIDDEN_SYMBOL("Tracedata")) にアクセスすることはできますが、生の tracedata のフォーマットはマイナーバージョンでも変更される可能性があります。.stackプロパティを直接上書きすることも可能です。
- エラーがカスタム・エラー・クラスへの非コンストラクタ関数呼び出しで作成された場合（new MyError('msg') の代わりに MyError('msg') ）、トレースバック・データのようなカスタム・フィールドで拡張されることはありません。コンストラクタとして呼び出された場合、Error を継承したカスタム・エラーは通常通り追加されます。組み込みの標準エラー (TypeError など) は、コンストラクタ以外の関数呼び出しで作成された場合でも、常に拡張されます (ただし、エラーの作成方法によって、トレースバックは若干異なって見えます)。


## 関数オブジェクト

### ECMAScriptの関数

Duktape Function オブジェクトは、標準的な ECMAScript プロパティにいくつかのプロパティを追加します。以下の表は、新しく作成された関数インスタンスに割り当てられたプロパティをまとめたものです（もちろん、プロパティは後から追加したり削除したりすることができます）。


| プロパティ | 互換性   | 説明 |
| ---- | ---- | ---- |
| length    | standard | Function (nominal) 引数の数 (該当する場合)。バインドされた関数を含む全てのFunctionオブジェクトに存在する。 |
| prototype | standard | コンストラクタとして呼び出されたとき、新しいオブジェクトに使用されるプロトタイプです。ほとんどの構築可能なFunctionオブジェクトに存在し、バインドされた関数にはコピーされない。|
| caller    | standard | エラーを投げるアクセサです。ストリクト関数とバインド関数に存在します。バインドされた関数にはコピーされません。(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY が与えられた場合、非厳密関数は非標準の呼び出し側プロパティを取得します)。 |
| arguments | standard | アクセサで、エラーを投げます。厳密な関数とバインドされた関数に存在します。バインドされた関数にはコピーされません。 |
| name      | Duktape  | 関数名、下記参照。バウンド関数名は、このプロパティに基づいて、"bound " という接頭辞が付きます（ES2015の標準的な動作です）。
| fileName  | Duktape  | 関数が宣言されたファイル名またはコンテキスト（エラートレースバックと同じ名前）。ターゲット関数からバインド関数にコピーされます。
| callee    | n/a      | デフォルトでは割り当てられない（"caller" プロパティとの関係を明確にするために、ここに記載）。 |


name プロパティは、すべての関数に割り当てられ、トレースバックで使用される名前でもあります。以下のように割り当てられる。

```javascript
function funcDecl() {
    /* Function declaration: 'name' is declaration name, here 'funcDecl'. */
}

var foo = function namedFunc() {
    /* Named function expression: 'name' is the name used in expression,
     * here 'namedFunc' (not 'foo').
     */
}

var bar = function () {
    /* Anonymous function expression: 'name' is the empty string. */
}
```

> ECMAScript のいくつかの組み込み関数は、ユーザーが作成した関数とは異なるプロパティを持ちます。


## Duktape/C関数

ユーザーが作成したDuktape/C関数（duk_push_c_function()）は、Functionオブジェクトのメモリフットプリントを削減するために、異なるプロパティのセットを持っています。

| プロパティ | 互換性 | 説明 |
| ---- | ---- | ---- |
| length | standard | Functionの引数カウント、duk_push_c_function()への引数にマッチ、 varargsの場合は0。書き込み不可、設定不可。


特に、標準のprototype、caller、argumentsプロパティがデフォルトで欠落していることに注意。これは厳密にはコンプライアンスではありませんが、関数のフットプリントを小さくするためには重要です。もちろん、ユーザがこれらのプロパティを設定することは可能ですが、設定する必要はありません。

また、（非標準の）name プロパティもありません。手動で設定すると、トレースバックで関数がどのように表示されるかに影響するため、便利です。


### 軽量Duktape/C関数

軽量 Duktape/C 関数 (lightfuncs) は、ECMAScript 環境でネイティブ関数を表現するための非常にメモリ効率の良い方法です。Lightfuncs はプロパティ・テーブルを持たないので、プロパティを保持することはできま せん。しかし、Function.prototype を継承し、以下の仮想プロパティ（設定不可、書き込み不可）を持っています。


| Property name | Compatibility | Description |
| ------------- | ------------- | ----------- |
| length        | standard      | Function (nominal) argument count. |
| name          | Duktape       | Function name: "light_\<PTR\>_\<FLAGS\>". |


nameプロパティは自動生成された仮想関数名です。\<PTR\>はDuktape/C関数ポインタのプラットフォーム依存ダンプ、\<FLAGS\>は16ビット内部制御フィールドの生の16進ダンプです（フォーマットはDuktape内部）。特定のフォーマットに依存してはいけません。例えば

```javascript
duk> print(myLightFunc.name);
light_0805b94c_0511
```

通常の関数と同様に、lightfunc は実装に依存した文字列に強制されます。特定のフォーマットに依存してはいけません。例えば


```javascript
duk> print(myLightFunc);
function light_0805b94c_0511() {"light"}
```


詳しくは、こちらをご覧ください。

- lightfuncsの使い方
- アルゴリズムを入力する
- lightweight-functions.rst


## 日付と時刻の処理

日付と時刻の処理は、Duktape をよりエキゾチックな環境に適応させる際に、しばしば移植性の問題になります。duk_config.h 設定ヘッダは、Date 組み込みの実装に必要な、プラットフォーム固有の プロバイダを選択します。Duktapeには、主流のプラットフォーム（Linux、Windows、OS X）用の組み込みプロバイダーがあり、通常は変更せずに動作するはずです。また、より特殊な環境のために、外部の日付プロバイダーを書くこともできます。外部日付プロバイダーは、例えば、プラットフォームの時間にオフセットを適用する必要がある場合や、時間の仮想化を使用する場合などにも使用することができます。

ECMAScript のコードは、標準の Date 組み込みで日付/時刻を扱いますが、これは仕様上、ミリ秒の分解能に制限されています。現在、Duktape特有のECMAScript日付/時間APIは存在しません。(サブミリ秒の解像度に対応するカスタムAPIが後で追加されるかもしれません)。

Cコードはもちろんプラットフォームの日付/時刻APIを直接使用できますが、Duktape C APIは日付/時刻APIコールも提供しています。これらの呼び出しはECMAScriptコードと同じ時間値を見ることができ、例えば時間の仮想化が使用されている場合には重要かもしれません。これらのコールを使うことで、あなたのコードはプラットフォーム・ニュートラルとなり、よりポータブルになります。Duktape C APIでは、時間値をサブミリ秒の分解能で扱うことができます。詳しくは、時間値の扱い方をご覧ください。


## 乱数について

乱数は、内部的に Math.random() で使用されています。また、現在は Array.prototype.sort() の実装でランダムピボット選択のために使用されています。

デフォルトの内部乱数生成器は xoroshiro128+ で、SplitMix64 シードミキシングを使用します。Shamirの3-op PRNGは低メモリターゲットやコンパイラが64ビット型を持っていない場合に使用されます。このジェネレータは、例えばシード材料の品質が限られているため、本格的な統計アルゴリズムには適しておらず、暗号には全く適していません。

DUK_USE_GET_RANDOM_DOUBLE 設定オプションを使って、内部の乱数生成器を置き換えることができます。


## デバッガーについて

Duktapeには、コンパイル時に有効にできるオプションとして、ビルトインのデバッガ・サポートがあります。デバッガ・サポートは、約15-20kBのコード・フットプリントを追加し（どのようなデバッガ機能が有効になっているかに依存）、メモリ・フットプリントは非常に小さくなっています。デバッガ機能には以下のものがあります。

- ファイル/ラインでの実行/一時停止、コールスタック、異なるコールスタックレベルのローカル変数などの実行ステータス情報
- 一時停止/再開、ステップオーバー/イント/アウト、ファイル/行を対象としたブレークポイント、デバッガステートメントなどの実行制御
- 任意のコールスタックレベルでの汎用Eval、任意のコールスタックレベルでの変数get/put
- アプリケーション定義のリクエスト（AppRequest）および通知（AppNotify）のための機構
- ヒープオブジェクトの詳細な検査、Duktapeヒープウォーキング、ヒープダンプの完全取得

デバッガーは、以下の主要なコンセプトに基づいています。

- Duktapeは、全てのアプリケーションに共通する組み込みのデバッグ・プロトコルを提供します。アプリケーションは、デバッグ・プロトコルを解析したり、理解したりする必要はありません。デバッグ・プロトコルはコンパクトなバイナリ・プロトコルで、低速接続の低メモリ・ターゲットでも問題なく動作します。デバッグプロトコルのJSONマッピングとJSONデバッグプロキシがあり、デバッグクライアントの統合を容易にする。
- デバッグプロトコルは信頼性の高いストリームベースのデバッグトランスポート上で実行される。移植性を最大化するために、具体的なトランスポートはストリームインターフェースを実装したコールバックのセットとしてアプリケーションコードから提供されます。ストリームベースのトランスポートでは、デバッグメッセージのバッファなしストリーミングが可能で、メモリ使用量を非常に低く抑えることができます。
- デバッグ・クライアントはトランスポート接続を終了し、Duktapeデバッグ・プロトコルを使ってDuktape内部（一時停止／再開、ステップ、ブレークポイント、evalなど）と対話します。また、より簡単に統合するために、JSONデバッグ・プロキシーを使用することもできます。
- 非常に狭いデバッグAPIは、デバッガーをアタッチしたりデタッチしたり、デバッグ・トランスポートの実装に必要なコールバックを提供するために、アプリケーション・コードによって使用されます。その他のすべてのデバッグ活動は、アプリケーションの関与なしにDuktapeによって直接実装されるデバッグ・プロトコルを介して行われます。


最適なデバッグトランスポートは、Wi-Fi、Bluetooth、シリアル回線、カスタム管理プロトコルに組み込まれたストリームなど、デバッグターゲットによって大きく異なります。標準的な」トランスポートはありませんが、TCP接続は便利なデフォルトです。Duktapeの配布物には、TCPトランスポートを使用したデバッグを始めるために必要なすべてのパーツが含まれています。

- TCPトランスポートに必要なコールバックの実装例： duk_trans_socket_unix.c (Windowsの例もあります)
- Duktape コマンドラインツール (duk) の TCP トランスポートを使ったデバッガサポート。--debugger オプション
- Node.js、Express、socket.io に基づくデバッガ・ウェブ UI: duk_debug.js

Node.jsベースのデバッガ・ウェブUI（duk_debug.js）は、Duktapeコマンドラインに接続できますが、TCPトランスポートを実装した他のターゲットと直接会話することもできます。また、別のトランスポートを使用するようにカスタマイズしたり、TCPとあなたのカスタムトランスポートの間を変換するプロキシを使用したりすることも可能です。また、独自のデバッグクライアントをスクラッチから作成し、カスタム IDE に統合することも可能です。バイナリデバッグプロトコルを使用してデバッグターゲットと直接統合するか、duk_debug.js (Node.js) または duk_debug_proxy.js (DukLuv) が提供する JSON プロキシを使用することができます。

デバッグターゲットとデバッグクライアントは混在することを意図しています。トランスポート（通常はTCPか適応しやすい）を除けば、デバッグプロトコルは同じです。中核機能はデバッグクライアントやデバッグターゲットに関係なく同じですが、一部のオプション機能が欠落している可能性があります。デバッグクライアントとデバッグターゲットは、アプリケーション固有のコマンド (AppRequest) と通知 (AppNotify) を実装して、クライアントとターゲットの両方がサポートしている場合に使用できる統合機能を充実させることができます (サポートしていない場合は簡単に無視してかまいません)。カスタムコマンドと通知により、例えば、ターゲットから直接ソースファイルをダウンロードしたり、カスタムメモリアロケータの状態を深く調査したり、コマンドでターゲットを再起動したりすることができる。

実装の詳細と開始方法については、以下を参照してください。

- debugger/README.rst
- debugger.rst
- duk_trans_dvalue.c: ローカルデバッグプロトコルのデコード/エンコードによるデバッグトランスポートの例
- duk_debug_proxy.js


## モジュール

### CommonJSモジュールローディングフレームワーク

モジュール・ローディングの多様なユースケースに単一のフレームワークで対応するのは難しいので、ビルトインのモジュール・ローディング・フレームワークはありません。Duktapeの配布物には、例えば、いくつかのオプションのモジュール・ローダー・ フレームワークが含まれています。

- module-duktape: CommonJS modules version 1.1.1 をベースにしたDuktape 1.x 互換ローダーで、module.exportsといくつかのDuktape固有のモジュール・オブジェクトのプロパティを追加でサポートしています。内部構造はmodules.rstで説明されており、例としてはモジュールの使い方を参照してください。このローダーはDuktape 1.xではビルトインでしたが、Duktape 2.xではオプショナルな追加機能として移動しました。
- module-node: Node.jsのモジュールに対応したローダーです。Node.js的なモジュールの使い方の例を参照してください。

また、独自のモジュール・ローダーを一から実装することもできます。上記のローダーは、DuktapeのパブリックAPIを使って実装されており、内部への特別なアクセスはありません。

モジュール・ローダーは require() 関数を提供し、以下のようにモジュールをロードすることができます。

```javascript
var mod = require('foo/bar');
mod.hello();
```


ローダーは、実際のモジュール解決やロードをユーザー提供のフックに抽象化し、様々な環境での組み込みを可能にします。例えば

- ファイルシステムのない環境でも、仮想的な組み込みファイルの集合からモジュールをロードすることで、モジュールロードを利用することができます。
- Babelなどを使って、ロード中にオンザフライのトランスパイルが可能です。

### ES2015 モジュール

ES2015 のインポート/エクスポートと ES2015 モジュールは、現在サポートされていません。

### C モジュール規約§。

DLL から C モジュールをロードして初期化するための推奨される (必須ではありませんが) C モジュール規約があります: c-module-convention.rst.


## ロギング

Duktapeの配布物には、小さなフットプリントと適度なパフォーマンス、そしてリダイレクト可能な出力を持つロギング・フレームワークが含まれています。このフレームワークはDuktape 1.xではビルトインでしたが、Duktape 2.xではオプションとして追加されました。

基本的な使用例です。

```javascript
var val1 = 'foo';
var val2 = 123;
var val3 = new Date(123456789e3);

var logger = new Duktape.Logger();  // or new Duktape.Logger('logger name')
logger.info('three values:', val1, val2, val3);
```


この例では、以下のような内容が標準エラー出力に出力されます。

```sh
2014-10-17T19:26:42.141Z INF test.js: three values: foo 123 1973-11-29 23:33:09.000+02:00
```


詳しくはWikiの記事How to use loggingとlogging.rstを参照してください。



## ファイナライゼーション

### 概要

Duktapeは、カスタム機能としてオブジェクトのファイナライゼーションをサポートしています。ファイナライザーは、オブジェクトが解放されようとするときに呼び出され、アプリケーション・コードが、例えば、オブジェクトに関連するネイティブ・リソースを解放できるようにします。ファイナライザーは、ECMAScript関数またはDuktape/C関数のいずれかにすることができます。しかし、ECMAScript のファイナライザはスクリプトのタイムアウトと悪い相互作用をする可能性があります。

例については、ファイナライザの使用方法を参照してください。


### 現在のファイナライザーを取得・設定する

プロトタイプ・チェーンに（あるいはオブジェクト自体に）内部 _Finalizer プロパティを持つオブジェクトは、解放される前にファイナライズの対象となります。内部プロパティは直接アクセスしてはいけませんが、以下を使用して読み書きが可能です。

- Duktape.fin(obj) (ECMAScript) または duk_get_finalizer() (C) は、現在のファイナライザを取得します。
- Duktape.fin(obj, fn) (ECMAScript) または duk_set_finalizer() (C) は、現在のファイナライザを設定します。


### ファイナライザー関数の引数と戻り値

ファイナライザー関数は、2つの引数で呼び出されます。

- ファイナライズされるオブジェクト。
- オブジェクトがヒープ破壊の一部として強制的に解放されるかどうかを示す boolean フラグ。この引数は Duktape 1.4.0 で追加されました。
 - false (通常の場合)の場合、ファイナライザは、戻る前にオブジェクトへのライブ参照を作成することによってオブジェクトを救出することができ、ファイナライザは後で再び呼ばれることが保証されています(遅くともヒープ破壊)。
 - true (ヒープ破棄時の強制終了) の場合、オブジェクトは救出できず、ファイナライザが終了した後に強制的に解放されます。ネイティブなリソースは、ファイナライザへのさらなる呼び出しを期待せずに解放する必要があります。

ファイナライザーの戻り値は無視されます。ファイナライザがスローしたエラーも、静かに無視されます。

### ファイナライザ実行保証

主なファイナライザーの保証は以下の通りです。

- ファイナライザは、参照カウントやマーク・アンド・スイープで検出された到達不能な オブジェクトに対して実行されます。しかし、ファイナライザはすぐに実行されるわけではなく、参照カウントによって オブジェクトが到達不可能になったことが検出されても実行されません。
- ファイナライザーは、Duktapeヒープが破壊されたときにも、到達可能な状態に関わらず、残りの全てのオブジェクトに対して実行されます。
- ファイナライザーは、オブジェクトが再び到達可能になることで救済されない限り、遅くともヒープが破壊された時点で一度だけ呼び出されます。オブジェクトは、それ自身のファイナライザによって救済されることもあれば、 マーク・アンド・スイープでオブジェクトのセットをファイナライズする際に、他のオ ブジェクトのファイナライザによって救済されることもあります。たとえば、X.ref = Y で、X と Y の両方が到達不能になった場合、Y のファイナライザが実行され、後で X のファイナライザが X と Y の両方を救済することが可能です。
- オブジェクトは任意の回数だけ救出される可能性があります。ファイナライザは「救出サイクル」ごとにちょうど1回だけ呼び出されます。この保証がある場合でも、ファイナライザーはリエントラントであることがベストプラクティスであり、例えば、再入力された場合にネイティブリソースを複数回解放することは慎重に避けなければなりません。
- ファイナライザーは Proxy オブジェクトに対しては実行されず、プレーンなターゲットオブジェクトに対して実行されます。これにより、Proxy オブジェクトが作成されるときにファイナライザーが複数回実行されることがありません。

これらを合わせると、ヒープが破壊される前のある時点でファイナライザが実行されることが保証され、これによりネイティブリソース（ソケットやファイルなど）が確実に解放されます。この保証にはいくつかの例外があり、詳細は以下を参照してください。

- ヒープ破壊時のファイナライザーのサニティ制限により、ファイナライザーが実行されないことがあります。
- スクリプトのタイムアウトが現在のコールスタックから伝搬される場合、ECMAScript のファイナライザーは直ちにスクリプトのタイムアウトエラーを再投与します。Duktape/Cのファイナライザーは、通常通り実行されます。
- Duktape がファイナライザーを呼び出そうとしたときに（緊急の GC にもかかわらず）メモリ不足になった場合、呼び出しエラーは黙って無視され、ファイナライザーはスキップされます。
- オブジェクトがマーク＆スイープによってファイナライズされ、次のマーク＆スイープラウンドがレスキューを検出する前に到達不可能になった場合、そのオブジェクトのファイナライザは実行されません。

Duktapeヒープが破壊されるとき、ファイナライザーの動作にはいくつかの制限があります。

- ファイナライザーは、到達可能なオブジェクトを含む、ヒープ内の全てのファイナライズ可能なオブジェクトに対して実行されます。
- ファイナライザーはオブジェクトを救出することはできません。「救出」のセマンティクスが曖昧になります。ファイナライザーの第2引数は、ヒープ破棄時に呼び出された場合、救助が不可能であることを示すために真になります。
- ファイナライザーは、ファイナライズ可能な新しいオブジェクトを作成することができ、これらのオブジェクトもファイナライズされます。例えば、ファイナライザーは、オブジェクトの破壊をHTTPで通知することができます。これは、独自のファイナライザーを持つネイティブのネットワークリソースを使用することができます。しかし、暴走したファイナライザーがヒープの破壊を防ぐことができないように、このプロセスにはサニティーの制限があります。
- ファイナライザーのサニティ・アルゴリズムはバージョンに依存します。このアルゴリズムでは、ファイナライザ可能なオブジェクトの数が最初は増加しますが、合理的な時間内に減少しなければファイナライザ処理が中断され、一部のネイティブ リソース リークが発生する可能性があります。


### その他の現在の制限事項

- スクリプト実行タイムアウト (DUK_USE_EXEC_TIMEOUT_CHECK) が使用され、タイムアウトが発生した場合、ECMAScript ファイナライザが実行を開始しても、スクリプトタイムアウトによりすぐに失敗する可能性があります。これが具体的な懸念事項である場合、代わりにDuktape/Cネイティブファイナライザを使用してください。このファイナライザは、タイムアウトが伝播しても正常に実行されます。
- ファイナライザーを実行するコンテキスト（Duktapeスレッド）は、現在ヒープ内の任意のコルーチンである可能性があります。これはサンドボックス化において考慮されなければなりません。
- ファイナライザーは現在、降伏することができません。


## コルーチン

Duktapeは、単純なコルーチンをサポートしています。コルーチン A はコルーチン B を再開または開始し、コルーチン B は降伏または終了（成功またはキャッチされないエラー）するまで実行し、その後コルーチン A は降伏結果で実行を継続します。

コルーチンは new Duktape.Thread() で作成され、その唯一の引数は、新しいコルーチンが最初のレジュームで実行を開始する初期関数として取得します。レジューム引数は、初期関数の最初の（そして唯一の）引数値となります。

Duktape.Thread.resume()は、再開するコルーチン、再開値、（オプションで）再開値が通常の値か、対象のコルーチンに注入されるエラーであるかを示すフラグを引数にとります。エラー投入とは、レジューム値をターゲットコルーチンの最後のyield操作の場所で "throw "することを意味します。つまり、通常の値で戻るのではなく、一見、エラーを投げるように見える。

Duktape.Thread.yield()は、yieldする値と、（オプションで）yield値が通常の値であるか、再開するコルーチンのコンテキストで投げられるエラーであるかを示すフラグを引数として取ります。言い換えれば、エラー値を指定すると、レジューム操作で通常の値を返す代わりにエラーを投げるように見える。

コルーチンが正常に存在する場合、すなわち、初期関数が値を返して終了する場合は、戻り値でyieldと同様に処理される。捕捉されないエラーによってコルーチンが存在する場合、それはエラーを伴うyieldと同様に扱われる：再開操作は、再開するコルーチンのコンテキストでそのエラーを再スローする。いずれの場合も、終了したコルーチンはもはや再開することができません; 再開しようとするとTypeErrorが発生します。

現在、yield が可能な場合、厳しい制限がある。つまり、コルーチンのアクティブなコールスタック全体が ECMAScript から ECMAScript への呼び出しで構成されている場合のみ、降伏が可能です。以下のものは、降伏するコルーチンのコールスタックのどこかに存在する場合、降伏を防ぎます。

- Duktape/C関数呼び出し
- ゲッター/セッター呼び出し
- プロキシ・トラップ呼び出し
- eval() 呼び出し
- ファイナライザー呼び出し

> Duktape 2.2以降、コンストラクタ呼び出し（new Func()）、Function.prototype.call()、 Function.prototype.apply() 、 Reflect.apply() 、 Reflect.construct() は yield を防止しなくなった。

例として、コルーチンの使い方を参照してください。


## 仮想プロパティ
Duktapeは、プロパティ・アクセスをプログラムで操作するための2つのメカニズムを提供します。

- アクセサー・プロパティ(セッターとゲッター)
- プロキシ・オブジェクト

例については、仮想プロパティの使用方法を参照してください。


## シンボル

DuktapeはES2015 Symbolをサポートしており、Duktape 1.xの内部文字列に似たDuktape特有の隠しSymbolも提供しています。隠しSymbolは、通常のECMAScriptコードから隠されるという点でES2015 Symbolと異なります：ECMAScriptコードから作成できず、列挙やJSON-シリアライズもできませんし、オブジェクト・getOwnPropertyName（）からも返らず、オブジェクトgetOwnPropertySymbols（）からも返されません。非表示のSymbolキーを持つプロパティは、非表示のSymbolへの参照を保持している場合にのみ、直接プロパティの読み取り/書き込みでアクセスすることができます。

現在使用されているフォーマットについては、symbol.rstを参照してください。アプリケーションの隠しシンボルは、0xFFバイトのプレフィックスで始まり、その後にアプリケーションで選択された任意の文字列が続きます。Cのコードがduk_push_string()などで文字列をプッシュし、そのバイト列が内部のシンボル・フォーマットにマッチした場合、その文字列値は自動的にシンボルとして解釈されます。

Duktapeでは、オブジェクトのファイナライザーの参照を保存するなど、様々な実装固有の目的のために隠れたSymbolも使用します。Duktape 2.2以降、Duktapeの隠しSymbolには異なるバイト・プレフィックスが使用されており、0xFFプレフィックスは完全にアプリケーション用に予約されています。アプリケーション・コードは、Duktapeの隠されたシンボルのキー付きプロパティにアクセスしようとしないでください： そのようなプロパティのセットは、バージョン間で任意に変更される可能性があります。

> 内部の UTF-8 バイト・シーケンスは、ECMAScript コードから有効な ECMAScript 文字列として作成することができないことに注意してください。例えば、隠されたSymbolは、ff 78 79 7aというバイトシーケンスで表現されますが、ECMAScriptの文字列" \u00ffxyz" は、メモリ内でc3 bf 78 79 7aというCESU-8バイトとして表現されます。

Symbolの作成はCコードから簡単に行えます。

```c
/* Create a hidden Symbol which can then be used to read/write properties.
 * The Symbol can be passed on to ECMAScript code like any other string or
 * Symbol.
 */
duk_push_string(ctx, DUK_HIDDEN_SYMBOL("mySymbol"));
```


Duktape 2.2以前は、DUK_HIDDEN_SYMBOL()や他のシンボル・リテラル・マクロは使用できず、内部表現を直接使用することになります。

```c
/* Terminating a string literal after a hex escape is safest to avoid some
 * ambiguous cases like "\xffab".  For more discussion, see:
 * https://github.com/svaarala/duktape/blob/master/misc/c_hex_esc.c
 */
duk_push_string(ctx, "\xff" "mySymbol");
```


隠しシンボルは、ECMAScript コードからデフォルトのビルトインだけを使って作成することはできません。標準的な ES2015 Symbol は Symbol.for('foo') のように Symbol 組み込みで作成することができます。サンドボックス化する場合、アプリケーションの C バインディングが、入力バッファをエンコードせずにそのまま文字列に変換するなどして、隠れた Symbol を作成するメカニズムを誤って提供しないようにしてください。

現在、Hidden Symbolをキーとするプロパティに対する特別なアクセス制御はありません。ユーザーコードがSymbolにアクセスできれば、プロパティ値の読み書きが可能です。これは将来のメジャーバージョンで変更される可能性が高く、ECMAScript コードは、隠された Symbol 値への参照を保持している場合でも、隠された Symbol キーを持つプロパティにアクセスできないようにします。


## バイトコードダンプ/ロード

duk_dump_function() と duk_load_function() という API コールは、C コードを呼び出して (1) ECMAScript 関数を移植性のあるバイトコードにシリアライズし、 (2) バイトコードをロードしてその関数を再構成することを可能にします。

バイトコードのフォーマットはDuktapeのバージョンに依存し、異なるDuktapeのマイナー・バージョンからバイトコードをロードするのは安全ではありません（パッチのバージョンはバイトコードの互換性に影響を与えません）。Duktapeの設定オプションもバイトコードの互換性に影響を与えるので、 dump/loadのソースとターゲットは同じオプションでコンパイルしなければなりません。バイトコード・フォーマットはプラットフォーム中立なので、あるプラットフォームでバイトコードをコンパイルして、別のプラットフォームでロードすることができます。これはクロスプラットフォーム・ビルドに便利な機能です。Duktapeはロードされたバイトコードを検証しないので、呼び出し側のコードは、実行中のDuktapeのバージョンでバイトコードがそのまま有効であることを確認しなければなりません。

> 呼び出し側のコードは、読み込まれるバイトコードが無傷で、実行中の Duktape のバージョンに対して有効であることを確認しなければなりません（つまり、同じバージョンの Duktape でコンパイルされ、その後変更されていないことを確認しなければなりません）。無効なバイトコードをロードすると、メモリが安全でない動作につながる可能性があります。また、悪意を持って細工されたバイトコードをロードすると、脆弱性が悪用される可能性さえあります。

詳細は bytecode.rst を参照してください。


## スレッディング

Duktapeは限定的なマルチスレッドをサポートしています。

- duk_create_heap()で作成された特定のDuktapeヒープはシングルスレッドです： 一度にヒープ内でコードを実行できるネイティブ・スレッドは1つだけです。ネイティブ・スレッドは、同じDuktapeヒープで同時に2つのネイティブ・スレッドがアクティブにならない限り、時間の経過とともに変更することができます。
- Duktape/Cコールの中でduk_suspend()を使ってDuktapeの実行を中断し、後で duk_resume()で再開することが可能です。これらの呼び出しの間に、別のスレッドが同じDuktapeヒープを呼び出す可能性があります。アプリケーション・コードは、一度に1つのネイティブ・スレッドしかDuktapeを呼び出さないようにするために、必要なロックを管理しなければなりません。
- Duktapeのヒープは、互いに完全に分離されています。Duktapeヒープごとにアクティブなネイティブ・スレッドが1つだけ存在する限り、複数のネイティブ・スレッドが同時にコードを実行することが可能です。

背景として、Duktapeヒープは、ヒープ内に存在するDuktapeスレッドの数にかかわらず、単一のメモリー管理領域です（ネイティブ・スレッドとDuktapeスレッドを混同しないでください）。ヒープ内のDuktapeスレッドはオブジェクト参照を共有できるため、マルチスレッド対応にはガベージ・コレクションと全てのオブジェクト処理に同期が必要になります。同期化は大きな移植性の問題になるので、実用的なアプローチは、Duktapeヒープをシングルスレッドに制限することです。Duktapeヒープは何も共有しないので、原則的にヒープ間のスレッド制限はありません。しかし、いくつかのプラットフォーム機能が利用できない場合（可変プリプロセッサー・マクロやリエントラント・システムコールなど）には、いくつかの制限があります。

スレッド制限の詳細とベストプラクティスについては、threading.rstとHow to use multiple native threadsを参照してください。


## サンドボックスの概要

サンドボックス化された環境では、2つの大きな目標を念頭に置いて、信頼されないコードの実行を許可します。

- セキュリティ：信頼されないコードが、メモリに直接アクセスしたり、セグメンテーション違反を起こすなど、安全でない操作をするのを防ぐ。
- 可用性：信頼できないコードが、利用可能なメモリをすべて消費したり、無限ループに入るなど、リソースを占有することを防止する。

Duktapeは、信頼されていないECMAScriptコードに対して、これらの目標を達成するためのメカニズムを提供します。すべてのCコードは信頼されることが期待されています。サンドボックスの実装方法に関する詳細な議論はsandboxing.rstを参照してください。

> Duktape 2.xのサンドボックス・サポートは、まだ作業中です。


## パフォーマンス

Duktapeはインタプリタ型エンジンであり、現在のところJITをサポートしていません。参照カウントを使用しているため、実行性能の代償としてメモリ使用量が少なくなっています。全体的なDuktapeの性能は、他のインタープリタ型言語と同程度であるべきです。

Duktapeの性能の特徴や、コードを最適化するためのヒントについては、「性能の最適化方法」をご覧ください。

パフォーマンスを重視するのであれば、プロファイル・ガイド付き最適化 (PGO) を強く推奨します。たとえば、PGO付きのGCC -O2は、PGOなしのGCC -O2よりも20%ほど速くなることがあります。


## メモリ使用量について

Duktapeはオンデマンドでメモリーを割り当て、事前に割り当てたヒープを必要としません。32ビット・システムでヒープを作成する場合、Duktapeは組み込みのECMAScriptオブジェクトのために約80kBを必要とします。特定の低メモリ・オプションを使用した場合、初期メモリ使用量は約27kBになります。組み込みオブジェクトと文字列をROM（読み取り専用データ・セクション）に移動させると、これはさらに約3kBまで減らすことができます。また、カスタムネイティブバインディングを完全にROMに移動させることも可能です。

ヒープ作成後、アプリケーションスクリプトの実行に必要なメモリが追加で割り当てられます。参照カウントにより、未使用の割り当てメモリはほとんどありません。唯一の大きな例外は、参照ループに参加するオブジェクトで、これらはマークアンドスイープにより最終的に収集されます。

Duktapeが必要とするメモリ割り当ては、基本的に2つのカテゴリーに分類されます。まず、文字列、バッファ、オブジェクト、オブジェクトのプロパティ・テーブルなどに必要な、およそ16バイトから128バイトの小さな割り当てがたくさんあります。次に、ECMAScript関数のバイトコード、大きな文字列とバッファ、値スタック、グローバル文字列テーブル、Duktapeヒープ・オブジェクトなどに必要な大きな割り当ては、はるかに少なくなっています。

ほとんどのシステムでは、メモリ使用量やメモリ割り当てパターンが問題になることはありません。低メモリ環境、例えばシステム RAM が 1MB 未満の場合、メモリ使用を最適化するためにカスタムのアロケーターを使いたいかもしれません。プールベースのアロケータは、フラグメンテーションの問題なしに、小さなアロケーションチャーンにうまく対処します。欠点は、具体的なアロケーションパターンに合わせてメモリプールサイズを調整する必要があることです。もし、プラットフォームのアロケーションプリミティブがたくさんの小さなアロケーションでうまく機能しない場合は、プールアロケータまたはハイブリッドアロケーションを使用するとよいでしょう。

どのような低メモリ機能が存在し、どのように低メモリシステム用のメモリプールをチューニングするかについて、詳しくは低メモリオプションと低メモリ.rstを参照してください。

デフォルトのオプションでは、Duktape は 32 ビットの refcount フィールドを使用し、64 ビットのシステムで非常に大きなメモリ・サイズになると技術的にラップする可能性があります。実際には、このようなことは起こりにくく、Duktapeのヒープが64GBより大きいことが必要です。DUK_USE_REFCOUNT32 を無効にして、 refcount フィールドに size_t を使用します。


## コンパイル方法

### 概要

Duktapeのコンパイルには、2つの基本ステップがあります。

- コンフィギュレーション: tools/configure.py を使って、コンパイルのために Duktape のソース・ファイルやヘッダー・ファイルを準備します。要求される Duktape の設定は、configure.py のコマンドライン・オプションを使って記述します。例えば

```sh
$ python2 tools/configure.py --output-directory /tmp/output -DDUK_USE_FASTINT -UDUK_USE_ES6_PROXY
$ ls /tmp/output/
duk_config.h  duk_source_meta.json  duktape.c  duktape.h
```

- コンパイル: 生成されたヘッダーファイルがコンパイラのインクルード検索パスにあることを確認し、生成されたソースファイル（複数可）をアプリケーションのビルドに含めます；公式のDuktapeビルドスクリプトやMakefileはありません。例えば

```sh
$ gcc -O2 -Wall -otest -I/tmp/output /tmp/output/duktape.c my_application.c -lm
```

Duktapeは通常、アプリケーションと一緒にコンパイルされますが、静的ライブラリや共有ライブラリとしてビルドすることも可能です。Duktapeは、システム全体のライブラリとしてインストールすることもできます。system-install.rstを参照してください。

> DUK_OPT_xxx 機能オプションは、Duktape 2.x ではサポートされなくなりました。 すべての設定情報は、duk_config.h や自動生成されたソースやヘッダに埋め込まれています。


### コンフィギュレーション

#### 事前設定されたソースとデフォルトの構成

Duktapeの配布物には、いくつかのバリエーションを持つ事前設定済みのソースとヘッダが含まれています。

- src/: duk_config.h, duktape.h, duktape.c からなる単一のソース・ファイル・バージョンです。
- src-noline/: src/ と同じですが、結合されたソースファイルに #line 命令がありません。これは環境によっては重要です。https://github.com/svaarala/duktape/pull/363 を参照してください。
- src-separate/: duk_config.h, duktape.h と別々のソースファイルから構成されるバージョン。単一のソースファイル版が望ましいのですが、ツールチェインによっては別ファイルの方がうまくいく場合もあります。

これらの設定済みソースは、プラットフォーム、コンパイラ、アーキテクチャの自動検出を行い、Duktapeのデフォルト設定を使用します。

- ECMAScript E5/E5.1完全準拠（オプションのAnnex B機能を含む）、ただし意図的な実世界の互換性逸脱を除く（カスタム動作参照）
- ES2015 型付け配列と Node.js Buffer のサポート
- ECMAScript 2015 (E6) と ECMAScript 2016 (E7) からのいくつかの機能
- 利用可能な場合はパックされた値表現（1値あたり8バイト）、利用できない場合はパックされていない値表現（通常1値あたり16バイト）。
- 参照カウントとマーク・アンド・スイープ・ガベージコレクション
- 完全なエラーメッセージとトレースバック
- デバッグ出力やアサートなどはありません。
- すべてのポータブルな高速パスが有効

> 事前設定されたソースは、DuktapeをWindowsのDLLにビルドするためには使用できません。そのためには configure.py に --dll オプションを付けて実行してください。


#### Duktapeの設定をカスタマイズするためにconfigure.pyを実行する

configure.pyユーティリティは、コマンドラインオプションで記述された特定の設定に対応するDuktapeソースとヘッダファイルを準備します。例えば、fastint サポートを有効にし、ECMAScript 6 Proxy オブジェクトのサポートを無効にして、DLL ビルドのための Duktape ソースを準備する場合です。

```sh
# Default output format is single source file (--separate-sources for separate
# sources) and no #line directives (--line-directives to enable them).

$ python2 tools/configure.py \
      --output-directory /tmp/output \
      --dll \
      -DDUK_USE_FASTINT \
      -UDUK_USE_ES6_PROXY

# The output directory /tmp/output contains the header and source files to
# be included in your build.

$ ls /tmp/output
duk_config.h  duk_source_meta.json  duktape.c  duktape.h
```


configure.py に与えられた設定オプションは、例えば、用意されたヘッダーとソースファイルのいくつかの異なる側面に影響を与えます。

- Duktape ソースコードのオプション機能は、duk_config.h 設定ヘッダによって提供される設定オプション (DUK_USE_xxx) を使って有効/無効化されます。この設定ヘッダは、プラットフォーム、アーキテクチャ、コンパイラの検出や、プラットフォームの移植性に関する他のすべての側面も処理します。
- 組み込みオブジェクトと文字列はメタデータファイルから読み込まれ、ビットパックされた組み込み初期化データが生成されます。また、カスタムのメタデータファイルを供給して、カスタムの組み込みバインディングを追加したり、MathやJSONなどの標準組み込みを変更することも可能です。
- ROMビルトイン "を使用する場合、ビルトインオブジェクトと文字列は、RAMフットプリントを減らすために読み取り専用のコードセクションに配置されます。ビルトインオブジェクトや文字列のイニシャライザに必要なソースコードは、configure.pyによって自動生成されます。また、カスタムのビルトインもリードオンリーコードセクションに配置することができます。
- Unicodeデータファイル(UnicodeData.txtとSpecialCasing.txt)は、ビットパックされたランタイムユニコードテーブルに変換されます。Unicodeデータファイルは、例えば、Unicodeテーブルのフットプリントを小さくするためにオーバーライドすることも可能です。

configure.py ユーティリティは Python 2.x のサポートが必要です。ビルド環境がPython 2.xをサポートしていない場合、別のプラットフォームでconfigure.pyを実行し、ビルド環境で結果のファイルをコンパイルすることができます。

デフォルトのオプションで問題ない場合でも、事前に設定されたソースを使用する代わりに、ビルドの一部としてconfigure.pyを実行することが推奨されます。カスタムオプションは、例えば低メモリのプラットフォームでは必要かもしれません。より実用的な詳細については、Duktapeのビルドのための設定 を参照してください。

#### 一般的に必要とされる設定オプション

一般的に必要とされる設定オプションをいくつか紹介します。

- DUK_USE_FATAL_HANDLER, 強く推奨。組み込みのデフォルトの致命的なエラーハンドラは、デバッグログメッセージを書き (stdout と stderr には何も書きません)、次に abort() を呼び出します。これが失敗すると、無限ループに入り、致命的なエラーの後に実行が再開されないことを確認します。これは通常、より優れた致命的なエラーの回復メカニズムを持っている可能性のある実運用アプリケーションにとって、最良の動作ではありません。デフォルトの致命的なハンドラを置き換えるには、致命的なエラーを処理する方法を参照してください。
- 長い制御転送：setjmp/longjmp と C++ 例外。デフォルトでは、Duktapeは内部の長い制御転送にsetjmp()とlongjmp()（またはその亜種）を使用します。C++コンパイラーでコンパイルする場合は、DUK_USE_CPP_EXCEPTIONSを使用すると、Duktapeが長い制御転送にC++例外を使用し、Duktape/C関数におけるスコープベースのリソース管理（自動デストラクタなど、RAIIと呼ばれることもあります）が期待通りに機能するようになります。MSVCでは、/EHsc例外モデルを避けるように注意してください（代わりに/EHsなどを使用してください）。なぜなら、"c "オプションは、MSVCがextern C関数がC++例外を投げられないと仮定してしまうからです。
- Windows DLL のビルド。Windows DLL ビルドでは、DLL ライブラリーのシンボルに対して declspec() 宣言が必要です。Duktapeのシンボルに対してこれらを有効にするには、configure.pyの実行時に-dllオプションを使用します。
- 強制的なバイト順やアライメント。Duktapeの自動機能検出が（まだ）機能していないプラットフォームでDuktapeを使う場合、設定段階で特定のバイト順やアライメントの要件を強制的に指定する必要があるかもしれません。
- エキゾチック・プラットフォームでの日付ビルトイン。新しいプラットフォームやエキゾチックなプラットフォームに移植する場合、Duktapeの組み込み日付サポートが、そのプラットフォームで動作しないことがあります。このような場合、外部の「Dateプロバイダ」を実装することで、Duktapeの変更なしに、必要な日付/時刻プリミティブを提供することができます。datetime.rstを参照してください。
- ネイティブ・スタック・チェック・マクロ。ターゲットが小さなスタックを持っている場合、DUK_USE_NATIVE_STACK_CHECK() マクロを定義すると便利です。これは、スタックフレームのサイズを考慮できないスタック深さの制限よりも、スタック枯渇に対するより良い保護策を提供します。


#### メモリ管理方法の選択肢

メモリ管理の選択肢は2つあります。

- 参照カウントとマーク＆スイープ（デフォルト）：ヒープオブジェクトは、到達不可能な参照サイクルに参加しているオブジェクトを除いて、到達不可能になった時点で直ちに解放されます。そのようなオブジェクトは、定期的に自発的に解放され、世界のマークアンドスイープコレクションを停止します。マークアンドスイープは、メモリ割り当てに失敗した場合の緊急ガベージコレクタとしても使用されます。
- マークアンドスイープのみ: コードフットプリントとメモリーフットプリントを減らしますが (ヒープヘッダが参照カウントを保存する必要がありません)、デフォルトの場合よりもメモリー使用量のばらつきがあります。また、自発的な、世界を停止するマークアンドスイープ収集の頻度は、参照カウントがほぼすべてのメモリ管理を処理することが期待されるデフォルトの場合よりも高くなります。自発的な (緊急でない) mark-and-sweep は config オプションで無効にすることができます。

参照カウントは、参照サイクルを処理するために mark-and-sweep に依存します。例えば、すべての ECMAScript 関数インスタンスは、関数用に作成された自動プロトタイプオブジェクトとの参照ループに入ることが要求されます。必要であれば、このループを手動で解除することができます。内部技術的な理由により、名前付き関数式も参照ループ内にあります。このループはユーザーコードから壊すことができず、mark-and-sweepのみがそのような関数を収集することができます。


### コンパイル方法

#### 一般的なガイドライン

Duktapeは公式のMakefileやビルドスクリプトを持っていません：異なる移植性のターゲットの数を考えると、公式のビルドスクリプトを維持することは難しいでしょう。その代わり、最も自然な方法で、既存のビルド・プロセスに Duktape を追加する必要があります。

DuktapeはCまたはC++コンパイラ（C99を推奨）でコンパイルされ、何らかの方法であなたのプログラムにリンクされます。正確な詳細はプラットフォームやツールチェインによって異なります。例えば、以下のようなことが可能です。

- Duktapeをあなたのプログラムと一緒にコンパイルし、明示的にリンクするステップを省く。
- Duktapeを静的ライブラリーとしてコンパイルし、その静的ライブラリーをプログラムにリンクする。
- Duktapeをダイナミック・ライブラリーとしてコンパイルし、ダイナミック・ライブラリーをあなたのプログラムとリンクする。
- Duktapeをダイナミック・ライブラリーとしてコンパイルし、システム全体にインストールし、いくつかのアプリケーションから使用する。

DuktapeのAPI関数はすべてマクロである可能性があり、あるAPIプリミティブの実装は互換性のあるリリース間でもマクロと実際の関数とで変わる可能性があります。Duktapeの設定オプションの中には、バイナリ互換性に影響を与えるものがあります。バイナリ互換性を確保するために

- アプリケーション・コードにduktape.hをインクルードしてください。これは一般的に良い習慣ですが、このヘッダーがないと、コンパイラーは全てのDuktape API関数が実際の関数であると誤って判断してしまい、リンクに失敗する原因となります。
- Duktapeとアプリケーションをコンパイルする際には、用意した同じDuktapeソースとヘッダを使用してください。これにより、Duktapeとあなたのアプリケーションは、全く同じDuktapeのバージョンとコンフィギュレーションでコンパイルされることを保証します。これは、Duktapeがライブラリとして別のコンパイル・ステップでコンパイルされる場合に特に重要です。
- Duktapeとアプリケーションをコンパイルする際には、同じコンパイラーを使用してください。異なるコンパイラーを使うと、例えばDuktapeのduk_config.hヘッダーの型検出や、関数の呼び出し規則などに影響を与え、バイナリ互換性が損なわれる可能性があります。実際には、コンパイラはある程度混在させることができます。たとえば、GCCとClangは一般に互換性があります。


#### 推奨されるコンパイラのオプション

GCC/clang のための推奨コンパイラー・オプションです。

- -std=c99: C99のセマンティクスを確保することを推奨。C型の検出を改善し、Duktapeが可変長マクロを使えるようにします。
- -Wall：潜在的な問題を早期に発見するために推奨します。
- -Os: Duktapeをエンベッディングする際に必要な、最小のフットプリントを実現するために最適化されます。-O2 は、パフォーマンスを最適化したビルドのための良い妥協点です。
- -fomit-frame-pointer: フレーム・ポインターを省略します。フットプリントはさらに小さくなりますが、デバッグの妨げになる可能性があります（デバッグ・ビルドからは除外してください）。
- -fstrict-aliasing: 厳密なエイリアシングルールを使用します。Duktapeはこれらのルールと互換性があり、結果のCコードを改善します。
- Configure.py の --dll は、Duktape が DLL としてビルドされる場合、少なくとも Windows 用にコンパイルする場合は必要です。


#### コンパイル時の警告について

Duktapeは、主流のコンパイラー（GCC、Clang、MSVC、MinGWなど）をC99モードで使用し、警告を有効にし（例：gcc/clangの-Wall）、デフォルトのDuktape設定オプションを使用すると、通常警告なしにコンパイルされます。非主流コンパイラー、非常に厳しい警告レベル（gcc/clangの-WextraやMSVCの/W4など）、デフォルトでないDuktape設定オプションを使用した場合、いくつかの警告が発生する可能性があります。すべてのコンパイラとすべての設定オプションの組み合わせについて、コンパイル時の警告をなくすことは非常に困難であり、プロジェクトの目標には明示的になっていません。警告を報告して、可能な限り修正することが推奨されます。

#### C++コンパイラを使う場合

Duktapeは、CとC++の両方のコンパイラーとアプリケーションで動作します。Duktapeとアプリケーションは、CコンパイラーとC++コンパイラーを自由に組み合わせてコンパイルすることができます。ただし、Duktapeとアプリケーションは、同じコンパイラ（CコンパイラまたはC++コンパイラ）で、同じコンパイラ・オプションでコンパイルすることが推奨されます。

duktape.hヘッダは、これらの組み合わせのすべてを動作させるために必要なグルー（接着剤）を含んでいます。具体的には、DuktapeのパブリックAPIが必要とする全てのシンボルは、extern "C" { ...}の中に入っています。C++コンパイラーでコンパイルする場合は、extern "C" { ...} ラッパーの中に入っています。これにより、そのようなシンボルはC++の名前を混乱させることなく定義され、使用されることが保証されます。具体的には

- Duktape自身をC++コンパイラーでコンパイルする場合、DuktapeのパブリックAPIが必要とするシンボルはマングルされません。その他のDuktape内部のシンボルはマングルされますが、外部からは見えないので、Cコンパイラーでコンパイルしても問題はありません。
- C++コンパイラーでアプリケーションをコンパイルする場合、ラッパーは、アプリケーションが使用するDuktapeパブリックAPIシンボルがマングルされずにルックアップされることを保証します。

CとC++のコンパイルが混在している場合、最終的なリンクはC++ツールチェーンで行う必要があります。少なくともgcc/g++を混在させた場合、以下のようなことに遭遇するかもしれません。


```sh
$ g++ -c -o duktape.o -Isrc/ src/duktape.c
$ gcc -c -o duk_cmdline.o -Isrc/ examples/cmdline/duk_cmdline.c
$ gcc -o duk duktape.o duk_cmdline.o -lm
duktape.o:(.eh_frame+0x1ab): undefined reference to \`__gxx_personality_v0\'
collect2: error: ld returned 1 exit status
```

修正方法としては、リンクにg++を使用することです。

```sh
$ g++ -c -o duktape.o -Isrc/ src/duktape.c
$ gcc -c -o duk_cmdline.o -Isrc/ examples/cmdline/duk_cmdline.c
$ g++ -o duk duktape.o duk_cmdline.o -lm
```


duk_config.hはDuktapeが必要とするC/C++データ型を選択し、その他の機能検出も行うため、CとC++コンパイラーを混在させると、理論的にはCとC++コンパイラーが異なる有効な機能やデータ型になってしまう可能性があります。もしそのようなことが起これば、Duktapeとアプリケーションのバイナリに互換性がなくなり、問題を診断するのが非常に困難になります。これは通常、問題にはなりませんが、この可能性を避けるために、Duktapeとアプリケーションを同じコンパイラーでコンパイルしてください。

デフォルトでは、スコープ・ベースのリソース管理（RAIIと呼ばれることもあります）はDuktape/C関数では動作しません。これは、Duktapeが内部の長い制御転送にlongjmp（）を使用し、C++スタック巻き戻しメカニズムを回避しているためです。DUK_USE_CPP_EXCEPTIONSを使用すると、Duktapeは内部での長い制御転送にC++の例外を使用するようになり、Duktape/C関数でスコープ・ベースのリソース管理を動作させることができるようになります。MSVCでは、/EHsc例外モデルを避けるように注意してください（代わりに/EHsなどを使用してください）。なぜなら、"c "オプションは、MSVCがextern C関数がC++例外を投げることができないと仮定するからです。MSVCとCMakeを使用する場合、例えば以下のように使用できます。

```sh
if (MSVC)
    string( REPLACE "/EHsc" "/EHs" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}" )
endif()
```


## 移植性

Duktapeは、少なくともC89コンパイラーを持つプラットフォームに広く移植可能です（ snprintf()とvsnprintf()を必要とするようないくつかの例外はありますが）。Duktapeはプラットフォーム関数への依存が非常に少ないため、非常にエキゾチックなプ ラットフォームへのDuktapeの移植が可能です。主なプラットフォーム依存の1つはDate組み込みで、異国のプラットフォームではカスタム・プロバイダーが必要になる場合があります。

プラットフォームやコンパイラー固有の移植性の問題、移植の推奨事項、トラブルシューティングのヒントについては、「移植性」を参照してください。


## 互換性

このセクションでは、ECMAScriptの方言、拡張、フレームワーク、およびテスト・スイートとDuktapeの互換性について説明します。


### ECMAScript E5 / E5.1

Duktapeの主な互換性目標は、ECMAScript E5/E5.1互換であることです。しかし、ES5の機能セマンティクスは、より新しい仕様バージョンで互換性のない変更が行われた場合、ES2015（またはそれ以降）に更新されます。現在の互換性レベルはかなり高いはずです。


### ECMAScript 2015 (E6)

DuktapeはECMAScript 2015（E6）の機能を一部実装していますが、一般的にE6との互換性はまだありません。


### ECMAScript 2016（E7）

DuktapeはECMAScript 2016（E7）からいくつかの機能を実装していますが、一般的にE7との互換性はまだありません。


### ECMAScript E3 

E5/E5.1仕様で要求される以外に、ECMAScript E3との互換性を維持するための努力はしていません。

### CoffeeScript

CoffeeScriptは、Duktapeと互換性があるはずのJavaScriptにコンパイルされます。既知の互換性の問題はありません。

いくつかのCoffeeScriptのサンプルが配布物に含まれています。単に examples/coffee/ で make を実行するだけです。例えば、hello.coffee:

```coffee
print 'Hello world!'
print 'version: ' + Duktape.version
```

コンパイルすると

```javascript
(function() {

  print('Hello world!');

  print('version: ' + Duktape.version);

}).call(this);
```


### Coco

CoffeeScriptと同じく、CocoはJavascriptにコンパイルします。既知の問題はありません。


### LiveScript

CoffeeScript と同様に、LiveScript は Javascript にコンパイルされます。既知の問題はありません。


### TypeScript

TypeScript は Javascript にコンパイルされます。Microsoft TypeScript コンパイラ（ES5/CommonJS モード）を使って TypeScript をコンパイルし、Duktape を使って結果の Javascript を実行しても、既知の問題はありません。また、DuktapeでTypeScriptコンパイラーを実行することも可能です。


### Underscore.js

Underscore.jsは、プレーンなECMAScriptに多くの便利なユーティリティを提供します。Duktapeは、Underscoreのほぼ全てのテストケースをパスします。現在の互換性ステータスについてはunderscore-status.rstを参照してください。


### Test262

test262はE5.1互換性をテストするためのテスト・スイートですが、標準のE5.1以外のテストも含まれています。Duktape は test262 のほぼ全てのケースに合格しています。現在の互換性ステータスは test262-status.rst を参照してください。


### Asm.js

asm.js は「コンパイラのための低レベルで効率的なターゲット言語として使用できる、JavaScript の厳密なサブセット」です。JavaScriptのサブセットとして、asm.jsの型注釈を使った関数は、Duktapeと完全に互換性があるはずです。しかし、Duktapeはasm.jsを特にサポートしておらず、asm.jsのコードを最適化することはありません。実際、asm.jsのコードは不要なバイトコードを生成し、通常のECMAScriptのコードよりも実行速度が遅くなります。asm.jsによって指定された "use asm "指示は、Duktapeでは無視されます。


### Emscripten

Emscriptenは、C/C++をJavascriptにコンパイルします。Duktapeは現在（Duktape 1.5.0時点）Emscriptenと互換性があり、Emscriptenのfastcompが使用できるES2015 TypedArrayをサポートしています。

Duktapeコンパイラが仮想レジスタを使い果たすため、大規模なプログラムは失敗する可能性があります。また、Duktapeはインタプリタ型エンジンであるため、性能はやや制限されます。現在の互換性の状況は emscripten-status.rst を見てください。

Duktape自体はEmscriptenでコンパイルされているので、例えばWebページの中でDuktapeを実行することも可能です（Dukweb REPLを参照）。


### Lua.js

lua.jsは、LuaのコードをJavascriptに変換します。生成されたJavascriptを実行する上で既知の問題はありませんが、Duktapeがlua.jsが期待するconsole.logを提供しないことが挙げられます。これは簡単に改善できます。例えば、以下のように前置きをします。

```lua
console = { log: function() { print(Array.prototype.join.call(arguments, ' ')); } };
```


### JS-Interpreter

JS-Interpreterは、JavascriptをJavascriptの中で解釈します。JS-InterpreterはDuktapeと一緒に動作しますが、DuktapeはJS-Interpreterが期待するウィンドウを提供しません。これは、プリペンドすることで修正可能です。

```javascript
window = {};
```

## バージョニング

### セマンティック・バージョニング

Duktapeは、公式リリースの際にセマンティック・バージョニングを採用しています。

- APIと互換性のない変更が行われた場合は、メジャー・バージョンに変更します。
- マイナー・バージョンの変更は、後方互換性のある機能的な変更が行われたときに行われます。
- 後方互換性のあるバグフィックスが行われた場合は、パッチバージョンに変更されます。

このルールが適用される「公開API」には、以下のものが含まれます。

- duktape.orgで文書化されているDuktape APIコール。
- Duktapeオブジェクトと他のECMAScript拡張を含む、ECMAScriptコードから見えるグローバル環境（duktape.orgで文書化されているもの）。

以下のものは、「公開API」のバージョン保証の対象外です。

- experimentalとタグ付けされたDuktape APIコール、およびexperimentalとして文書化されたその他の機能。
- APIマクロによる内部コール。マクロとして実装されたAPIコールはパブリックAPIの一部ですが、マクロが行う内部コールは、たとえそのシンボルの可視性がパブリックであったとしても、パブリックAPIには含まれません。
- APIコールを関数コールからマクロに変更すること(またはその逆)。これらは互換性のある変更とみなされます (ただし、パッチリリースでは行われません)。
- 最新のECMAScriptの仕様に合わせる。Duktapeは、最新のECMAScript仕様（現在はES2016）を追跡しています。最新の仕様に合わせるために必要な後方互換性のない変更は、マイナー・バージョンでも行われることがあります（ただし、バグを修正する必要がある場合を除き、パッチ・バージョンでは行われません）。通常、このような変更は、例えば引数の強制やプロパティの継承の変更など、比較的小さなものです。
- マイナーバージョンでも変更される可能性があると明示的に指摘されている特定の動作、例えば
 - バッファオブジェクトのバッキングバッファが、バッファオブジェクトの見かけのサイズより小さい場合の動作。メモリセーフな動作は保証されますが、それ以外の動作はバージョンによって異なる可能性があります。
- Duktapeのコンフィグオプション。互換性のない設定オプションの変更は、パッチリリースでは行われませんが、マイナーリリースでは行われる可能性があります。目標は、サポートされなくなった機能オプションが使われたときに（可能であれば）コンパイル・エラーを発生させ、誤った仮定を修正できるようにすることです。
- Duktape と共に配布される Extras (extras/ ディレクトリ)。

パッチ版がリリースされた場合、以下のことが保証されます。

- APIバイナリ互換性の維持：定数値の変更、関数の型付けの変更、APIコール関数/マクロのステータスの変更はありません。
- バイトコードダンプ・ロードの形式は変更しないので、パッチバージョンのみが異なる旧バージョンからダンプしたバイトコードをロードすることができます。
- ECMAScriptのセマンティックスの修正は、バグフィックスに必要な場合を除き、含まれません。
- 設定オプションが互換性のない形で変更されることはありません。

Duktape リポジトリから作成された開発版ビルドは、公式リリースではなく、厳密なセマンティックバージョン管理には従いません。


### 実験的な機能

いくつかの新しい機能やAPIコールは実験的とマークされています。これは、マイナーリリースであっても互換性のない方法で変更される可能性があることを意味します。

例えば、有用ではあるが不完全であったり、最適な設計が明らかでないため、設計にコミットする前にフィードバックを収集することが有効であるなどの理由で、機能は実験的とマークされることがあります。通常、ある機能は1つのマイナーリリースで実験的なものとなり、その後、必要な変更を経て、完全にサポートされる機能となります。


### バージョンの命名規則

リリースは、(メジャー).(マイナー).(パッチ)の形式を使用します、例えば、1.0.3です。


### DUK_VERSIONとDuktape.versionについて

DUK_VERSIONとDuktape.versionは、次のように計算された1つの番号を使ってバージョンを識別します。(major * 10000 + minor * 100 + patch) のように計算された1つの番号を使用し、Duktape リポジトリから作られた開発版ビルド（公式リリースではない）については1つ減算されます。

開発版ビルドの制限に注意してください。

- 例えば、1.3.0リリース以前のmasterからのビルドは、すべて10299として識別されます。
- パッチリリース用の開発版ビルドは、以前のパッチリリースと区別されません: 例えば、1.3.2 より後 1.3.3 より前の開発版ビルドは 10302 と識別されます。

開発版ビルドは実運用に使うべきではありませんが、現在の DUK_VERSION と Duktape.version 番号は、バージョンを比較するのに便利な近似値を提供します：開発版ビルドは、実際のリリースより小さく、以前のリリースより大きい（または同じ）比較をします。


### 例

以下の表は、バージョンの昇順にいくつかの例を示しています。

| Version | DUK_VERSION & Duktape.version | Notes |
| ---- | ---- | ---- |
| 0.12.0 | 1200  |  |
| 1.0.0  | 10000 |  |
| 1.2.99 | 10299 | Development build before 1.3 release. |
| 1.3.0  | 10300 |  |
| 1.3.2  | 10302 |  |
| 2.0.0  | 20000 |  |


### 安定版のメンテナンスについて

長期的なメンテナンス方針はまだありません: 安定版には、少なくとも次の安定版がリリースされ、それに移行する時間ができるまでは、バグフィックス (パッチリリース) が行われます。

### 互換性のない変更

互換性のない変更の一般的な目標は、古くてサポートされていない機能に依存するアプリケーションのビルドに失敗することです。黙って壊れるよりも、ビルドに失敗する方が望ましいのです。これは、たとえば次のようなことを意味します。

- APIコールのセマンティクスが変更された場合、古いAPIコールは削除され（使用するとビルド失敗の原因になる）、新しいものが追加される。
- 古い機能オプションのサポートが削除された場合、それを使おうとするとビルド失敗の原因となる。
  
これは厳密なルールではなく、すべてのケースで実現できるわけではありません。


## 制限事項

以下は、現在の実装における既知の制限事項のリストです。制限には、セマンティクスの観点からの欠点、性能の制限、実装の制限（これは避けられない）などがあります。

些細なバグは「長期的なバグ」でない限り、リストアップしていません。


### 再入可能性なし

単一のDuktapeヒープ、つまり同じガベージコレクタを共有するコンテキストは、リエントラントではありません。C/C++のスレッドで、特定のDuktapeヒープに対して一度にDuktape APIを呼び出せるのは1つだけです（ただし、呼び出すスレッドは時間の経過とともに変更される可能性があります）。スレッド化」を参照してください。


### 文字列とバッファの制限

内部表現では、文字列の最大長は 2**31-1 (0x7fffffff) バイト（文字ではありません） までです。16ビットのコードポイントは最悪の場合UTF-8の3バイトにエンコードされるため、 動作が保証される最大文字列長は約0.7G文字となります。

バッファの値も 2**31-1 (0x7fffffff) バイトに制限されます。


### プロパティの制限

オブジェクトは最大で DUK_HOBJECT_MAX_PROPERTIES (内部定義) を持つことができます。現在のところ、この制限は 0x7ffffff です。


### 配列の制限

配列のアイテム・インデックスが 2**31-1 の制限 (0x7ffffff) を超えると、Duktape には配列のセマンティクスに関するいくつかの既知のバグが発生します。


### 空のマッチを超える正規表現量化子

正規表現エンジンは、空のマッチ上で量化子が使用されたときに行き詰まりますが、最終的には内部再帰（または実行ステップ）制限で救済されます。たとえば、次のコードは "no match" の結果を生成するはずですが、代わりに内部再帰の制限にヒットします。


```sh
$ duk
duk> t = /(x*)*/.exec('y');
RangeError: regexp executor recursion limit
    at [anon] (duk_regexp_executor.c:145) internal
    at exec () native strict preventsyield
    at global (input:1) preventsyield
```


### Duktapeはロケールを完全にサポートしていません。

Duktape はローカル時刻の概念をサポートしていますが、ロケールに関連する他の機能、例えば、ロケール固有の日付書式、ロケール固有の文字列比較、ロケール/言語固有の Unicode 規則（トルコ語、アゼリ語、リスアニア語のケース変換規則など）はサポートされていません。


### Unicodeの大文字・小文字変換は、ロケールや文脈に依存しない。

E5 15.5.4.16から15.5.4.19項では、Unicode SpecialCasing.txtのコンテキストとロケール処理を要求しています。しかし、Duktapeは現在、"current locale "の概念を持っていない。


### デフォルトでないプロパティ属性を使用した場合の配列のパフォーマンス

すべての配列要素は、書き込み可能で、列挙可能で、設定可能であることが期待されています（新しいプロパティのデフォルト・プロパティ属性）。この仮定が一時的にでも破られた場合、オブジェクトの「配列部分」全体は永久に放棄され、配列エントリーは「エントリー部分」に移動されます。この場合、使用されているすべての配列インデックスを明示的な文字列キー（"0"、"1 "など）としてインターフェイスすることになります。これはコンプライアンス上の問題ではありませんが、パフォーマンスを低下させます。


### Object.defineProperty() を用いて要素を書き込む際の配列の性能

Object.defineProperty() を使用して数値添字の配列要素を書き込む場合、現在の実装では内部の「配列部分」を放棄しているため、後の配列アクセスが非常に遅くなります。これを避けるには、a[123] = 321 のような直接代入で配列要素を記述してください。


### グローバル/評価コードに生成されるバイトコードは、関数コードより遅い。

グローバルコードや評価コード用に生成されたバイトコードは、変数をレジスタに静的に割り当てることができず、明示的な名前ベースの変数読み取り/書き込みアクセスが使用されます。関数コード用に生成されたバイトコードにはこの制限がありません。ほとんどの変数はレジスタに静的に割り当てられ、アクセスには直接レジスタ参照が使用されます。

これは、トップレベルのグローバル/評価コードを長時間実行するのでなければ、些細な問題です。回避策は簡単で、トップレベルから呼び出す関数の中にコードを入れておくことです。

```javascript
function main() {
    // ...
}
main();
```


また、この目的のために無名関数を使用するイディオムもよくあります。

```javascript
(function () {
    // ...
})();
```


### 関数テンポラリは、予想以上に長くガベージコレクションのために生き続けるかもしれません

ECMAScript の関数は、固定されたレジスタのセットでバイトコードにコンパイルされます。いくつかのレジスタは引数や変数バインディングのために予約され、他のものはテンポラリとして使用されます。すべてのレジスタはガベージコレクションの観点から生きているとみなされ、関数が実際にはもう参照できない古い値を含む一時的なレジスタであってもです。このような一時的なレジスタは、他の式の評価によって上書きされるか、関数が終了するまで到達可能であると見なされます。関数の終了は、ガベージコレクションを確実にするために、唯一容易に予測できる条件です。

もし、非常に長い時間実行し続ける関数があるならば、その関数には必要最小限の変数とテンポラリしかないはずです。例えば、次のようなコード構成にすることができます。


```javascript
function runOnce() {
    // run one iteration, lots of temporaries
}

function foreverLoop() {
    for (;;) {
        runOnce();
    }
}
```


これは通常、長時間稼働する関数がなければ問題にはならない。


### 関数インスタンスはマークアンドスイープによってのみガベージコレクションされます

ECMAScript のすべての関数インスタンスは、デフォルトでは、関数のために自動的に作成されたプロトタイプオブジェクトとの参照ループ内にあります。関数インスタンスの prototype プロパティは prototype オブジェクトを指し、prototype のコンストラクタのプロパティは関数インスタンスに戻ります。このような参照ループを収集できるのは、今のところマークアンドスイープだけです。参照カウントのみで構築した場合（推奨しません）、関数インスタンスがメモリをリークしているように見えることがあります。メモリは、関連するヒープが破棄されたときに解放されます。

参照ループを手動で解除することができます (ただし、これは少し面倒です)。

```javascript
var f = function() { };
var g = function() { };
var h = function() { };
Duktape.fin(f, function() { print('finalizer for f'); });
Duktape.fin(g, function() { print('finalizer for g'); });
Duktape.fin(h, function() { print('finalizer for h'); });

// not collected until heap destruction in a reference counting only build
f = null;            // not collected immediately

// break cycle by deleting 'prototype' reference (alternative 1)
g.prototype = null;
g = null;            // collected immediately, finalizer runs

// break cycle by deleting 'constructor' reference (alternative 2)
h.prototype.constructor = null;
h = null;            // collected immediately, finalizer runs

// mark-and-sweep triggers finalizer for 'f'
Duktape.gc();
```


内部技術的な理由により、名前付き関数式は内部環境レコードオブジェクトとの参照ループの中にもあります。このループはユーザーコードから抜け出すことができず、マークアンドスイープのみがこのような関数を収集することができます。通常の関数宣言や無名関数にはこの制限はありません。例


```javascript
var fn = function myfunc() {
    // myfunc is in reference loop with an internal environment record,
    // and can only be collected with mark-and-sweep.
}
```


Duktape 2.x以降、マーク・アンド・スイープは常に有効になっており、参照ループに参加しているオブジェクトは最終的に解放されます。設定オプションにより、定期的な「自発的」（緊急ではない）マーク＆スイープを無効化することで、時間に敏感な環境での収集の一時停止を減らすことができます。


### 非標準的な関数の「呼び出し元」プロパティの制限

DUK_USE_NONSTD_FUNC_CALLER_PROPERTY が与えられると、 Duktape は、例えば V8 や Spidermonkey と同様に、非標準の関数インスタンスの呼び出し側プロパティを更新します。しかし、いくつかの制限事項があります。

- evalコードから（非厳密な）関数が呼び出された場合、Duktapeはcallerに、evalコードが非厳密であればnull、厳密であればeval（組み込み関数evalの参照）をセットします。これは、例えばV8の動作とは異なっています。
- コルーチンとcallerは相性が悪く、コルーチンのコールスタックが完全に巻き戻された後でもcallerがnullでない状態で残っていることがあります。また、コルーチンがそのコールスタックが巻き戻される前にガベージコレクションされた場合、そのコールスタック内の関数の呼び出し元のプロパティは、今更更新されません。

詳細については、内部の test-bi-function-nonstd-caller-prop.js テストケースを参照してください。


### デバッガー休止状態でのガベージコレクション

デバッガー・サポートが有効で、デバッガー・セッションがアクティブで、Duktape が一時停止しているとき、現在いくつかの制限があります。

一時停止中はガベージ・コレクションが無効になるため、Duktape.gc() および duk_gc() への呼び出しは黙って無視されます。


## Luaとの比較

Duktapeは、概念的にLuaから多くのことを借りています。以下は、Luaと比較してDuktapeで何が違うかについてのメモです。Luaに既に慣れている方には役に立つかもしれません。


### 配列とスタックのインデックスはゼロベース

配列とスタックのインデックスは全てゼロベースで、Luaのような1ベースではありません。つまり、スタックの底は 0、下から 2 番目の要素は 1、一番上の要素は -1 です。0 はもはや無効/非存在の要素を示すのに利用できないので、Duktape では代わりに定数 DUK_INVALID_INDEX が使用されます。

文字列のインデックスもゼロベースで、スライスは開始インデックスを含み、終了インデックスを含まない（すなわち\[start,end\[）で示されます。Lua では、スライスは包括的なインデックス（例：\[start,end\]）で示されます。


### オブジェクト型は、関数とスレッドを表す

Luaでは、関数とスレッドは、オブジェクトとは別の型です。Duktapeでは、オブジェクト型は、プレーンオブジェクト、ECMAScriptやネイティブ関数、スレッド（コルーチン）に使用されます。その結果、これら全てのオブジェクトは、変更可能で拡張可能なプロパティのセットを持ちます。


### Lua userdata と lightuserdata

Luaのuserdataに最も近いコンセプトはDuktapeバッファ・タイプですが、以下のような相違点があります。

- Duktapeバッファーはサイズ変更可能ですが、Lua userdataの値はサイズ変更できません。Duktapeバッファはサイズ変更可能ですが、Luaのユーザーデータはサイズ変更できません。
- Duktapeバッファはプロパティを持たない生のバイト配列であり、Lua userdataオブジェクトは環境参照を格納することができます。

LuaのlightuserdataとDuktapeのポインタは、基本的に同じものです。

Duktapeバッファにプロパティを関連付ける必要がある場合、代わりにバッファ・オブジェクトを使用します（または、独自のオブジェクトを作成し、そのプロパティとしてプレーン・バッファを格納します）。そして、そのオブジェクトにファイナライザーを追加することで、バッファに関連するすべてのリソースを解放することができます。これは、バッファへの参照を保持するものが他にない限り、うまく動作します。もしそうだとすると、オブジェクトがファイナライズされた後にバッファが使用される可能性があります。これを防ぐために、ネイティブCの構造体は、データ構造がオープンかクローズかを示すフラグを持つべきでしょう。これは、堅牢なネイティブ・コードのためのグッドプラクティスです。


### ガベージ・コレクション

Duktapeは、参照カウントと非インクリメンタルなマーク＆スイープ・ガーベージ・コレク ターを組み合わせています（マーク＆スイープは参照サイクルのみに必要です）。マーク＆スイープの任意パスを無効にすることで、収集の一時停止を避けることができます（DUK_USE_VOLUNTARY_GCを無効にする）。Lua は一時停止のないインクリメンタル・コレクターを持ちますが、参照カウントはありません。

Duktapeには、緊急ガベージコレクタがあります。Lua 5.2には緊急ガベージコレクタがありますが、Lua 5.1にはありません（ただし、緊急GCパッチはあります）。


### duk_safe_call() vs. lua_cpcall()

duk_safe_call() は、既存の値スタック・フレームで動作する保護された C 関数呼び出しです。関数呼び出しは、呼び出しスタック上では全て見えません。

lua_cpcall()は新しいスタック・フレームを作成します。


### バイトコードダンプ/ロード

Duktape 1.3以降、DuktapeはLuaのlua_dump()に似たバイトコード・ダンプ/ロード・メカニズムを備えています。バイトコード・ダンプ/ロードを参照してください。


### メタテーブル

ECMAScript E5/E5.1 には Lua のメタテーブルに相当するものはありませんが、ECMAScript ES2015 Proxy オブジェクトが同様の機能を提供します。E5/E5.1よりも優れたプロパティの仮想化を可能にするために、DuktapeはES2015 Proxyのサブセットを実装しています。


### lua_next()とduk_next()の比較

lua_next() は、前のキーと値を新しいペアに置き換えますが、duk_next() はそうではありません。呼び出し側は、キーや値を明示的にポップする必要があります。


### ローアクセサ

lua_rawgetのようなLuaの生のテーブルアクセス関数に相当するものはありません。以下の ECMAScript の組み込み関数を使用することで、同様の効果を得ることができます (ただし、パフォーマンスに関しては別です)。Object.getOwnPropertyDescriptor ( O, P ), Object.defineProperty ( O, P, Attributes ).


### コルーチン

Duktape APIには、コルーチン制御のためのプリミティブはありません（Lua APIには、例えばlua_resumeがあります）。コルーチンの制御は、Duktape のビルトインで公開されている関数を使用する ことによってのみ可能です。さらに、Duktapeにはコルーチンの生成に関する多くの制限があります。例えば、コルーチンはコンストラクター呼び出しやゲッター/セッター呼び出しの内部で生成することはできません。


### 複数の戻り値

Lua は複数の戻り値をサポートしていますが、Duktape (または ECMAScript) は現在サポートしていません。これは、複数の値を返す構文を持つ ECMAScript ES2015 で変わるかもしれません。Duktape/C APIは、1以上の戻り値を予約し、後で複数の戻り値に使用できるようにします。


### 弱参照(Weak references)

Luaは弱参照をサポートしています。Duktapeは、現在サポートしていません。


### Unicode

Luaは、ビルトインのUnicodeをサポートしていません（文字列はバイト列です）が、DuktapeはECMAScript準拠の一環として、16ビットUnicodeをサポートしています。


### ストリーミング・コンパイル

Luaには、ストリーミング・コンパイルAPIがあり、コードがディスクから読み込まれたり、オンザフライで解凍されたりする場合に有効です。Duktapeは現在、ストリーミング・コンパイルをサポートしていません。これは、ソース・コードに対して複数のパスが必要だからです。

---

Duktape is (C) by its [authors](https://github.com/svaarala/duktape/blob/master/AUTHORS.rst) and licensed under the [MIT license](https://github.com/svaarala/duktape/blob/master/LICENSE.txt).