# Duktapeプログラマーズ・ガイド


## はじめに

Version: 2.6.0 (2020-10-13)


### ドキュメントの範囲

このガイドでは、あなたのプログラムでDuktapeを使用するための入門書を提供します。基本的な使い方に慣れてきたら、APIの詳細を調べるための簡潔なAPIリファレンスがあります。Duktape Wikiでは、より詳細な例やベストプラクティスを提供しています。

この文書では、Duktapeの内部構造はカバーしていません。内部構造をいじりたい場合は、Duktapeのリポジトリを参照してください。


### Duktapeとは？

Duktapeは、移植性とコンパクトなフットプリントを重視した、組み込み可能なECMAScript®エンジンです。DuktapeをC/C++プログラムに組み込むことで、スクリプトによる機能拡張を簡単に行うことができます。また、プログラムの主要な制御フローをECMAScriptで構築し、重い処理を行うために高速なCコード関数を使用することも可能です。

Duktapeを組み込むアプリケーションは、どのネイティブ・バインディングをどのような方法で提供するかを制御することができます。例えば、コンソールへのテキスト出力やファイル・システムとのやり取りに関するデフォルトのバインディングは存在しません。Duktapeの配布パッケージにはサンプル・プロバイダーが含まれており、ニーズに合わせて簡単に統合することができます。

ECMAScriptとJavascriptという用語は、しばしば多かれ少なかれ同等だと考えられていますが、Javascriptとその亜種は技術的にはECMAScript言語が使用される環境の一つに過ぎません。ブラウザ以外の ECMAScript 環境でも、ブラウザ固有のビルトインが提供されていることがよくあるので、両者の境界は実際にはあまり明確ではありません。それでも、Duktapeが実装している言語を指すために、ここではECMAScriptという用語を使用します。


## 準拠

DuktapeはES5.0/ES5.1に準拠し、必要に応じてES2015以降からセマンティクスを更新しています。

- ECMAScript言語仕様書第5版
- ECMAScript®言語仕様5.1版

Duktapeは、セマンティクスとビルトインに関する最新のECMAScript仕様を追跡しています（ただし、ES2015以降のサポートはまだ不完全です）、ご参照ください。

- ECMAScript® 2015言語仕様
- ECMAScript® 2016言語仕様

特定のケースでは、Duktapeは仕様のドラフトに従うことがあります（TC39/ecma262で進行中の作業を参照）。これは、最新仕様の機能が現実のコードと衝突する場合に行われます（例えば、RegExp.prototypeの問題を参照）。

TypedArrayのサポートはES2016 TypedArrayに基づいています。初期の実装はKhronos TypedArrayの仕様に基づいていました。

- TypedArray Specification (Editor's Draft 18 July 2013) (注: リンクは最新版です)
- svn co -r 30720 https://cvs.khronos.org/svn/repos/registry/trunk/public/typedarray

Node.jsのBufferサポートは、以下のものをベースにしています。

- Buffer Node.js v6.9.1。

TextEncoder()とTextDecoder()のバインディングは、以下を参考にしています。

- Encoding API, WHATWG Encoding Living Standard

Performance.now()バインディングは、以下をベースにしています。

- High Resolution Time Level 2


## 機能紹介

Duktapeは、ECMAScriptの標準的な機能の他に、以下の追加機能を備えています（一部はアプリケーションから見えるもの、その他は内部的なものです）。

- ES2015 TypedArrayおよびNode.js Bufferバインディング、プレーンなバッファタイプ(軽量なUint8Array)
- ECMAScript 2015 (ES6) から: setPrototypeOf/\_\_proto\_\_, Proxyオブジェクトのサブセット, Reflect, 計算されたプロパティ名, 最小限のconstサポート
- ECMAScript 2016 (ES7) から: 指数演算子 (\*\*, \*\*=)
- WHATWG Encoding Living Standardに基づくエンコーディングAPIバインディング
- Duktape固有のビルトイン：Duktapeグローバル・オブジェクトによって提供されます。
- 拡張型：カスタムの「バッファ」と「ポインタ」型、任意のバイナリ文字列と非BMP文字列をサポートする拡張文字列型（標準ECMAScriptは16ビットコードポイントしかサポートしていません）。
- 参照カウントとマーク＆スイープガベージコレクションの組み合わせ、ファイナライザーと緊急ガベージコレクション（マーク＆スイープだけで構築することも可能です）
- コルーチンのサポート
- テールコールのサポート
- デバッガプロトコルに基づく内蔵デバッガフレームワーク
- プラットフォーム依存のない組み込みの正規表現エンジン
- プラットフォームに依存しない組込みの Unicode サポート
- プラットフォームに依存しない組込みの数値解析と書式設定
- バイナリシリアライゼーション用の組込みCBORバインディング
- 追加のカスタムJSONフォーマット（JXとJC）
- コンパイル済み関数をキャッシュするためのバイトコードダンプ/ロード機構


## 目標

__コンプライアンス。__ ECMAScript E5/E5.1 と実世界でのコンプライアンス。ECMAScriptのコンプライアンスには、正規表現とUnicodeのサポートが必要です。可能であれば、最新またはドラフトECMAScript仕様から機能を実装し、Duktapeカスタム機能を最小化する。

__移植性。__ Duktapeは、システム・ライブラリへの依存を最小限に抑えることで、移植性を高めています。例えば、数値のフォーマットやパース、正規表現、Unicodeは、すべてDuktapeが内部で実装しています。完全に排除できない数少ない依存性の1つが、Date組み込みによるシステムの日付／時刻の統合です。Duktapeは主要なプラットフォームを直接サポートしていますが、エキゾチックなプラットフォームでは、外部のDateプロバイダーを使用することも可能です。

__簡単なC言語インターフェース。__ DuktapeとC言語プログラムとの間のインターフェースは、自然でエラーに強いものであるべきです。特に、文字列の表現がUTF-8であり、C言語の一般的な使用法に適合するように、自動的にNULターミネータが付加される必要があります。

__フットプリントが小さいこと。__ 小さなプログラムであっても、コードとデータのフットプリントは可能な限り小さくすべきです。Duktapeは、標準ライブラリのない「ベアメタル」ターゲットにも移植可能です。これは性能よりも重要なことです。なぜなら、非常に高速なエンジンはすでにいくつかありますが、非常にコンパクトでポータブルなエンジンは少ないからです。

__適度な性能。__ フットプリントが小さい（そしてある程度ポータビリティがある）ため、おそらく競争力のあるJITベースのエンジンの可能性はなく、SpiderMonkey（およびその最適化バージョン）やGoogle V8などの非常に高度なJITベースのエンジンと競争する現実的な方法はありません。それでも、典型的な組み込みプログラムでは、性能は妥当なものであるはずです。この点では、Luaが良いベンチマークになります。(オプションで、JIT化やオフラインコンパイルのサポートを追加するのも良いでしょう)。

__ASCII文字列の性能。__ プレーンなASCII文字列を扱う操作が非常に高速であることは重要です。ASCIIはほとんどの組み込み用途で支配的です。ASCII以外の文字列を扱う操作は、それなりに高速である必要がありますが、重要ではありません。これは必要なトレードオフです。C互換文字列を使うということは、本質的にUTF-8文字列表現を使うということであり、文字列インデックスや他の多くの操作が、固定サイズの文字表現を使う場合よりも遅くなるのです。それでも、文字列を順次（どちらかの方向に）効率的に反復するような一般的なイディオムをサポートすることは重要です。


## ドキュメントの構成

本書では、Duktapeのダウンロードからコンパイル、そしてプログラムへの組み込みまでを説明します。また、スクリプト機能をどのようにプログラムに組み込むか、具体的な例を示しています。

プログラミングモデル、スタック型。C型では、ヒープ、コンテキスト、バリュースタック、Duktape API、Duktape/C関数など、Duktapeの中核となる概念について説明します。Duktapeのスタック型とC言語の型ラッパーについても詳しく説明しています。

Duktape特有のECMAScriptの機能については、複数のセクションで説明しています。型アルゴリズム（カスタム型用）、Duktape組み込み機能（追加の組み込み機能）、Post-ES5機能（ES2016以降に実装された機能）、カスタム動作（標準とは異なる動作）、カスタムJSON形式、カスタムディレクティブ、バッファオブジェクト、エラーオブジェクト（プロパティとトレースバックサポート）、関数オブジェクト（プロパティ）、日付と時刻、乱数、デバッグ、モジュール、最終化、コルーチン、仮想プロパティ、記号、バイトコードダンプ/読み込み、スレッド化、サンドボックス化。

パフォーマンス」では、パフォーマンスを向上させ、パフォーマンスの落とし穴を回避するためのDuktape固有のヒントをいくつか提供しています。Memory usage（メモリー使用法） Duktapeのメモリー使用法を要約し、使用量を最小限に抑えるためのポインターを提供します。コンパイル アプリケーションの一部としてDuktapeを構成し、コンパイルする方法について説明しています。移植性 プラットフォームやコンパイラーに特有の問題や、その他の移植性に関する問題を扱います。互換性 DuktapeのECMAScript方言、拡張機能、フレームワークとの互換性について説明します。バージョン管理 Duktapeのバージョン管理について、またどのようなバージョン互換性が期待されるかについて説明します。制限事項 現在知られている制限事項を要約し、可能な回避策を提供します。

Luaとの比較では、LuaとDuktapeの違いについて説明します。すでにLuaに慣れている方には、有益な情報かもしれません。


## はじめに


### ダウンロード

Download ページからソース配布物をダウンロードします。


### テスト用コマンドラインツール

配布物を解凍します。

```sh
$ cd /tmp
$ tar xvfJ duktape-<version>.tar.xz
```


提供されたMakefileを使用して、コマンドラインツールをコンパイルしてください。

```sh
$ cd /tmp/duktape-<version>/
$ make -f Makefile.cmdline
```


Makefileはgccがインストールされていることを前提にしています。そうでない場合は、Makefileをあなたのコンパイラに合わせて編集すればよいのです（Makefileは非常にシンプルです）。

> Duktapeは移植性の問題を避けるため、ファイルやコンソールのI/Oに対する組み込みのバインディングを提供していません（例えば、I/O APIが全くないプラットフォームもあります）。コマンドライン・ユーティリティは、extras/print-alert を使って print() と alert() のバインディングを提供し、簡単に遊べるようにしています。配布物には、以下のような便利な(オプションの)バインディングを提供する「extras」があります。
>
> - print() や alert()
> - コンソールオブジェクト、例：console.log()
> 
> __このガイドの例では、説明のために print() バインディングを想定しています。__

> コマンドラインツールは、デフォルトでプラットフォーム依存を回避しています。Makefile を編集することで、linenoise による行編集のサポートを追加することができます。
> 
> - DDUK_CMDLINE_FANCY を追加する。
> - linenoise.hのヘッダに-Ipath/to/linenoiseを追加する。
> - ソースリストに path/to/linenoise.c を追加する。
> - LinenoiseはPOSIX環境でのみ動作し、Cコンパイラが必要です(C++ではありません)


ECMAScriptのコードをインタラクティブに実行できるようになりました。

```sh
$ ./duk
((o) Duktape 2.6.0 (v2.6.0)
duk> print('Hello world!')
Hello world!
= undefined
```


また、ECMAScriptのコードをファイルから実行することができるので、機能やアルゴリズムで遊ぶのに便利です。例として、fib.js を作成します。

```javascript
// fib.js
function fib(n) {
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    return fib(n-1) + fib(n-2);
}

function test() {
    var res = [];
    for (i = 0; i < 20; i++) {
        res.push(fib(i));
    }
    print(res.join(' '));
}

test();
```


コマンドラインからスクリプトをテストします。

```sh
$ ./duk fib.js
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
```


### Duktapeをプログラムに組み込む

コマンドラインツールは、Duktapeを組み込んだプログラムの一例です。Duktapeをあなたのプログラムに組み込むのは非常に簡単です。

- duktape-N.N.N/tools/configure.pyを実行して、ビルドのためにDuktapeを設定する。その結果、duktape.c, duktape.h, duk_config.h を含むディレクトリができます。
- duktape.c, duktape.h, duk_config.hをビルドに追加し、プログラムの他の場所からDuktape APIを呼び出してください。

Duktapeの配布物（duktape-N.N.N.tar.xz）のsrc/ディレクトリには、Duktapeのデフォルト設定のための事前設定済みのヘッダーファイルとソースファイルが含まれており、通常はそのまま使用することができます。必要であれば、設定ツールを使って、Duktapeを低メモリ・ターゲット用に最適化したり、機能を有効化／無効化したりといったDuktapeのオプションをカスタマイズすることができます。詳細と例については、Compiling and Configuring Duktape for build（ビルドのためのDuktapeのコンパイルと設定）を参照してください。

配布物には、このプロセスを説明する非常に簡単なサンプル・プログラム hello.c が含まれています。あらかじめ設定されたDuktapeのヘッダーとテストプログラムは、Duktapeコンテキストを作成し、それを使っていくつかのECMAScriptコードを実行します。
ソース・ファイルを使って、テスト・プログラムを例えば以下のようにコンパイルします。

```sh
$ cd /tmp/duktape-<version>/
$ gcc -std=c99 -o hello -Isrc src/duktape.c examples/hello/hello.c -lm
```


Duktapeの設定をカスタマイズするには、configure.pyを使います。

```sh
$ cd /tmp/duktape-<version>/
# Here we disable ECMAScript 6 Proxy object support
$ python2 tools/configure.py --output-directory duktape-src -UDUK_USE_ES6_PROXY
$ gcc -std=c99 -o hello -Iduktape-src duktape-src/duktape.c examples/hello/hello.c -lm
```


テストプログラムは、Duktapeコンテキストを作成し、それを使っていくつかのECMAScriptコードを実行します。

```sh
$ ./hello
Hello world!
2+3=5
```


Duktapeはエンベデッドエンジンなので、プログラムの基本的な制御フローを変更する必要はありません。基本的なやり方は

- プログラムの初期化時などに、Duktapeコンテキストを作成します（スクリプトが必要な場合は、オンデマンドでも構いません）。通常、初期化時にスクリプトをロードしますが、これはオンデマンドで行うこともできます。
- コードの中でスクリプトを使用したい箇所を特定し、そこにスクリプト関数の呼び出しを挿入します。
- スクリプト関数の呼び出しを行うには、まずDuktape APIを使って呼び出しの引数をDuktapeコンテキストのバリュー・スタックにプッシュします。その後、別のDuktape APIコールを使って実際の呼び出しを開始します。
- スクリプトの実行が終了すると、制御がプログラムに戻り（APIコールが戻り）、Duktapeコンテキストのバリュー・スタックに戻り値が残されています。C言語コードは、Duktape APIを使ってこの戻り値にアクセスすることができます。

より広い意味で、Duktapeをネイティブ・コードで使用する方法には、いくつかのアプローチがあります。

- メイン・アプリケーションはC/C++コードで実行し、基本機能の拡張のためにDuktapeを呼び出す（例：プラグインやコンフィギュレーションなど）。
- メイン・アプリケーションはECMAScriptコードで実行し、I/Oやパフォーマンス重視の操作などでは、シンプルなC/C++ネイティブ・バインディングを呼び出す。ネイティブバインディングはしばしばステートレスに保たれ、ステートロジックがスクリプトコードから見えないようにします。
- ECMAScript コードでメインアプリケーションを実行し、パフォーマンス重視の操作にはより複雑でステートフルな C/C++ ネイティブバインディングを使用します。例えば、グラフィックエンジンはネイティブオブジェクトとして実装することができます。

詳しい例は、以下のWiki記事を参照してください。

- はじめに: ラインプロセッシング
- はじめに: プライマリティテスト


## プログラミングモデル


### 概要

Duktapeを使ったプログラミングは非常に簡単です。

- Duktapeのソース (duktape.c) とヘッダ (duktape.h と duk_config.h) をビルドに追加してください。もし、デフォルトの設定が適切でなければ、 python2 tools/configure.py を使って、カスタム設定用の Duktape ソースとヘッダを準備します。
- Duktapeヒープ（ガベージコレクション領域）と初期コンテキスト（基本的にスレッドハンドル）をプログラム内に作成します。
- 必要なECMAScriptスクリプト・ファイルをロードし、Duktape/C関数を登録します。Duktape/C関数は、ECMAScriptコードから呼び出すことができるC関数で、性能向上やネイティブ・ライブラリへのバインディングなどのために利用できます。
- ECMAScriptの関数を呼び出すには、適宜、Duktape APIを使用してください。Duktape APIは、関数との間で値を受け渡しするために使用されます。値は、C言語の表現とDuktape内部（ECMAScript互換）の表現との間で変換されます。
- Duktape APIは、（ECMAScriptから呼び出された）Duktape/C関数が呼び出しの引数にアクセスしたり、戻り値を提供したりする際にも使用されます。

それでは、すべてのステップとそれに関連する概念をより詳しく見ていきましょう。


### ヒープとコンテキスト

Duktapeのヒープとは、ガベージコレクションのための1つの領域です。ヒープは、文字列やECMAScriptオブジェクト、その他の可変サイズのガベージコレクション・データのためのストレージを割り当てるために使用されます。ヒープ内のオブジェクトは、参照カウント、マーク＆スイープ・ガベージコレクション、オブジェクトのファイナライゼーションなどに必要な情報を提供する内部ヒープ・ヘッダを備えています。ヒープオブジェクトは互いに参照し合うことができ、ガベージコレクションの観点から到達可能性グラフが作成される。例えば、ECMAScript オブジェクトのプロパティは、そのオブジェクトのプロパティセットのキーと値の両方を参照します。複数のヒープを持つことができますが、異なるヒープにあるオブジェクトはお互いを直接参照することができません。ヒープ間で値を渡すにはシリアライズを使用する必要があります。

DuktapeコンテキストはECMAScriptの「実行スレッド」であり、特定のDuktapeヒープに住んでいるものです。Duktape APIでは、コンテキストは duk_context * で表され、Duktape内部のコルーチン（協調スレッドの一種）に関連付けられます。各コンテキストはグローバル・オブジェクトからなる環境とも関連付けられています。コンテキストは同じグローバル環境を共有することもできますが、異なる環境を持つこともできます。コンテキスト・ハンドルはほぼ全てのDuktape APIコールに与えられており、呼び出し側はDuktapeコルーチンの値スタックと対話することができます：値の挿入や問い合わせ、関数の呼び出しなど。

各コルーチンは、実行を制御するコールスタックを持ち、ECMAScript エンジン内のネイティブまたは ECMAScript の関数呼び出しを追跡します。各コルーチンはまた、コルーチンのアクティブなコールスタックのすべての ECMAScript 値を格納する値スタックを持っています。値スタックは常に最新の関数呼び出しのアクティブ・スタック・フレームを持ちます（関数呼び出しが行われていない場合、アクティブ・スタック・フレームはそのまま値スタックとなります）。Duktape APIの呼び出しは、ほとんど現在アクティブなスタック・フレームだけで動作します。また、try-catch-finallyなどを使ってエラー・キャッチのサイトを確立するための内部ブックキーピングもあります。

複数のコンテキストが同じDuktapeヒープを共有することができます。より具体的に言うと、これは複数のコンテキストが同じガベージコレクションの状態を共有でき、安全にオブジェクト参照を交換できることを意味します。異なるヒープにあるコンテキストは、直接オブジェクト参照を交換することはできません。すべての値は、何らかの方法でシリアライズされなければなりません。

Duktape APIが提供するほぼすべてのAPIコールは、その最初の引数としてコンテキスト・ポインタを取ります。グローバル変数や状態は使用されず、複数の独立したDuktapeヒープとコンテキストを同時に実行することに何の制限もありません。ただし、マルチスレッドに関する制限はあります。1つのヒープ内で任意のコードを実行できるネイティブ・スレッドは1つだけです。

Duktapeヒープとヒープ内の初期コンテキストを作成するには、単純に次のようにします。

```c
duk_context *ctx = duk_create_heap_default();
if (!ctx) { exit(1); }
```


独自のメモリ割り当て関数や致命的なエラーハンドラ関数を用意する場合（推奨）は

```c
duk_context *ctx = duk_create_heap(my_alloc,
                                   my_realloc,
                                   my_free,
                                   my_udata,
                                   my_fatal);
if (!ctx) { exit(1); }
```


同じヒープ内に新しいコンテキストを作成し、そのコンテキストが同じグローバルオブジェクトを共有するようにします。

```c
duk_context *new_ctx;

(void) duk_push_thread(ctx);
new_ctx = duk_get_context(ctx, -1 /*index*/);
```


同じヒープ内に新しいコンテキストを作成するが、グローバルオブジェクトのセットは新しいものにする。

```c
duk_context *new_ctx;

(void) duk_push_thread_new_globalenv(ctx);
new_ctx = duk_get_context(ctx, -1 /*index*/);
```


コンテキストは到達不可能になった時点で自動的にガベージコレクションされます。これはまた、もしあなたのCコードがduk_context *を保持しているなら、対応するDuktapeコルーチンはガベージコレクションの観点から到達可能でなければならない（MUST）ことを意味します。

ヒープは、呼び出し元がそれを使い終わったときに明示的に破棄されなければなりません。

```c
duk_destroy_heap(ctx);
```

これにより、割り当てられたすべてのヒープオブジェクトが解放され、そのようなオブジェクトへのポインタがすべて無効になる。特に、呼び出し元のプログラムが、ヒープに関連付けられたコンテキストの値スタックに存在する値への文字列ポインタを保持していた場合、そのポインタは無効になり、ヒープ破棄呼び出しが戻った後は決して再参照してはならない。


### コールスタック（コンテキスト）

コンテキストのコールスタックは、呼び出し元からは直接見えません。これは、あるコンテキストで現在実行されている C または ECMAScript の関数呼び出しの連鎖を記録しています。この簿記の主な目的は、関数の呼び出し元と呼び出し先の間で引数と結果の受け渡しを容易にし、関数呼び出しの間で値スタックがどのように分割されたかを追跡することです。また、コールスタックによって、Duktapeはエラー時のトレースバックを構築することができます。

Duktapeはテールコールをサポートしているため、コールスタックは必ずしも真のコールチェインを正確に表しているとは限りません。

> Cスタックと混同しないように。


### (コンテキストの)値スタックと値スタックインデックス

コンテキストの値スタックは、コルーチンの現在の実行状態に関連するタグ付き型の値の配列である。使用されるタグ付き型は、undefined, null, boolean, number, string, object, buffer, pointer, and lightfunc です。利用可能なタグ付き型の詳細については、「型」を参照してください。

値スタックは、コルーチンのコールスタック上の現在アクティブな関数呼び出し（アクティベーション）間で分割されます。いつでも、スタック上の要素をインデックスするための原点を提供するアクティブなスタックフレ ームがあります。より具体的には、Duktape APIではインデックス・ゼロで参照されるボトム（底）が常に存在します。また、現在使用されている最も高い要素のすぐ上にあるスタック要素を特定する概念的なトップがあります。以下の図がこれを示しています。

```
 Value stack
 of 15 entries
 (absolute indices)

.----.
| 15 |
| 14 |
| 13 |
| 12 |      Active stack frame (indices
| 11 |      relative to stack bottom)
| 10 |
|  9 |      .---.   Stack top is 6 (relative to stack bottom).
|  8 | <--- | 5 |   API index 5 is highest used (at value stack index 8).
|  7 |      | 4 |
|  6 |      | 3 |
|  5 |      | 2 |
|  4 |      | 1 |
|  3 | <--- | 0 |   API index 0 is bottom (at value stack index 3).
|  2 |      `---'
|  1 |
|  0 |
`----'
```


内部値スタックの要素を参照する直接的な方法はありません。Duktape APIは、常に現在アクティブなスタック・フレームを扱います。Duktape APIは、常に現在アクティブなスタック・フレームを扱うため、文書全体を通してスタック・フレームは水平に表示されます。例えば、上図のアクティブなスタック・フレームは、次のように表示されます。

```
| 0 | 1 | 2 | 3 | 4 | 5 |
```


スタック・インデックスは、Duktape APIで使用される符号付き整数のインデックスで、現在のアクティブなスタック・フレームの要素を、現在のフレームの底から相対的に参照するために使用されます。

負ではない（>= 0）のインデックスは、フレームの底を基準として、現在のスタック・フレーム内のスタック・エントリーを参照します。

```
| 0 | 1 | 2 | 3 | 4 | <5> |
```


負の（< 0）インデックスは、スタックの先頭からの相対的なエントリーを指します。

```
| -6 | -5 | -4 | -3 | -2 | <-1> |
```


特殊定数 DUK_INVALID_INDEX は、無効なスタックインデックスを示す負の整数である。これは API 呼び出しから返され、また API 呼び出しに与えて "値がない" ことを示すことができます。

スタックトップ(または単に "トップ")は、最も使用されているインデックスのすぐ上の仮想要素の非負のインデックスである。例えば、最も使用されているインデックスの上は 5 であるので、スタックトップは 6 である。 トップは現在のスタックサイズを示し、またスタックにプッシュされる次の要素のインデックスである。

```
| 0 | 1 | 2 | 3 | 4 | <5> | (6) |
```


> API のスタック操作は、常に現在のスタックフレームに限定される。現在のフレームより下のスタックエントリを参照する方法はない。これは意図的なものであり、コールスタック内の関数が互いの値に影響を与えないようにするためである。

> Cスタックと混同しないように。


### バリュースタックを成長させる

コンテキストの値スタックは、いつでもある最大数のエントリに割り当てられています。割り当てられたサイズを超えて値をプッシュしようとすると、エラーがスローされ、値スタックが自動的に拡張されることはありません。これは、内部実装を単純化し、また、関数中にある数のエントリが必要であることが事前に分かっている場合に、再割り当てを最小限に抑えることでパフォーマンスを向上させるものです。

値スタックが作成されるとき、あるいは Duktape/C 関数が入力されるとき、値スタックは常に呼び出し引数と DUK_API_ENTRY_STACK （現在 64）要素のための空間を持つことが保証されています。一般的なケースでは、これは十分すぎるほどで、Duktape/C関数の大部分は値スタックを拡張する必要がありません。より大きなスペースを必要とする関数、あるいは入力に依存したスペースを必要とする関数だけが、値スタックを拡張する必要があります。

duk_check_stack() または (通常より好ましくは) duk_require_stack() で明示的にスタック割り当てを拡張することができます。いったん拡張に成功すると、指定された数の要素をスタックにプッシュできることが再び保証されます。Duktape/C関数から戻る以外、割り当てを縮小する方法はありません。

例えば、入力された ASCII 文字列を大文字に変換する次のような関数を考えてみましょう。この例では、必要な値スタックのエントリ数が入力に依存することが示されています（そうでなければ、これは文字列を大文字にするためのあまり良い方法とは言えません）。

```c
/* uppercase.c */
#include <stdio.h>
#include <stdlib.h>
#include "duktape.h"

static int dummy_upper_case(duk_context *ctx) {
    size_t sz;
    const char *val = duk_require_lstring(ctx, 0, &sz);
    size_t i;

    /* We're going to need 'sz' additional entries on the stack. */
    duk_require_stack(ctx, sz);

    for (i = 0; i < sz; i++) {
        char ch = val[i];
        if (ch >= 'a' && ch <= 'z') {
            ch = ch - 'a' + 'A';
        }
        duk_push_lstring(ctx, (const char *) &ch, 1);
    }

    duk_concat(ctx, sz);
    return 1;
}

int main(int argc, char *argv[]) {
    duk_context *ctx;

    if (argc < 2) { exit(1); }

    ctx = duk_create_heap_default();
    if (!ctx) { exit(1); }

    duk_push_c_function(ctx, dummy_upper_case, 1);
    duk_push_string(ctx, argv[1]);
    duk_call(ctx, 1);
    printf("%s -> %s\n", argv[1], duk_to_string(ctx, -1));
    duk_pop(ctx);

    duk_destroy_heap(ctx);
    return 0;
}
```


Duktapeは、ユーザー予約要素に加えて、全てのAPIコールがさらなる割り当てなしに動作するのに十分なバリュー・スタック・スペースを確保するために、自動的に内部のバリュー・スタック・リザーブを保持します。また、メモリの再割り当てを最小限に抑えるため、値スタックはある程度大きなステップで拡張・縮小されます。その結果、呼び出し元が指定した余分な値を超えて利用可能な値スタック要素の内部数は、かなり変化します。呼び出し元はこれを考慮する必要はなく、利用可能な追加要素に依存するべきでは決してない。


### ECMAScriptの配列インデックス

ECMAScript のオブジェクトおよび配列のキーは、文字列またはシンボルのみとする。配列のインデックス (例: 0, 1, 2) は、それぞれの数値の標準文字列表現 (例: "0", "1", "2") として表現されます。より技術的には、範囲 [0, 2**32-2] の整数のすべての標準文字列表現が有効な配列インデックスとなります。

ECMAScript の配列インデックスの取り扱いを説明するために、次の例を考えてみましょう。

```javascript
var arr = [ 'foo', 'bar', 'quux' ];

print(arr[1]);     // refers to 'bar'
print(arr["1"]);   // refers to 'bar'

print(arr[1.0]);   // refers to 'bar', canonical encoding is "1"
print(arr["1.0"]); // undefined, not an array index
```


ECMAScript の配列上で動作するいくつかの API 呼び出しは、配列の数値インデックス引数を受け付けます。これは実際には、その数値の文字列変換を示すショートハンドに過ぎません。例えば、APIに整数の123が与えられた場合、これは実際にはプロパティ名 "123 "を指します。

内部的には、Duktapeは可能な限り数値インデックスを実際の文字列に変換することを避けようとします。したがって、関連する場合は配列インデックスAPIコールを使用することが望ましいです。同様に、ECMAScriptのコードを書く場合にも、文字列インデックスではなく、数値を使うことが望ましいです。


### Duktape API

Duktape APIは、duktape.hで定義され、APIリファレンスで文書化されたユーザー呼び出し可能なAPIコールの集合体です。

Duktape APIコールは一般的にエラーに寛容で、全ての引数にエラー（NULLポインタなど）がないかをチェックします。しかし、フットプリントを最小にするため、ctx引数はチェックされず、呼び出し側は NULLコンテキストでDuktape APIコールを呼び出してはいけません(MUST NOT)。

すべてのDuktape APIコールは、潜在的にマクロです。呼び出し側のコードは、Duktape APIコールが関数ポインタとして利用可能であることに 依存してはいけません。あるAPIコールの実装は、互換性のあるリリース間であっても、マクロと実際の関数の間で変更される可能性があります。Duktape APIは、マクロに対して以下の保証を行います。

- 引数は2回以上評価されない(明示的に記述されていない限り)。ただし、現在のバージョンで引数が無視される場合、引数は全く評価されない可能性があります。
- 戻り値のあるAPIコールは、式として使用できる。APIマクロが複数のステートメントを含む場合、カンマ式（例：(foo, bar, quux)）として実装される。
- 戻り値が void の API 呼び出しは、必ずしも式の一部として動作しない場合がある。APIマクロは、ブロック文またはダミーの do {...} while (0) ループとして実装されることがある。


### Duktape/C 関数

Duktape/C APIシグネチャを持つC関数は、ECMAScript関数オブジェクトと関連付けることができ、ECMAScript関数オブジェクトが呼び出されたときに呼び出されます。Duktape/C API関数は、以下のような形をしています。

```c
duk_ret_t my_func(duk_context *ctx) {
    duk_push_int(ctx, 123);
    return 1;
}
```

この関数は、ECMAScript の呼び出し引数を ctx の値スタックで取得し、 duk_get_top() は、値スタック上に存在する引数の数を示します。このバインディングは、自動的に値スタックにプッシュされません; 必要であれば、それにアクセスするために duk_push_this() を使用してください。Duktape/C 関数に関連付けられた ECMAScript 関数オブジェクトを作成する際に、希望する引数の数を選択することができます。余分な引数は削除され、足りない引数は undefined に置き換えられます。関数は、（引数数としてDUK_VARARGSを与えることにより）vararg関数として登録することもでき、この場合、呼び出し引数はC関数入力前に修正されません。

この関数は、以下のいずれかを返すことができる。

- 戻り値 1 は、スタックの一番上の値が戻り値として解釈されることを示す。
- 戻り値 0 は、値スタック上に明示的な戻り値がないことを示し、undefined が呼び出し元に返される。
- 負の戻り値は、自動的にエラーが投げられることを示す。DUK_RET_xxx というエラーコードは、特定の種類のエラーに対応します（正の値である DUK_ERR_xxx と混同しないでください）。これはオプションの省略記法で、フットプリントは小さいですが、いくつかの欠点もあります (例えば、エラーメッセージがないなど)。
- ECMAScript は Edition 5.1 では複数の戻り値をサポートしていないので、1 以上の戻り値は現在未定義です (1 以上の値は、ECMAScript Edition 6 で複数の戻り値をサポートするようになるかもしれません。)。

Duktape/C関数が戻るとき、値スタックは自動的に巻き戻されるので、関数が戻ったときに値スタックを手動でクリーンアップする必要はありません。

負のエラー返り値は、一般的なエラー処理を簡素化することを目的としており、Duktape APIコールで明示的にエラーを構築して投げることの代替となります。Duktapeが自動的にメッセージを作成するため、エラーメッセージを与えることはできません。例えば

```c
duk_ret_t my_func(duk_context *ctx) {
    if (duk_get_top(ctx) == 0) {
        /* throw TypeError if no arguments given */
        return DUK_RET_TYPE_ERROR;
    }
    /* ... */
}
```


すべてのDuktape/C関数は、ECMAScriptの意味においてストリクト（厳密）であるとみなされます。DuktapeのAPIコールは、たとえDuktape/C関数の外部で、つまりコールスタックが空の状態でAPIコールが行われたとしても、常にECMAScriptのstrictモードのセマンティックに従います。例えば、duk_del_prop()を使って設定不可能なプロパティを削除しようとすると、エラーがスローされます。これは、ECMAScriptの厳密な関数でも同様です。

```javascript
function f() {
    'use strict';
    var arr = [1, 2, 3];
    return delete arr.length;  // array 'length' is non-configurable
}

print(f());  // this throws an error because f() is strict
```


Duktape/C関数の厳密性のもう一つの帰結は、Duktape/C関数に与えられたこのバインディングが強制されないということです。これはECMAScriptの厳密なコードにも当てはまります。


```javascript
function strictFunc() { 'use strict'; print(typeof this); }
function nonStrictFunc() { print(typeof this); }

strictFunc.call('foo');     // prints 'string' (uncoerced)
nonStrictFunc.call('foo');  // prints 'object' (coerced)
```


Duktape/Cの関数は、現在のところ常にコンストラクタブルで、つまりnew Foo()式の中で常に使用することが可能です。ある関数がコンストラクタ・モードで呼び出されたかどうかは、以下のようにして確認することができます。


```c
static duk_ret_t my_func(duk_context *ctx) {
    if (duk_is_constructor_call(ctx)) {
        printf("called as a constructor\n");
    } else {
        printf("called as a function\n");
    }
}
```


メモリを節約するために、Duktape/C関数はデフォルトでprototypeプロパティを持たないので、デフォルトのオブジェクト・インスタンス（thisとしてコンストラクタに与えられる）はObject.prototypeを継承しています。カスタム・プロトタイプを使用するには、Duktape/C関数に対して明示的にプロトタイプを定義します。ECMAScript関数と同様に、コンストラクターがオブジェクトの値を返す場合、その値はデフォルトのオブジェクト・インスタンスを置き換え、新しい式の値となります。

> このバインディングは自動的に値スタックにプッシュされないので、アクセスするには duk_push_this() を使ってください。


### Duktape/C関数の状態を格納する

Duktape/C関数にアウトオブバンドで、つまり明示的な呼び出し引数の外で、パラメータや追加の状態を提供したい場合があります。これを実現するには、いくつかの方法があります。

#### 関数のプロパティ

まず、Duktape/C関数はそのFunctionオブジェクトを使用して、状態やパラメータを保存することができます。ある Duktape/C 関数（実際の C 関数）は常に ECMAScript Function オブジェクトで表現され、内部的に基礎となる C 関数と関連付けられています。Functionオブジェクトは、その関数の特定のインスタンスに関連するプロパティを保存するために使用することができます。ある Duktape/C 関数は、複数の独立した Function オブジェクトに関連付けることができ、したがって、独立した状態にすることができることに注意してください。

Duktape/C関数に関連するECMAScript Functionオブジェクトにアクセスするのは簡単です。

```c
duk_push_current_function(ctx);
duk_get_prop_string(ctx, -1, "my_state_variable");
```


#### 'this' バインディング

状態を保存するためのもう一つの方法は、Duktape/C関数をメソッドとして呼び出し、状態を保存するためにthisバインディングを使用することです。例えば、asと呼ばれるDuktape/C関数を考えてみましょう。

```c
foo.my_c_func()
```


Duktape/C関数は呼び出されると、このバインディングとしてfooを取得し、fooに直接ステートを格納することができます。関数オブジェクトのアプローチと異なるのは、すべてのメソッドで同じオブジェクトが共有される点です。

thisバインディングにアクセスするのは簡単です。

```c
duk_push_this(ctx);
duk_get_prop_string(ctx, -1, "my_state_variable");
```


#### 隠しシンボルのプロパティ

データをオブジェクトと関連付ける必要があるが、ECMAScript コードから隠される場合、隠された[シンボル]()をプロパティキーとして使用することができます。このキーは、C API から ECMAScript コードに渡されない限り、C API を介してのみアクセス可能です。一般的な使用例としては、C メモリへのポインタ/データのバッキングを関連付けることです。シンボルは文字列として作成されますが、シンボルとしてマークするマクロで区別されます。

例えば、この上に隠されたシンボルを設定したり、取得したりする。

```c
my_context_data_t *my_context_data = malloc(sizeof(my_context_data_t));
duk_push_this(ctx);
duk_push_pointer(ctx, my_context_data);
duk_put_prop_string(ctx, -2, DUK_HIDDEN_SYMBOL("my_context_data"));
/* ... */
duk_push_this(ctx);
duk_get_prop_string(ctx, -1, DUK_HIDDEN_SYMBOL("my_context_data"));
my_context_data_t *my_context_data = duk_get_pointer(ctx, -1);
```


#### 関数のマジックバリュー

Duktape/C関数オブジェクトは、16ビット符号付き整数の「マジック」値（デフォル トではゼロ）を内部に保存でき、余分なメモリー・コストをかけずに済みます。このマジック値は、Duktape/C関数にフラグや小さな値を最小限のコストで渡すために使用することができ、1つのネイティブ関数が複数の関数オブジェクトに対してわずかに異なる動作を提供することができます。

```c
/* マジックバリューの例：最下位2ビットをプレフィックスインデックスに使用、
 * ビット2(0x04)はログ書き込みヘルパーの改行スタイルを選択するために使用されます。 
 */
const char *prefix[4] = { "INFO", "WARN", "ERROR", "FATAL" };
duk_int_t magic = duk_get_current_magic(ctx);

printf("%s: %s", prefix[magic & 0x03], duk_safe_to_string(ctx, 0));
if (magic & 0x04) {
    printf("\r\n");
} else {
    printf("\n");
}
```

APIの使用例については、テストケースである [test-get-set-magic.c]()を参照してください。Duktapeは、コンパイルされたコードのサイズを最小化するために、内部的に マジック値を多用しています（例えば、[duk_bi_math.c]()を参照してください）。

> マジック・バリューの仕組みは、Duktapeのメジャー・バージョン間で利用可能な予備ビットの数が変化するため、変更される可能性があります。マジック・バリューを使うのは、フットプリントが本当に重要なときだけにしてください。関数オブジェクトに保存されるプロパティは、より安定した代替手段です。


#### ヒープスタッシュ

ヒープ・スタッシュは、Cコードからだけ見えるオブジェクトです。これは Duktape ヒープに関連付けられ、Duktape/C コードが ECMAScript コードに公開されない「アンダー・ザ・フード」状態データを保存することを可能にします。これは [duk_push_heap_stash()]() API 呼び出しでアクセスします。


#### グローバルスタッシュ

グローバルスタッシュはヒープスタッシュと似ていますが、グローバルオブジェクトと関連付けられています。これは [duk_push_global_stash()]() API コールでアクセスできます。同じヒープ内に、異なるグローバル・オブジェクトを持つ複数の環境が存在することがあります。

#### スレッドスタッシュ

スレッド・スタッシュはヒープ・スタッシュと似ていますが、Duktapeスレッド（つまりctxポインタ）に関連付けられます。[duk_push_thread_stash()]() APIコールを使ってアクセスできます。


### Duktapeバージョン固有コード

Duktapeのバージョンは、DUK_VERSION定義によって、 (major * 10000) + (minor * 100) + patchという数値で利用可能です。同じ値は、Duktape.versionを通じてECMAScriptコードで利用可能です。呼び出し側のコードは、Duktapeのバージョンに特化したコードのために、この定義を利用することができます。

Cコードの場合:

```c
#if (DUK_VERSION >= 20403)
/* Duktape 2.4.3 or later */
#elif (DUK_VERSION >= 10500)
/* Duktape 1.5.0 or later */
#else
/* Duktape lower than 1.5.0 */
#endif
```


ECMAScriptコードの場合（[Duktape built-ins]()も参照のこと）：

```javascript
if (typeof Duktape !== 'object') {
    print('not Duktape');
} else if (Duktape.version >= 20403) {
    print('Duktape 2.4.3 or higher');
} else if (Duktape.version >= 10500) {
    print('Duktape 1.5.0 or higher (but lower than 2.4.3)');
} else {
    print('Duktape lower than 1.5.0');
}
```


### 数値エラー・コード

Duktape API でエラーが発生した場合、呼び出し側はそのエラーに数値のエラー・コードを 割り当てなければなりません。エラーコードは正の整数で、現時点では 24 ビットの範囲に制限されています。組み込みのエラーコードは duktape.h で定義されており、例えば DUK_ERR_TYPE_ERROR がある。

残りの上位ビットは、例えば追加のフラグを運ぶために内部的に使用される。負のエラー値は、Duktape/C APIにおいて、自動的にエラーを投げるための省略記法として使用されます。


### エラー・ハンドリング

Duktape APIにおけるエラー処理は、ECMAScriptがエラーを処理する方法と似ています：エラーは明示的または暗黙的にスローされ、その後キャッチされ処理されます。エラーは明示的または暗黙的にスローされ、その後キャッチされ処理されます。Cコードはtry-catch文の代わりにprotected Duktape APIコールを使って、Cコード内でエラーをキャッチし処理できるポイントを確立します。保護された呼び出しを除く全てのDuktape APIコールは、エラーを投げる可能性があります。ほとんどのECMAScript操作は、状況によってはエラースローを引き起こす可能性があり、メモリ不足エラーはほとんど全ての状況で発生する可能性があります。throw サイトと catch サイト間の長い制御転送は、 setjmp()/longjmp() (またはそのプラットフォーム固有のバージョン)、または C++ 例外スロー (DUK_USE_CPP_EXCEPTIONS が有効な場合) に基づいています、長い制御転送をご覧ください。

捕捉されないエラーは致命的なエラー・ハンドラを呼び出すことになり、これは回復不可能な状況とみなされるため、通常は避けるべきです。「通常のエラーと致命的なエラー」「致命的なエラーの処理方法」を参照してください。致命的なエラーを回避するために、一般的なアプリケーション・コードでは、他のDuktape APIを呼び出す前に、エラー・キャッチ・サイトを確立する必要があります。これは、例えば保護されたDuktape APIコールを使って行われます。

- コードの評価 (duk_peval())、コードのコンパイル (duk_pcompile())、関数の呼び出し (duk_pcall()) には protected コールを使用する。
- 単一の duk_safe_call() を使用してエラー・キャッチャーを確立し、安全でないプリミティブを安全な呼び出しの中で自由に使用できるようにする。


1つ目の手法の一例:

```javascript
/* スクリプトのエラーが安全に扱えるようファイルを評価するために
 * duk_peval() variant を使用します。 構文エラーと実行時エラーの両方が捕捉されます。*/

push_file_as_string(ctx, "myscript.js");
if (duk_peval(ctx) != 0) {
    /* duk_safe_to_string() を使用してエラーを文字列に変換する。 
     * この API コールは、強制変換の際にエラーを投げないことが保証されています。
     */
    printf("Script error: %s\n", duk_safe_to_string(ctx, -1));
}
duk_pop(ctx);
```

2つ目の手法の一例:

```javascript
/* Use duk_safe_call() to wrap all unsafe code into a separate C function.
 * This approach has the advantage of covering all API calls automatically
 * but is a bit more verbose.
 */

static duk_ret_t unsafe_code(duk_context *ctx, void *udata) {
    /* Here we can use unprotected calls freely. */

    (void) udata;  /* 'udata' may be used to pass e.g. a struct pointer */

    push_file_as_string(ctx, "myscript.js");
    duk_eval(ctx);

    /* ... */

    return 0;  /* success return, no return value */
}

/* elsewhere: */

if (duk_safe_call(ctx, unsafe_code, NULL /*udata*/, 0 /*nargs*/, 1 /*nrets */) != 0) {
    /* The 'nrets' argument should be at least 1 so that an error value
     * is left on the stack if an error occurs.  To avoid further errors,
     * use duk_safe_to_string() for safe error printing.
     */
    printf("Unexpected error: %s\n", duk_safe_to_string(ctx, -1));
}
duk_pop(ctx);
```

プロテクトされたコール内でも、内部エラーのように致命的なエラーを引き起こすか、プロテクトされたAPIコールから外部にエラーを伝播させるような稀なケースがあります。これらは異常時にのみ発生し、回復可能とはみなされません。これらのケースをうまく処理するために、生産品質のアプリケーションは常に致命的なエラーを処理するための合理的な戦略を持つ致命的なエラーハンドラを持つべきです。そのような戦略は、必然的にアプリケーションに依存しますが、次のようなものになるでしょう。

- 組み込みデバイスでは、致命的なエラーハンドラは致命的なエラー情報をフラッシュファイルに書き込んで、デバイスをリブートすることができます。リブート後、致命的なエラーを診断サーバーに報告し、調査できるようにする。
- UNIX システムでは、致命的エラーハンドラは単にプロセスを終了させ (デフォルトの致命的ハンドラは abort() を使用します)、 ラッパースクリプトにアプリケーションを再開させることができます。

アプリケーションによっては、エラー・キャッチャーなしでAPIコールを行い、 致命的なエラーにつながるキャッチできないエラーを投げる危険性があることは、 問題にならないかもしれないことに注意してください。致命的なエラーが発生した後、実行を継続することは安全ではないので、そのようなアプリケーションは、致命的なエラーが発生した場合、通常、単に終了します。実際の回復戦略がなくても、致命的なエラーハンドラを使用して、例えば、プロセス終了前に stderr に致命的なエラー情報を書き込むべきです。


### 正常なエラーと致命的なエラー

