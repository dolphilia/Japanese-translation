# Duktapeプログラマーズ・ガイド


## はじめに

Version: 2.6.0 (2020-10-13)


### ドキュメントの範囲

このガイドでは、あなたのプログラムでDuktapeを使用するための入門書を提供します。基本的な使い方に慣れてきたら、APIの詳細を調べるための簡潔なAPIリファレンスがあります。Duktape Wikiでは、より詳細な例やベストプラクティスを提供しています。

この文書では、Duktapeの内部構造はカバーしていません。内部構造をいじりたい場合は、Duktapeのリポジトリを参照してください。


### Duktapeとは？

Duktapeは、移植性とコンパクトなフットプリントを重視した、組み込み可能なECMAScript®エンジンです。DuktapeをC/C++プログラムに組み込むことで、スクリプトによる機能拡張を簡単に行うことができます。また、プログラムの主要な制御フローをECMAScriptで構築し、重い処理を行うために高速なCコード関数を使用することも可能です。

Duktapeを組み込むアプリケーションは、どのネイティブ・バインディングをどのような方法で提供するかを制御することができます。例えば、コンソールへのテキスト出力やファイル・システムとのやり取りに関するデフォルトのバインディングは存在しません。Duktapeの配布パッケージにはサンプル・プロバイダーが含まれており、ニーズに合わせて簡単に統合することができます。

ECMAScriptとJavascriptという用語は、しばしば多かれ少なかれ同等だと考えられていますが、Javascriptとその亜種は技術的にはECMAScript言語が使用される環境の一つに過ぎません。ブラウザ以外の ECMAScript 環境でも、ブラウザ固有のビルトインが提供されていることがよくあるので、両者の境界は実際にはあまり明確ではありません。それでも、Duktapeが実装している言語を指すために、ここではECMAScriptという用語を使用します。


## 準拠

DuktapeはES5.0/ES5.1に準拠し、必要に応じてES2015以降からセマンティクスを更新しています。

- ECMAScript言語仕様書第5版
- ECMAScript®言語仕様5.1版

Duktapeは、セマンティクスとビルトインに関する最新のECMAScript仕様を追跡しています（ただし、ES2015以降のサポートはまだ不完全です）、ご参照ください。

- ECMAScript® 2015言語仕様
- ECMAScript® 2016言語仕様

特定のケースでは、Duktapeは仕様のドラフトに従うことがあります（TC39/ecma262で進行中の作業を参照）。これは、最新仕様の機能が現実のコードと衝突する場合に行われます（例えば、RegExp.prototypeの問題を参照）。

TypedArrayのサポートはES2016 TypedArrayに基づいています。初期の実装はKhronos TypedArrayの仕様に基づいていました。

- TypedArray Specification (Editor's Draft 18 July 2013) (注: リンクは最新版です)
- svn co -r 30720 https://cvs.khronos.org/svn/repos/registry/trunk/public/typedarray

Node.jsのBufferサポートは、以下のものをベースにしています。

- Buffer Node.js v6.9.1。

TextEncoder()とTextDecoder()のバインディングは、以下を参考にしています。

- Encoding API, WHATWG Encoding Living Standard

Performance.now()バインディングは、以下をベースにしています。

- High Resolution Time Level 2


## 機能紹介

Duktapeは、ECMAScriptの標準的な機能の他に、以下の追加機能を備えています（一部はアプリケーションから見えるもの、その他は内部的なものです）。

- ES2015 TypedArrayおよびNode.js Bufferバインディング、プレーンなバッファタイプ(軽量なUint8Array)
- ECMAScript 2015 (ES6) から: setPrototypeOf/\_\_proto\_\_, Proxyオブジェクトのサブセット, Reflect, 計算されたプロパティ名, 最小限のconstサポート
- ECMAScript 2016 (ES7) から: 指数演算子 (\*\*, \*\*=)
- WHATWG Encoding Living Standardに基づくエンコーディングAPIバインディング
- Duktape固有のビルトイン：Duktapeグローバル・オブジェクトによって提供されます。
- 拡張型：カスタムの「バッファ」と「ポインタ」型、任意のバイナリ文字列と非BMP文字列をサポートする拡張文字列型（標準ECMAScriptは16ビットコードポイントしかサポートしていません）。
- 参照カウントとマーク＆スイープガベージコレクションの組み合わせ、ファイナライザーと緊急ガベージコレクション（マーク＆スイープだけで構築することも可能です）
- コルーチンのサポート
- テールコールのサポート
- デバッガプロトコルに基づく内蔵デバッガフレームワーク
- プラットフォーム依存のない組み込みの正規表現エンジン
- プラットフォームに依存しない組込みの Unicode サポート
- プラットフォームに依存しない組込みの数値解析と書式設定
- バイナリシリアライゼーション用の組込みCBORバインディング
- 追加のカスタムJSONフォーマット（JXとJC）
- コンパイル済み関数をキャッシュするためのバイトコードダンプ/ロード機構


## 目標

__コンプライアンス。__ ECMAScript E5/E5.1 と実世界でのコンプライアンス。ECMAScriptのコンプライアンスには、正規表現とUnicodeのサポートが必要です。可能であれば、最新またはドラフトECMAScript仕様から機能を実装し、Duktapeカスタム機能を最小化する。

__移植性。__ Duktapeは、システム・ライブラリへの依存を最小限に抑えることで、移植性を高めています。例えば、数値のフォーマットやパース、正規表現、Unicodeは、すべてDuktapeが内部で実装しています。完全に排除できない数少ない依存性の1つが、Date組み込みによるシステムの日付／時刻の統合です。Duktapeは主要なプラットフォームを直接サポートしていますが、エキゾチックなプラットフォームでは、外部のDateプロバイダーを使用することも可能です。

__簡単なC言語インターフェース。__ DuktapeとC言語プログラムとの間のインターフェースは、自然でエラーに強いものであるべきです。特に、文字列の表現がUTF-8であり、C言語の一般的な使用法に適合するように、自動的にNULターミネータが付加される必要があります。

__フットプリントが小さいこと。__ 小さなプログラムであっても、コードとデータのフットプリントは可能な限り小さくすべきです。Duktapeは、標準ライブラリのない「ベアメタル」ターゲットにも移植可能です。これは性能よりも重要なことです。なぜなら、非常に高速なエンジンはすでにいくつかありますが、非常にコンパクトでポータブルなエンジンは少ないからです。

__適度な性能。__ フットプリントが小さい（そしてある程度ポータビリティがある）ため、おそらく競争力のあるJITベースのエンジンの可能性はなく、SpiderMonkey（およびその最適化バージョン）やGoogle V8などの非常に高度なJITベースのエンジンと競争する現実的な方法はありません。それでも、典型的な組み込みプログラムでは、性能は妥当なものであるはずです。この点では、Luaが良いベンチマークになります。(オプションで、JIT化やオフラインコンパイルのサポートを追加するのも良いでしょう)。

__ASCII文字列の性能。__ プレーンなASCII文字列を扱う操作が非常に高速であることは重要です。ASCIIはほとんどの組み込み用途で支配的です。ASCII以外の文字列を扱う操作は、それなりに高速である必要がありますが、重要ではありません。これは必要なトレードオフです。C互換文字列を使うということは、本質的にUTF-8文字列表現を使うということであり、文字列インデックスや他の多くの操作が、固定サイズの文字表現を使う場合よりも遅くなるのです。それでも、文字列を順次（どちらかの方向に）効率的に反復するような一般的なイディオムをサポートすることは重要です。


## ドキュメントの構成

本書では、Duktapeのダウンロードからコンパイル、そしてプログラムへの組み込みまでを説明します。また、スクリプト機能をどのようにプログラムに組み込むか、具体的な例を示しています。

プログラミングモデル、スタック型。C型では、ヒープ、コンテキスト、バリュースタック、Duktape API、Duktape/C関数など、Duktapeの中核となる概念について説明します。Duktapeのスタック型とC言語の型ラッパーについても詳しく説明しています。

Duktape特有のECMAScriptの機能については、複数のセクションで説明しています。型アルゴリズム（カスタム型用）、Duktape組み込み機能（追加の組み込み機能）、Post-ES5機能（ES2016以降に実装された機能）、カスタム動作（標準とは異なる動作）、カスタムJSON形式、カスタムディレクティブ、バッファオブジェクト、エラーオブジェクト（プロパティとトレースバックサポート）、関数オブジェクト（プロパティ）、日付と時刻、乱数、デバッグ、モジュール、最終化、コルーチン、仮想プロパティ、記号、バイトコードダンプ/読み込み、スレッド化、サンドボックス化。

パフォーマンス」では、パフォーマンスを向上させ、パフォーマンスの落とし穴を回避するためのDuktape固有のヒントをいくつか提供しています。Memory usage（メモリー使用法） Duktapeのメモリー使用法を要約し、使用量を最小限に抑えるためのポインターを提供します。コンパイル アプリケーションの一部としてDuktapeを構成し、コンパイルする方法について説明しています。移植性 プラットフォームやコンパイラーに特有の問題や、その他の移植性に関する問題を扱います。互換性 DuktapeのECMAScript方言、拡張機能、フレームワークとの互換性について説明します。バージョン管理 Duktapeのバージョン管理について、またどのようなバージョン互換性が期待されるかについて説明します。制限事項 現在知られている制限事項を要約し、可能な回避策を提供します。

Luaとの比較では、LuaとDuktapeの違いについて説明します。すでにLuaに慣れている方には、有益な情報かもしれません。


## はじめに


### ダウンロード

Download ページからソース配布物をダウンロードします。


### テスト用コマンドラインツール

配布物を解凍します。

```sh
$ cd /tmp
$ tar xvfJ duktape-<version>.tar.xz
```


提供されたMakefileを使用して、コマンドラインツールをコンパイルしてください。

```sh
$ cd /tmp/duktape-<version>/
$ make -f Makefile.cmdline
```


Makefileはgccがインストールされていることを前提にしています。そうでない場合は、Makefileをあなたのコンパイラに合わせて編集すればよいのです（Makefileは非常にシンプルです）。

> Duktapeは移植性の問題を避けるため、ファイルやコンソールのI/Oに対する組み込みのバインディングを提供していません（例えば、I/O APIが全くないプラットフォームもあります）。コマンドライン・ユーティリティは、extras/print-alert を使って print() と alert() のバインディングを提供し、簡単に遊べるようにしています。配布物には、以下のような便利な(オプションの)バインディングを提供する「extras」があります。
>
> - print() や alert()
> - コンソールオブジェクト、例：console.log()
> 
> __このガイドの例では、説明のために print() バインディングを想定しています。__

> コマンドラインツールは、デフォルトでプラットフォーム依存を回避しています。Makefile を編集することで、linenoise による行編集のサポートを追加することができます。
> - DDUK_CMDLINE_FANCY を追加する。
> - linenoise.hのヘッダに-Ipath/to/linenoiseを追加する。
> - ソースリストに path/to/linenoise.c を追加する。
> - LinenoiseはPOSIX環境でのみ動作し、Cコンパイラが必要です(C++ではありません)


ECMAScriptのコードをインタラクティブに実行できるようになりました。

```sh
$ ./duk
((o) Duktape 2.6.0 (v2.6.0)
duk> print('Hello world!')
Hello world!
= undefined
```


また、ECMAScriptのコードをファイルから実行することができるので、機能やアルゴリズムで遊ぶのに便利です。例として、fib.js を作成します。

```javascript
// fib.js
function fib(n) {
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    return fib(n-1) + fib(n-2);
}

function test() {
    var res = [];
    for (i = 0; i < 20; i++) {
        res.push(fib(i));
    }
    print(res.join(' '));
}

test();
```


コマンドラインからスクリプトをテストします。

```sh
$ ./duk fib.js
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
```


### Duktapeをプログラムに組み込む

コマンドラインツールは、Duktapeを組み込んだプログラムの一例です。Duktapeをあなたのプログラムに組み込むのは非常に簡単です。

- duktape-N.N.N/tools/configure.pyを実行して、ビルドのためにDuktapeを設定する。その結果、duktape.c, duktape.h, duk_config.h を含むディレクトリができます。
- duktape.c, duktape.h, duk_config.hをビルドに追加し、プログラムの他の場所からDuktape APIを呼び出してください。

Duktapeの配布物（duktape-N.N.N.tar.xz）のsrc/ディレクトリには、Duktapeのデフォルト設定のための事前設定済みのヘッダーファイルとソースファイルが含まれており、通常はそのまま使用することができます。必要であれば、設定ツールを使って、Duktapeを低メモリ・ターゲット用に最適化したり、機能を有効化／無効化したりといったDuktapeのオプションをカスタマイズすることができます。詳細と例については、Compiling and Configuring Duktape for build（ビルドのためのDuktapeのコンパイルと設定）を参照してください。

配布物には、このプロセスを説明する非常に簡単なサンプル・プログラム hello.c が含まれています。あらかじめ設定されたDuktapeのヘッダーとテストプログラムは、Duktapeコンテキストを作成し、それを使っていくつかのECMAScriptコードを実行します。
ソース・ファイルを使って、テスト・プログラムを例えば以下のようにコンパイルします。

```sh
$ cd /tmp/duktape-<version>/
$ gcc -std=c99 -o hello -Isrc src/duktape.c examples/hello/hello.c -lm
```


Duktapeの設定をカスタマイズするには、configure.pyを使います。

```sh
$ cd /tmp/duktape-<version>/
# Here we disable ECMAScript 6 Proxy object support
$ python2 tools/configure.py --output-directory duktape-src -UDUK_USE_ES6_PROXY
$ gcc -std=c99 -o hello -Iduktape-src duktape-src/duktape.c examples/hello/hello.c -lm
```


テストプログラムは、Duktapeコンテキストを作成し、それを使っていくつかのECMAScriptコードを実行します。

```sh
$ ./hello
Hello world!
2+3=5
```


Duktapeはエンベデッドエンジンなので、プログラムの基本的な制御フローを変更する必要はありません。基本的なやり方は

- プログラムの初期化時などに、Duktapeコンテキストを作成します（スクリプトが必要な場合は、オンデマンドでも構いません）。通常、初期化時にスクリプトをロードしますが、これはオンデマンドで行うこともできます。
- コードの中でスクリプトを使用したい箇所を特定し、そこにスクリプト関数の呼び出しを挿入します。
- スクリプト関数の呼び出しを行うには、まずDuktape APIを使って呼び出しの引数をDuktapeコンテキストのバリュー・スタックにプッシュします。その後、別のDuktape APIコールを使って実際の呼び出しを開始します。
- スクリプトの実行が終了すると、制御がプログラムに戻り（APIコールが戻り）、Duktapeコンテキストのバリュー・スタックに戻り値が残されています。C言語コードは、Duktape APIを使ってこの戻り値にアクセスすることができます。

より広い意味で、Duktapeをネイティブ・コードで使用する方法には、いくつかのアプローチがあります。

- メイン・アプリケーションはC/C++コードで実行し、基本機能の拡張のためにDuktapeを呼び出す（例：プラグインやコンフィギュレーションなど）。
- メイン・アプリケーションはECMAScriptコードで実行し、I/Oやパフォーマンス重視の操作などでは、シンプルなC/C++ネイティブ・バインディングを呼び出す。ネイティブバインディングはしばしばステートレスに保たれ、ステートロジックがスクリプトコードから見えないようにします。
- ECMAScript コードでメインアプリケーションを実行し、パフォーマンス重視の操作にはより複雑でステートフルな C/C++ ネイティブバインディングを使用します。例えば、グラフィックエンジンはネイティブオブジェクトとして実装することができます。

詳しい例は、以下のWiki記事を参照してください。

- はじめに: ラインプロセッシング
- はじめに: プライマリティテスト


## プログラミングモデル


### 概要

Duktapeを使ったプログラミングは非常に簡単です。

- Duktapeのソース (duktape.c) とヘッダ (duktape.h と duk_config.h) をビルドに追加してください。もし、デフォルトの設定が適切でなければ、 python2 tools/configure.py を使って、カスタム設定用の Duktape ソースとヘッダを準備します。
- Duktapeヒープ（ガベージコレクション領域）と初期コンテキスト（基本的にスレッドハンドル）をプログラム内に作成します。
- 必要なECMAScriptスクリプト・ファイルをロードし、Duktape/C関数を登録します。Duktape/C関数は、ECMAScriptコードから呼び出すことができるC関数で、性能向上やネイティブ・ライブラリへのバインディングなどのために利用できます。
- ECMAScriptの関数を呼び出すには、適宜、Duktape APIを使用してください。Duktape APIは、関数との間で値を受け渡しするために使用されます。値は、C言語の表現とDuktape内部（ECMAScript互換）の表現との間で変換されます。
- Duktape APIは、（ECMAScriptから呼び出された）Duktape/C関数が呼び出しの引数にアクセスしたり、戻り値を提供したりする際にも使用されます。

それでは、すべてのステップとそれに関連する概念をより詳しく見ていきましょう。


### ヒープとコンテキスト

Duktapeのヒープとは、ガベージコレクションのための1つの領域です。ヒープは、文字列やECMAScriptオブジェクト、その他の可変サイズのガベージコレクション・データのためのストレージを割り当てるために使用されます。ヒープ内のオブジェクトは、参照カウント、マーク＆スイープ・ガベージコレクション、オブジェクトのファイナライゼーションなどに必要な情報を提供する内部ヒープ・ヘッダを備えています。ヒープオブジェクトは互いに参照し合うことができ、ガベージコレクションの観点から到達可能性グラフが作成される。例えば、ECMAScript オブジェクトのプロパティは、そのオブジェクトのプロパティセットのキーと値の両方を参照します。複数のヒープを持つことができますが、異なるヒープにあるオブジェクトはお互いを直接参照することができません。ヒープ間で値を渡すにはシリアライズを使用する必要があります。

DuktapeコンテキストはECMAScriptの「実行スレッド」であり、特定のDuktapeヒープに住んでいるものです。Duktape APIでは、コンテキストは duk_context * で表され、Duktape内部のコルーチン（協調スレッドの一種）に関連付けられます。各コンテキストはグローバル・オブジェクトからなる環境とも関連付けられています。コンテキストは同じグローバル環境を共有することもできますが、異なる環境を持つこともできます。コンテキスト・ハンドルはほぼ全てのDuktape APIコールに与えられており、呼び出し側はDuktapeコルーチンの値スタックと対話することができます：値の挿入や問い合わせ、関数の呼び出しなど。

各コルーチンは、実行を制御するコールスタックを持ち、ECMAScript エンジン内のネイティブまたは ECMAScript の関数呼び出しを追跡します。各コルーチンはまた、コルーチンのアクティブなコールスタックのすべての ECMAScript 値を格納する値スタックを持っています。値スタックは常に最新の関数呼び出しのアクティブ・スタック・フレームを持ちます（関数呼び出しが行われていない場合、アクティブ・スタック・フレームはそのまま値スタックとなります）。Duktape APIの呼び出しは、ほとんど現在アクティブなスタック・フレームだけで動作します。また、try-catch-finallyなどを使ってエラー・キャッチのサイトを確立するための内部ブックキーピングもあります。

複数のコンテキストが同じDuktapeヒープを共有することができます。より具体的に言うと、これは複数のコンテキストが同じガベージコレクションの状態を共有でき、安全にオブジェクト参照を交換できることを意味します。異なるヒープにあるコンテキストは、直接オブジェクト参照を交換することはできません。すべての値は、何らかの方法でシリアライズされなければなりません。

Duktape APIが提供するほぼすべてのAPIコールは、その最初の引数としてコンテキスト・ポインタを取ります。グローバル変数や状態は使用されず、複数の独立したDuktapeヒープとコンテキストを同時に実行することに何の制限もありません。ただし、マルチスレッドに関する制限はあります。1つのヒープ内で任意のコードを実行できるネイティブ・スレッドは1つだけです。

Duktapeヒープとヒープ内の初期コンテキストを作成するには、単純に次のようにします。

```c
duk_context *ctx = duk_create_heap_default();
if (!ctx) { exit(1); }
```


独自のメモリ割り当て関数や致命的なエラーハンドラ関数を用意する場合（推奨）は

```c
duk_context *ctx = duk_create_heap(my_alloc,
                                   my_realloc,
                                   my_free,
                                   my_udata,
                                   my_fatal);
if (!ctx) { exit(1); }
```


同じヒープ内に新しいコンテキストを作成し、そのコンテキストが同じグローバルオブジェクトを共有するようにします。

```c
duk_context *new_ctx;

(void) duk_push_thread(ctx);
new_ctx = duk_get_context(ctx, -1 /*index*/);
```


同じヒープ内に新しいコンテキストを作成するが、グローバルオブジェクトのセットは新しいものにする。

```c
duk_context *new_ctx;

(void) duk_push_thread_new_globalenv(ctx);
new_ctx = duk_get_context(ctx, -1 /*index*/);
```


コンテキストは到達不可能になった時点で自動的にガベージコレクションされます。これはまた、もしあなたのCコードがduk_context *を保持しているなら、対応するDuktapeコルーチンはガベージコレクションの観点から到達可能でなければならない（MUST）ことを意味します。

ヒープは、呼び出し元がそれを使い終わったときに明示的に破棄されなければなりません。

```c
duk_destroy_heap(ctx);
```

これにより、割り当てられたすべてのヒープオブジェクトが解放され、そのようなオブジェクトへのポインタがすべて無効になる。特に、呼び出し元のプログラムが、ヒープに関連付けられたコンテキストの値スタックに存在する値への文字列ポインタを保持していた場合、そのポインタは無効になり、ヒープ破棄呼び出しが戻った後は決して再参照してはならない。


### コールスタック（コンテキスト）

コンテキストのコールスタックは、呼び出し元からは直接見えません。これは、あるコンテキストで現在実行されている C または ECMAScript の関数呼び出しの連鎖を記録しています。この簿記の主な目的は、関数の呼び出し元と呼び出し先の間で引数と結果の受け渡しを容易にし、関数呼び出しの間で値スタックがどのように分割されたかを追跡することです。また、コールスタックによって、Duktapeはエラー時のトレースバックを構築することができます。

Duktapeはテールコールをサポートしているため、コールスタックは必ずしも真のコールチェインを正確に表しているとは限りません。

> Cスタックと混同しないように。


### (コンテキストの)値スタックと値スタックインデックス

コンテキストの値スタックは、コルーチンの現在の実行状態に関連するタグ付き型の値の配列である。使用されるタグ付き型は、undefined, null, boolean, number, string, object, buffer, pointer, and lightfunc です。利用可能なタグ付き型の詳細については、「型」を参照してください。

値スタックは、コルーチンのコールスタック上の現在アクティブな関数呼び出し（アクティベーション）間で分割されます。いつでも、スタック上の要素をインデックスするための原点を提供するアクティブなスタックフレ ームがあります。より具体的には、Duktape APIではインデックス・ゼロで参照されるボトム（底）が常に存在します。また、現在使用されている最も高い要素のすぐ上にあるスタック要素を特定する概念的なトップがあります。以下の図がこれを示しています。

```
 Value stack
 of 15 entries
 (absolute indices)

.----.
| 15 |
| 14 |
| 13 |
| 12 |      Active stack frame (indices
| 11 |      relative to stack bottom)
| 10 |
|  9 |      .---.   Stack top is 6 (relative to stack bottom).
|  8 | <--- | 5 |   API index 5 is highest used (at value stack index 8).
|  7 |      | 4 |
|  6 |      | 3 |
|  5 |      | 2 |
|  4 |      | 1 |
|  3 | <--- | 0 |   API index 0 is bottom (at value stack index 3).
|  2 |      `---'
|  1 |
|  0 |
`----'
```

内部値スタックの要素を参照する直接的な方法はありません。Duktape APIは、常に現在アクティブなスタック・フレームを扱います。Duktape APIは、常に現在アクティブなスタック・フレームを扱うため、文書全体を通してスタック・フレームは水平に表示されます。例えば、上図のアクティブなスタック・フレームは、次のように表示されます。

```
| 0 | 1 | 2 | 3 | 4 | 5 |
```


スタック・インデックスは、Duktape APIで使用される符号付き整数のインデックスで、現在のアクティブなスタック・フレームの要素を、現在のフレームの底から相対的に参照するために使用されます。

負ではない（>= 0）のインデックスは、フレームの底を基準として、現在のスタック・フレーム内のスタック・エントリーを参照します。

```
| 0 | 1 | 2 | 3 | 4 | <5> |
```


負の（< 0）インデックスは、スタックの先頭からの相対的なエントリーを指します。

```
| -6 | -5 | -4 | -3 | -2 | <-1> |
```


特殊定数 DUK_INVALID_INDEX は、無効なスタックインデックスを示す負の整数である。これは API 呼び出しから返され、また API 呼び出しに与えて "値がない" ことを示すことができます。

スタックトップ(または単に "トップ")は、最も使用されているインデックスのすぐ上の仮想要素の非負のインデックスである。例えば、最も使用されているインデックスの上は 5 であるので、スタックトップは 6 である。 トップは現在のスタックサイズを示し、またスタックにプッシュされる次の要素のインデックスである。

```
| 0 | 1 | 2 | 3| 4 | <5> | (6) |
```

> API のスタック操作は、常に現在のスタックフレームに限定される。現在のフレームより下のスタックエントリを参照する方法はない。これは意図的なものであり、コールスタック内の関数が互いの値に影響を与えないようにするためである。

> Cスタックと混同しないように。


### バリュースタックを成長させる

コンテキストの値スタックは、いつでもある最大数のエントリに割り当てられています。割り当てられたサイズを超えて値をプッシュしようとすると、エラーがスローされ、値スタックが自動的に拡張されることはありません。これは、内部実装を単純化し、また、関数中にある数のエントリが必要であることが事前に分かっている場合に、再割り当てを最小限に抑えることでパフォーマンスを向上させるものです。

値スタックが作成されるとき、あるいは Duktape/C 関数が入力されるとき、値スタックは常に呼び出し引数と DUK_API_ENTRY_STACK （現在 64）要素のための空間を持つことが保証されています。一般的なケースでは、これは十分すぎるほどで、Duktape/C関数の大部分は値スタックを拡張する必要がありません。より大きなスペースを必要とする関数、あるいは入力に依存したスペースを必要とする関数だけが、値スタックを拡張する必要があります。

duk_check_stack() または (通常より好ましくは) duk_require_stack() で明示的にスタック割り当てを拡張することができます。いったん拡張に成功すると、指定された数の要素をスタックにプッシュできることが再び保証されます。Duktape/C関数から戻る以外、割り当てを縮小する方法はありません。

例えば、入力された ASCII 文字列を大文字に変換する次のような関数を考えてみましょう。この例では、必要な値スタックのエントリ数が入力に依存することが示されています（そうでなければ、これは文字列を大文字にするためのあまり良い方法とは言えません）。

```c
/* uppercase.c */
#include <stdio.h>
#include <stdlib.h>
#include "duktape.h"

static int dummy_upper_case(duk_context *ctx) {
    size_t sz;
    const char *val = duk_require_lstring(ctx, 0, &sz);
    size_t i;

    /* スタックに 'sz' 個の追加エントリが必要です。 */
    duk_require_stack(ctx, sz);

    for (i = 0; i < sz; i++) {
        char ch = val[i];
        if (ch >= 'a' && ch <= 'z') {
            ch = ch - 'a' + 'A';
        }
        duk_push_lstring(ctx, (const char *) &ch, 1);
    }

    duk_concat(ctx, sz);
    return 1;
}

int main(int argc, char *argv[]) {
    duk_context *ctx;

    if (argc < 2) { exit(1); }

    ctx = duk_create_heap_default();
    if (!ctx) { exit(1); }

    duk_push_c_function(ctx, dummy_upper_case, 1);
    duk_push_string(ctx, argv[1]);
    duk_call(ctx, 1);
    printf("%s -> %s\n", argv[1], duk_to_string(ctx, -1));
    duk_pop(ctx);

    duk_destroy_heap(ctx);
    return 0;
}
```


Duktapeは、ユーザー予約要素に加えて、全てのAPIコールがさらなる割り当てなしに動作するのに十分なバリュー・スタック・スペースを確保するために、自動的に内部のバリュー・スタック・リザーブを保持します。また、メモリの再割り当てを最小限に抑えるため、値スタックはある程度大きなステップで拡張・縮小されます。その結果、呼び出し元が指定した余分な値を超えて利用可能な値スタック要素の内部数は、かなり変化します。呼び出し元はこれを考慮する必要はなく、利用可能な追加要素に依存するべきでは決してない。


### ECMAScriptの配列インデックス

ECMAScript のオブジェクトおよび配列のキーは、文字列またはシンボルのみとする。配列のインデックス (例: 0, 1, 2) は、それぞれの数値の標準文字列表現 (例: "0", "1", "2") として表現されます。より技術的には、範囲 [0, 2**32-2] の整数のすべての標準文字列表現が有効な配列インデックスとなります。

ECMAScript の配列インデックスの取り扱いを説明するために、次の例を考えてみましょう。

```javascript
var arr = [ 'foo', 'bar', 'quux' ];

print(arr[1]);     // refers to 'bar'
print(arr["1"]);   // refers to 'bar'

print(arr[1.0]);   // refers to 'bar', canonical encoding is "1"
print(arr["1.0"]); // undefined, not an array index
```


ECMAScript の配列上で動作するいくつかの API 呼び出しは、配列の数値インデックス引数を受け付けます。これは実際には、その数値の文字列変換を示すショートハンドに過ぎません。例えば、APIに整数の123が与えられた場合、これは実際にはプロパティ名 "123 "を指します。

内部的には、Duktapeは可能な限り数値インデックスを実際の文字列に変換することを避けようとします。したがって、関連する場合は配列インデックスAPIコールを使用することが望ましいです。同様に、ECMAScriptのコードを書く場合にも、文字列インデックスではなく、数値を使うことが望ましいです。


### Duktape API

Duktape APIは、duktape.hで定義され、APIリファレンスで文書化されたユーザー呼び出し可能なAPIコールの集合体です。

Duktape APIコールは一般的にエラーに寛容で、全ての引数にエラー（NULLポインタなど）がないかをチェックします。しかし、フットプリントを最小にするため、ctx引数はチェックされず、呼び出し側は NULLコンテキストでDuktape APIコールを呼び出してはいけません(MUST NOT)。

すべてのDuktape APIコールは、潜在的にマクロです。呼び出し側のコードは、Duktape APIコールが関数ポインタとして利用可能であることに 依存してはいけません。あるAPIコールの実装は、互換性のあるリリース間であっても、マクロと実際の関数の間で変更される可能性があります。Duktape APIは、マクロに対して以下の保証を行います。

- 引数は2回以上評価されない(明示的に記述されていない限り)。ただし、現在のバージョンで引数が無視される場合、引数は全く評価されない可能性があります。
- 戻り値のあるAPIコールは、式として使用できる。APIマクロが複数のステートメントを含む場合、カンマ式（例：(foo, bar, quux)）として実装される。
- 戻り値が void の API 呼び出しは、必ずしも式の一部として動作しない場合がある。APIマクロは、ブロック文またはダミーの do {...} while (0) ループとして実装されることがある。


### Duktape/C 関数

Duktape/C APIシグネチャを持つC関数は、ECMAScript関数オブジェクトと関連付けることができ、ECMAScript関数オブジェクトが呼び出されたときに呼び出されます。Duktape/C API関数は、以下のような形をしています。

```c
duk_ret_t my_func(duk_context *ctx) {
    duk_push_int(ctx, 123);
    return 1;
}
```

この関数は、ECMAScript の呼び出し引数を ctx の値スタックで取得し、 duk_get_top() は、値スタック上に存在する引数の数を示します。このバインディングは、自動的に値スタックにプッシュされません; 必要であれば、それにアクセスするために duk_push_this() を使用してください。Duktape/C 関数に関連付けられた ECMAScript 関数オブジェクトを作成する際に、希望する引数の数を選択することができます。余分な引数は削除され、足りない引数は undefined に置き換えられます。関数は、（引数数としてDUK_VARARGSを与えることにより）vararg関数として登録することもでき、この場合、呼び出し引数はC関数入力前に修正されません。

この関数は、以下のいずれかを返すことができる。

- 戻り値 1 は、スタックの一番上の値が戻り値として解釈されることを示す。
- 戻り値 0 は、値スタック上に明示的な戻り値がないことを示し、undefined が呼び出し元に返される。
- 負の戻り値は、自動的にエラーが投げられることを示す。DUK_RET_xxx というエラーコードは、特定の種類のエラーに対応します（正の値である DUK_ERR_xxx と混同しないでください）。これはオプションの省略記法で、フットプリントは小さいですが、いくつかの欠点もあります (例えば、エラーメッセージがないなど)。
- ECMAScript は Edition 5.1 では複数の戻り値をサポートしていないので、1 以上の戻り値は現在未定義です (1 以上の値は、ECMAScript Edition 6 で複数の戻り値をサポートするようになるかもしれません。)。

Duktape/C関数が戻るとき、値スタックは自動的に巻き戻されるので、関数が戻ったときに値スタックを手動でクリーンアップする必要はありません。

負のエラー返り値は、一般的なエラー処理を簡素化することを目的としており、Duktape APIコールで明示的にエラーを構築して投げることの代替となります。Duktapeが自動的にメッセージを作成するため、エラーメッセージを与えることはできません。例えば

```c
duk_ret_t my_func(duk_context *ctx) {
    if (duk_get_top(ctx) == 0) {
        /* 引数が与えられない場合、TypeErrorを投げる */
        return DUK_RET_TYPE_ERROR;
    }
    /* ... */
}
```


すべてのDuktape/C関数は、ECMAScriptの意味においてストリクト（厳密）であるとみなされます。DuktapeのAPIコールは、たとえDuktape/C関数の外部で、つまりコールスタックが空の状態でAPIコールが行われたとしても、常にECMAScriptのstrictモードのセマンティックに従います。例えば、duk_del_prop()を使って設定不可能なプロパティを削除しようとすると、エラーがスローされます。これは、ECMAScriptの厳密な関数でも同様です。

```javascript
function f() {
    'use strict';
    var arr = [1, 2, 3];
    return delete arr.length;  // 配列 'length' は設定不可
}

print(f());  // f() がストリクトであるため、エラーを発生させます。
```


Duktape/C関数の厳密性のもう一つの帰結は、Duktape/C関数に与えられたこのバインディングが強制されないということです。これはECMAScriptの厳密なコードにも当てはまります。


```javascript
function strictFunc() { 'use strict'; print(typeof this); }
function nonStrictFunc() { print(typeof this); }

strictFunc.call('foo');     // prints 'string' (uncoerced)
nonStrictFunc.call('foo');  // prints 'object' (coerced)
```


Duktape/Cの関数は、現在のところ常にコンストラクタブルで、つまりnew Foo()式の中で常に使用することが可能です。ある関数がコンストラクタ・モードで呼び出されたかどうかは、以下のようにして確認することができます。


```c
static duk_ret_t my_func(duk_context *ctx) {
    if (duk_is_constructor_call(ctx)) {
        printf("called as a constructor\n");
    } else {
        printf("called as a function\n");
    }
}
```


メモリを節約するために、Duktape/C関数はデフォルトでprototypeプロパティを持たないので、デフォルトのオブジェクト・インスタンス（thisとしてコンストラクタに与えられる）はObject.prototypeを継承しています。カスタム・プロトタイプを使用するには、Duktape/C関数に対して明示的にプロトタイプを定義します。ECMAScript関数と同様に、コンストラクターがオブジェクトの値を返す場合、その値はデフォルトのオブジェクト・インスタンスを置き換え、新しい式の値となります。

> このバインディングは自動的に値スタックにプッシュされないので、アクセスするには duk_push_this() を使ってください。


### Duktape/C関数の状態を格納する

Duktape/C関数にアウトオブバンドで、つまり明示的な呼び出し引数以外で、パラメータや追加ステートを提供したい場合があります。これを実現するためには、いくつかの方法があります。

#### 関数のプロパティ

まず、Duktape/C関数はそのFunctionオブジェクトを使って、状態やパラメーターを保存することができます。ある Duktape/C 関数（実際の C 関数）は常に ECMAScript の Function オブジェクトで表され、内部的に基礎となる C 関数と関連付けられています。Functionオブジェクトは、その関数の特定のインスタンスに関連するプロパティを保存するために使用することができます。ある Duktape/C 関数は、複数の独立した Function オブジェクトに関連付けることができ、したがって、独立した状態にすることができることに注意してください。

Duktape/C関数に関連するECMAScript Functionオブジェクトにアクセスするのは簡単です。

```c
duk_push_current_function(ctx);
duk_get_prop_string(ctx, -1, "my_state_variable");
```


#### 'this'バインディング

状態を保存するためのもう一つの方法は、Duktape/C関数をメソッドとして呼び出し、状態を保存するためにthisバインディングを使用することです。例えば、asと呼ばれるDuktape/C関数を考えてみましょう。

```javascript
foo.my_c_func()
```


Duktape/C関数は呼び出されると、このバインディングとしてfooを取得し、fooに直接ステートを格納することができます。関数オブジェクトのアプローチと異なるのは、すべてのメソッドで同じオブジェクトが共有される点です。

thisバインディングにアクセスするのは簡単です。

```c
duk_push_this(ctx);
duk_get_prop_string(ctx, -1, "my_state_variable");
```


#### 隠されたシンボルのプロパティ

データをオブジェクトと関連付ける必要があるが、ECMAScript コードから隠されている場合、隠し[シンボル]()をプロパティキーとして使用することができます。このキーは、C API から ECMAScript コードに渡されない限り、C API を介してのみアクセス可能です。一般的な使用例としては、C メモリへのポインタ/データのバッキングを関連付けることです。シンボルは文字列として作成されますが、シンボルとしてマークするマクロで区別されます。

例えば、この上に隠されたシンボルを設定したり、取得したりする。

```c
my_context_data_t *my_context_data = malloc(sizeof(my_context_data_t));
duk_push_this(ctx);
duk_push_pointer(ctx, my_context_data);
duk_put_prop_string(ctx, -2, DUK_HIDDEN_SYMBOL("my_context_data"));
/* ... */
duk_push_this(ctx);
duk_get_prop_string(ctx, -1, DUK_HIDDEN_SYMBOL("my_context_data"));
my_context_data_t *my_context_data = duk_get_pointer(ctx, -1);
```


#### 関数のマジックバリュー

Duktape/C関数オブジェクトは、16ビット符号付き整数の「マジック」値（デフォル トではゼロ）を、余分なメモリー・コストなしに内部に保存することができます。このマジック・バリューは、フラグや小さな値を最小限のコストで Duktape/C 関数に渡すために使用でき、これにより、単一のネイティブ関数が複数の関数 オブジェクトに対してわずかに異なる動作を提供することができます。

```c
/* Magic value example: two lowest bits are used for a prefix index, bit 2 (0x04)
 * is used to select newline style for a log write helper.
 */
const char *prefix[4] = { "INFO", "WARN", "ERROR", "FATAL" };
duk_int_t magic = duk_get_current_magic(ctx);

printf("%s: %s", prefix[magic & 0x03], duk_safe_to_string(ctx, 0));
if (magic & 0x04) {
    printf("\r\n");
} else {
    printf("\n");
}
```


APIの使用例については、テストケースである [test-get-set-magic.c]() を参照してください。Duktapeは、コンパイルされたコードのサイズを最小化するために、内部的に マジック値を多用しています（例えば、[duk_bi_math.c]()を参照してください）。

> マジック・バリューの仕組みは、Duktapeのメジャー・バージョン間で変更される可能性があり、利用可能な予備ビットの数が変わるからです。マジック・バリューを使うのは、フットプリントが本当に重要なときだけにしてください。関数オブジェクトに保存されるプロパティは、より安定した代替手段です。


#### ヒープスタッシュ

ヒープ・スタッシュは、Cコードからだけ見えるオブジェクトです。これは Duktape ヒープに関連付けられ、Duktape/C コードが ECMAScript コードに公開されない「アンダー・ザ・フード」状態データを保存することを可能にします。これは [duk_push_heap_stash()]() API 呼び出しでアクセスします。


#### グローバルスタッシュ

グローバルスタッシュはヒープスタッシュと似ていますが、グローバルオブジェクトと関連付けられています。[duk_push_global_stash()]() APIコールでアクセスできます。同じヒープ内に、異なるグローバル・オブジェクトを持つ複数の環境が存在することがあります。


#### スレッド隠し場所

スレッド・スタッシュはヒープ・スタッシュと似ていますが、Duktapeスレッド（つまりctxポインタ）に関連付けられます。[duk_push_thread_stash()]() APIコールでアクセス可能です。


### Duktapeのバージョン固有コード

Duktapeのバージョンは、DUK_VERSION定義を通じて、 (major * 10000) + (minor * 100) + patchという数値で利用可能です。同じ値は、Duktape.versionを通じて、ECMAScriptコードで利用可能です。呼び出し側のコードは、Duktapeのバージョンに特化したコードのために、この定義を利用することができます。

Cコードの場合。

```c
#if (DUK_VERSION >= 20403)
/* Duktape 2.4.3 or later */
#elif (DUK_VERSION >= 10500)
/* Duktape 1.5.0 or later */
#else
/* Duktape lower than 1.5.0 */
#endif
```

ECMAScriptのコード用（[Duktape build-ins]()も参照）。

```javascript
if (typeof Duktape !== 'object') {
    print('not Duktape');
} else if (Duktape.version >= 20403) {
    print('Duktape 2.4.3 or higher');
} else if (Duktape.version >= 10500) {
    print('Duktape 1.5.0 or higher (but lower than 2.4.3)');
} else {
    print('Duktape lower than 1.5.0');
}
```


### 数値エラー・コード

Duktape API でエラーが発生した場合、呼び出し側はそのエラーに数値のエラー・コードを 割り当てなければなりません。エラーコードは正の整数であり、現時点では 24 ビットに制限されています。組み込みのエラーコードは duktape.h で定義されており、例えば DUK_ERR_TYPE_ERROR がある。

残りの上位ビットは、例えば追加のフラグを運ぶために内部的に使用される。負のエラー値は、Duktape/C APIにおいて、自動的にエラーを投げるための省略記法として使用されます。


### エラー・ハンドリング

Duktape APIにおけるエラー処理は、ECMAScriptがエラーを処理する方法と似ています：エラーは明示的または暗黙的にスローされ、その後キャッチされ処理されます。エラーは明示的または暗黙的にスローされ、その後キャッチされ処理されます。Cコードはtry-catch文の代わりに[protected]() Duktape APIコールを使って、Cコード内でエラーをキャッチし処理できるポイントを確立します。保護された呼び出しを除く全てのDuktape APIコールは、エラーを投げる可能性があります。ほとんどのECMAScript操作は、状況によってはエラースローを引き起こす可能性があり、メモリ不足エラーはほとんど全ての状況で起こり得ます。throw サイトと catch サイト間の長い制御転送は、 setjmp()/longjmp() (またはそのプラットフォーム固有のバージョン)、または C++ 例外スロー (DUK_USE_CPP_EXCEPTIONS が有効な場合) に基づいています、[長い制御転送]()を参照してください。

捕捉されないエラーは致命的なエラーハンドラを呼び出しますが、これは回復不可能な状況とみなされ、通常は避けるべきです。致命的なエラーを回避するために、一般的なアプリケーション・コードでは、他のDuktape APIを呼び出す前に、エラー・キャッチ・サイトを確立する必要があります。これは、例えば保護されたDuktape APIコールを使って行われます。

コードの評価 ([duk_peval()]())、コードのコンパイル ([duk_pcompile()]())、関数の呼び出し ([duk_pcall()]()) には protected コールを使用する。
単一の [duk_safe_call()]() を使って、安全でないプリミティブを安全な呼び出しの内部で自由に使えるように、エラー・キャッチャーを確立する。

最初の手法の例。

```javascript
/* Use duk_safe_call() to wrap all unsafe code into a separate C function.
 * This approach has the advantage of covering all API calls automatically
 * but is a bit more verbose.
 */

static duk_ret_t unsafe_code(duk_context *ctx, void *udata) {
    /* Here we can use unprotected calls freely. */

    (void) udata;  /* 'udata' may be used to pass e.g. a struct pointer */

    push_file_as_string(ctx, "myscript.js");
    duk_eval(ctx);

    /* ... */

    return 0;  /* success return, no return value */
}

/* elsewhere: */

if (duk_safe_call(ctx, unsafe_code, NULL /*udata*/, 0 /*nargs*/, 1 /*nrets */) != 0) {
    /* The 'nrets' argument should be at least 1 so that an error value
     * is left on the stack if an error occurs.  To avoid further errors,
     * use duk_safe_to_string() for safe error printing.
     */
    printf("Unexpected error: %s\n", duk_safe_to_string(ctx, -1));
}
duk_pop(ctx);
```


プロテクトされたコール内でも、内部エラーのように致命的なエラーを引き起こすか、プロテクトされたAPIコールから外部にエラーを伝播させるような稀なケースがあります。これらは異常時にのみ発生し、回復可能とはみなされません。これらのケースをうまく処理するために、生産品質のアプリケーションは常に致命的なエラーを処理するための合理的な戦略を持つ致命的なエラーハンドラを持つべきです。そのような戦略は、必然的にアプリケーションに依存しますが、次のようなものになるでしょう。

- 組み込みデバイスでは、致命的なエラーハンドラは致命的なエラー情報をフラッシュファイルに書き込んで、デバイスをリブートすることができます。リブート後、致命的なエラーを診断サーバーに報告し、調査できるようにする。
- UNIX システムでは、致命的エラーハンドラは単にプロセスを終了させ (デフォルトの致命的ハンドラは abort() を使用します)、 ラッパースクリプトにアプリケーションを再開させることができます。

アプリケーションによっては、エラー・キャッチャーなしでAPIコールを行い、 致命的なエラーにつながるキャッチできないエラーを投げる危険性があることは、 問題にならないかもしれないことに注意してください。致命的なエラーが発生した後、実行を継続することは安全ではないので、そのようなアプリケーションは、致命的なエラーが発生した場合、通常、単に終了します。実際の回復手段がない場合でも、致命的なエラーハンドラを使用して、例えばプロセス終了前に標準エラーに致命的なエラー情報を書き込む必要があります。


### 通常エラーと致命的エラー

通常のエラーは throw 文、[duk_throw()]() API 呼び出し（または類似のもの）、あるいは内部で回復可能な Duktape エラーによって発生します。通常のエラーは、ECMAScript コードでは try-catch で、C コードでは [duk_pcall()]() (API calls tagged [protected]() を参照)で捕捉できます。

致命的なエラーは、キャッチできないエラー、アサーションの失敗（有効な場合）、[duk_fatal()]()への明示的なコール、Duktape内部の回復不能なエラーによって引き起こされます。

各Duktapeヒープは、[duk_create_heap()]()で登録されたヒープ全体の致命的なエラー・ハンドラを持っています。ハンドラが与えられない場合、組み込みのデフォルト・ハンドラが使用されます。

- デフォルト設定: 組み込みのデフォルトの致命的なエラーハンドラは、デバッグログメッセージを書きますが、標準出力や標準エラーには何も書きません。デバッグログはデフォルトで無効になっており、致命的なエラーメッセージはデフォルトでは表示されません。ハンドラは次にabort()を呼び出します。abort() が何らかの理由で終了した場合、ハンドラは無限ループに入り、致命的なエラーの後に実行が再開されないことを保証します。
- DUK_USE_CPP_EXCEPTIONS が有効: 組み込みのデフォルトの致命的なエラーハンドラは duk_fatal_exception を投げます。この例外は std::runtime_error を継承しているので簡単に捕捉でき、致命的なエラーメッセージを読み込むための ::what() メソッドを提供します。致命的なエラーをキャッチした後に実行を継続するのは安全ではありません。
- DUK_USE_FATAL_HANDLER が定義されている場合、C++ 例外を有効にしても、常に組み込みのデフォルトの致命的なエラーハンドラとして使用されます。

> (1) ヒープ生成時にカスタム致命的エラーハンドラを提供する、 (2) duk_config.h の DUK_USE_FATAL_HANDLER() オプションを使って、 組み込みのデフォルト致命的エラーハンドラを置き換える、の両方を強くお勧めします。


致命的なエラーの後に実行を再開する安全な方法はありません。そのため、致命的なエラー・ハンドラは戻ったりDuktape APIを呼び出してはいけません。その代わり、ハンドラは例えばコンソールやログ・ファイルにメッセージを書き出し、その後プロセスを終了（または組み込みデバイスを再起動）する必要があります。これは、C++の例外を長い制御転送メカニズムとして使用する場合にも適用されます。致命的なエラーの後、アプリケーションが実行を継続すると、すべての賭けがなくなります。メモリリークが発生する可能性があり、メモリ安全性が損なわれるかもしれません。

致命的なエラーは、ヒープコンテキスト無しで発生することもあり、その場合 Duktapeはヒープ固有の致命的なエラー・ハンドラを探すことができません。その場合、Duktapeは常に組み込みのデフォルトの致命的エラーハンドラを呼び出します(handler userdata引数をNULLに設定した場合)。この方法で処理される致命的なエラーは、現在のところアサーションの失敗に限られています。そのため、アサーションを有効にしない場合、そのようなエラーは現在発生せず、すべての致命的なエラー処理は、アプリケーションが直接制御するヒープに関連する致命的なエラー・ハンドラを通じて行われます。

より詳細な情報や例については、[致命的なエラーの処理方法]()を参照してください。


### ロング・コントロール・トランスファー

Duktapeがエラーのスローやキャッチのために内部で使用している特定の長い制御転送メカニズムは、アプリケーション・コードからは直接見えません。アプリケーション・コードはエラーをキャッチするために[保護された]()呼び出しを使用し、エラーはDuktapeまたはアプリケーションによって、例えばduk_error（）などの様々なDuktape API呼び出しを使用してスローされます。


#### DUK_USE_CPP_EXCEPTIONS を使用しないデフォルトの構成

デフォルトの構成では、Duktape API の保護された呼び出しは setjmp() を使用してキャッチ・サイトを確立します。エラースローサイトでは、longjmp()を使用して、ネイティブCスタックを巻き戻し、(最も近い)キャッチサイトに戻ります。いくつかのプラットフォームでは、sigsetjmp() や siglongjmp などの呼び出しの変種が使用されています。呼び出しの亜種の間には、例えばパフォーマンスやシグナル処理に関して、小さな違いがあります。呼び出しの種類は duk_config.h で選択されます。

longjmp() は、longjmp() と setjmp() の間のすべてのネイティブ C スタックフレームを巻き戻しま す。しかし、この巻き戻し処理は C++ の自動デストラクタを呼び出さないので、C++ アプリケーションによっては重大な制限となる可能性があります。

致命的なエラー、例えば捕捉されないエラーについては、デフォルトの致命的なエラーハンドラは abort() を使用します、[正常なエラーと致命的なエラー]()を参照してください。


#### C++モード、DUK_USE_CPP_EXCEPTIONSを使用した場合

DUK_USE_CPP_EXCEPTIONSが有効な場合、長い制御転送はC++の例外スローに基づいて行われます。保護された呼び出しは、C++のトライ・キャッチを使用してキャッチ・サイトを確立します。これはDuktape内部で発生し、アプリケーションからは見えないことに注意してください。エラースローサイトはduk_internal_exceptionをスローし、（最も近い）Duktapeのキャッチサイトによってキャッチされます。アプリケーション・コードでは、この例外をキャッチ（スロー）してはいけません。そのリスクを最小限にするために、この例外は標準的な例外クラスを継承していないので、お決まりの std::exception catch サイトで捕捉されることはありません。

致命的なエラー、例えばキャッチされないエラーの場合、duk_fatal_exception はデフォルトの致命的なエラーハンドラによって投げられます。この例外は std::runtime_error を継承しており、ユーザコードで捕捉されることを意図しています。この例外は、致命的なエラーメッセージを返す ::what() メソッドを提供します。致命的なエラーは捕捉可能であっても、エラーを捕捉した後に実行を継続することは安全ではありません。[正常なエラーと致命的なエラー]()を参照してください。

どちらの C++ 例外タイプでも、C++ ネイティブのスタック巻き戻し処理は、throw サイトと catch サイトの間のスタックフレームの自動デストラクタをサポートしています。


## スタックタイプ

### 概要

| Type | Type constant | Type mask constant | Description |
| ---- | ---- | ----- | -----|
| (none)    | DUK_TYPE_NONE      | DUK_TYPE_MASK_NONE      | no type (missing value, invalid index, etc) |
| undefined | DUK_TYPE_UNDEFINED | DUK_TYPE_MASK_UNDEFINED | undefined |
| null      | DUK_TYPE_NULL      | DUK_TYPE_MASK_NULL      | null |
| boolean   | DUK_TYPE_BOOLEAN   | DUK_TYPE_MASK_BOOLEAN   | true and false |
| number    | DUK_TYPE_NUMBER    | DUK_TYPE_MASK_NUMBER    | IEEE double |
| string    | DUK_TYPE_STRING    | DUK_TYPE_MASK_STRING    | immutable (plain) string or (plain) Symbol |
| object    | DUK_TYPE_OBJECT    | DUK_TYPE_MASK_OBJECT    | object with properties |
| buffer    | DUK_TYPE_BUFFER    | DUK_TYPE_MASK_BUFFER    | mutable (plain) byte buffer, fixed/dynamic/external; mimics an Uint8Array |
| pointer   | DUK_TYPE_POINTER   | DUK_TYPE_MASK_POINTER   | opaque pointer (void *) |
| lightfunc | DUK_TYPE_LIGHTFUNC | DUK_TYPE_MASK_LIGHTFUNC | plain Duktape/C function pointer (non-object); mimics a Function |


### メモリ割り当て

以下のスタックタイプは、追加のヒープ割り当てを伴います。

- 文字列: 1回の割り当てで、ヒープと文字列ヘッダが結合され、その後に不変の文字列データが続きます。外部文字列が使用される場合（デフォルトでは有効ではありません、一般的に低メモリ環境では）、文字列データは外部である可能性もあります。
- オブジェクト：1つのアロケーションは、ヒープとオブジェクトヘッダを組み合わせたものに使用され、もう1つのアロケーションはオブジェクトプロパティに使用されます。プロパティの割り当てには、配列エントリと通常のプロパティの両方が含まれ、オブジェクトが十分に大きい場合は、検索を高速化するためにハッシュテーブルが含まれます。
- バッファ：固定バッファの場合、単一のアロケーションは、ヒープとバッファヘッダを組み合わせたものを含み、その後に変更可能な固定サイズのバッファが続きます。動的バッファの場合、現在のバッファは別々に割り当てられます。外部バッファの場合、単一のヒープオブジェクトが割り当てられ、ユーザバッファを指します。

文字列とバッファはプリミティブ (pass-by-value) 型とみなされますが、メモリ割り当ての観点からはヒープで割り当てられる型です。


### ポインタの安定性

Duktapeによって割り当てられたヒープ・オブジェクトは、安定したポインターを持ちます：ガベージ・コレクションの観点から到達可能である間は、オブジェクトはメモリー内で再配置されません。これはメイン・ヒープ・オブジェクトの場合ですが、ダイナミック・プロパティ・ テーブルやダイナミック・バッファ・データ領域のような、オブジェクトに関連する追加割 り当てについては、必ずしもそうとは限りません。ヒープオブジェクトは、到達可能なスレッドの値スタックに存在するか、グローバルオブジェクトを通じて到達可能である場合などに到達可能です。ヒープオブジェクトが到達不可能になると、そのオブジェクトを参照するユーザCコードによって保持されるポインタは安全でなくなり、もはや再参照されるべきではなくなります。

実際には、ユーザコードが直接参照するヒープ割り当てデータは、文字列、固定バッファ、ダイナミックバッファだけです。文字列と固定バッファのデータ領域は安定しています。Duktape/C関数が戻った後でも、文字列や固定バッファがガベージコレクションの観点から常に到達可能である限り、そのデータを参照するCポインタを保持することは安全です。ただし、Duktape/Cの値スタック引数などについては、特別な取り決めがない限り、この限りではありません。

ダイナミックバッファのデータ領域は安定したポインタを持ちません。バッファ自体は安定したアドレスを持つヒープヘッダを持っていますが、現在のバッファは別に割り当てられ、バッファのサイズが変更されたときに再配置される可能性があります。Duktape/C関数が戻った後にポインタを保持するのは、おそらく避けた方が良いでしょう（バッファがサイズ変更されていないことを確認する簡単な方法がないため）。

外部バッファの場合、データ・ポインタの安定性は、ポインタを設定・更新するユーザ・コードに依存します。


### タイプマスク

タイプ・マスクを使用すると、呼び出し側のコードで、ある型が特定の型セットに属しているかどうかを簡単にチェックできます。例えば、あるスタック値が数値、文字列、またはオブジェクトであることをチェックするためです。

```c
if (duk_get_type_mask(ctx, -3) & (DUK_TYPE_MASK_NUMBER |
                                  DUK_TYPE_MASK_STRING |
                                  DUK_TYPE_MASK_OBJECT)) {
    printf("type is number, string, or object\n");
}
```


さらに便利にタイプのセットをマッチングさせるための特定のAPIコールがあります。

```c
if (duk_check_type_mask(ctx, -3, DUK_TYPE_MASK_NUMBER |
                                 DUK_TYPE_MASK_STRING |
                                 DUK_TYPE_MASK_OBJECT)) {
    printf("type is number, string, or object\n");
}
```


これらは、代替品よりも高速でコンパクトです。

```c
// alt 1
if (duk_is_number(ctx, -3) || duk_is_string(ctx, -3) || duk_is_object(ctx, -3)) {
    printf("type is number, string, or object\n");
}

// alt 2
int t = duk_get_type(ctx, -3);
if (t == DUK_TYPE_NUMBER || t == DUK_TYPE_STRING || t == DUK_TYPE_OBJECT) {
    printf("type is number, string, or object\n");
}
```


### None

none 型は実際には型ではなく、値が存在しないこと、スタックインデックスが無効であること等を示すために API で使用されます。


### Undefined(未定義)

undefined型は ECMAScript の未定義に対応し、ヌルとは区別されます。

アクティブな値スタックの範囲外から読み込まれた値は、undefinedとして読み返される。


### Null

Null 型は ECMAScript の null にマップされます。


### Boolean

Boolean型は、C API では整数として表現されます：ゼロは偽、非ゼロは真です。

API 呼び出しの引数として boolean 値を与える場合、0 以外の値はすべて "true" 値として扱われます。APIコールが真偽値を返す場合、常に値1が "true "の値として使用される。これにより、ある種のC言語のイディオムが使用できるようになる。例えば、以下のように、APIコールの戻り値から直接ビットマスクを構築することができる。

```c
/* this works and generates nice code */
int bitmask = (duk_get_boolean(ctx, -3) << 2) |
              (duk_get_boolean(ctx, -2) << 1) |
              duk_get_boolean(ctx, -1);

/* more verbose variant not relying on "true" being represented by 1 */
int bitmask = ((duk_get_boolean(ctx, -3) ? 1 : 0) << 2) |
              ((duk_get_boolean(ctx, -2) ? 1 : 0) << 1) |
              (duk_get_boolean(ctx, -1) ? 1 : 0);

/* another verbose variant */
int bitmask = (duk_get_boolean(ctx, -3) ? (1 << 2) : 0) |
              (duk_get_boolean(ctx, -2) ? (1 << 1) : 0) |
              (duk_get_boolean(ctx, -1) ? 1 : 0);
```

### 数値

数値型は IEEE の double であり、±無限大と NaN 値を含む。ゼロの符号も保存される。IEEE doubleは、53ビットまでのすべての整数を正確に表現する。

IEEE doubleは、NaN値に対して追加の信号ビットを持つことができる。これらのビットは、Duktape内部のタグ付き型表現（8バイトのパック値使用時）で使用されるため、Duktape APIにおけるNaN値は正規化されます。具体的には、あるNaN値を値スタックにプッシュすると、別の（正規化された）NaN値が出てくることがあります。NaN がそのままの形で保存されることを当てにしないように。


### 文字列

文字列スタックタイプは、プレーン文字列とプレーンシンボル（ES2015 で導入）の両方を表現するために使用されます。文字列は、ある長さの任意のバイト列であり、内部に NUL (0x00) 値を含むことができます。文字列は、C言語のコーディングの便宜上、常に自動的にNULで終端されます。NULターミネーターは文字列の長さの一部としてカウントされません。例えば、文字列 "foo" はバイト長 3 で、メモリには { 'f', 'o', 'o', '\0' } という形式で格納されます。NUL終端が保証されているため、アプリケーションで内部NULが問題にならない限り、文字列は常に単純なconst char *を使って指定することができます。呼び出し側のコードは、Duktapeが保持する文字列データを直接参照することができます。このような文字列データ・ポインタは、Duktapeヒープ内で文字列に到達可能である限り有効です（そして安定しています）。

文字列は効率化のために内部化されており、ある文字列のコピーは一度に1つだけ存在します。文字列は不変であり、Cコードを呼び出しても絶対に変更してはいけません。変更すると、診断が困難な非常に不可思議な問題が発生します。

ECMAScript の文字列は、U+0000 から U+FFFF までの任意の 16 ビットのコードポイントを含むことができますが、BMP 以外のコードポイントを表現することはできません。これは、ECMAScriptの標準では文字列がこのように定義されているためです。Duktapeでは、ECMAScriptの文字列はCESU-8エンコーディングでエンコードされています。CESU-8は、サロゲートペアの範囲（U+D800からU+DFFF）のコードポイントを直接エンコードすることができる（UTF-8では禁止）ことを除いて、UTF-8と一致しています。CESU-8 は、UTF-8 と同様、すべての 7 ビ ッ ト ASCII キ ャ ラ ク タ を そ の ま ま符号化 し ますので、 C コ ー ド に と っ ては好都合です。例えば

- U+0041 ("A") は 41 にエンコードされます。
- U+1234 (ETHIOPIC SYLLABLE SEE) は e1 88 b4 にエンコードする。
- U+D812 (高位サロゲート) は ed a0 92 にエンコードされる。これは無効なUTF-8となる。

また、Duktapeは内部で拡張文字列を使用しています。U+10FFFFまでのコードポイントはUTF-8で表現でき、それ以上のコードポイントは32ビットいっぱいまで拡張UTF-8で表現できます。Duktapeが使用する拡張UTF-8のエンコーディングは、以下の表の通りです。先頭バイトは2進数で示し（データビットを示す "x"）、継続バイトは "C "で示します（ビット列10xxxxxxxを示す）。


| Codepoint range | Bits | Byte sequence | Notes |
| ---- | ---- | ---- | ---- |
| U+0000 to U+007F             | 7  | 0xxxxxxx             | |
| U+0080 to U+07FF             | 11 | 110xxxxx C           | |	
| U+0800 to U+FFFF             | 16 | 1110xxxx C C         | U+D800 to U+DFFF allowed (unlike UTF-8) |
| U+1 0000 to U+1F FFFF        | 21 | 11110xxx C C C       | Above U+10FFFF allowed (unlike UTF-8) |
| U+20 0000 to U+3FF FFFF      | 26 | 111110xx C C C C     | |	
| U+400 0000 to U+7FFF FFFF    | 31 | 1111110x C C C C C   | |
| U+8000 0000 to U+F FFFF FFFF | 36 | 11111110 C C C C C C | Only 32 bits used in practice (up to U+FFFF FFFF) |


U+7FFFFFFFF以上のコードポイントに対するエンコーディングの欠点は、先頭バイトが0xFEになることで、ユニコードのバイトオーダーマーカーエンコーディングと矛盾することです。これは、Duktapeの内部使用では実用的な懸念事項ではありません。

最後に、無効な拡張UTF-8バイト・シーケンスは、Symbol値を表すなどの特別な目的で使用されます。無効な拡張UTF-8/CESU-8バイト・シーケンスは、（CESU-8である）標準のECMAScript文字列と衝突することはなく、オブジェクトのプロパティ・テーブル内できれいに分離されたまま残ります。詳しくは Symbols と symbols.rst を参照してください。

無効な拡張 UTF-8 シーケンスを持つ文字列は、C コードから値スタックにプッシュでき、ECMAScript 関数に渡すこともできますが、2 つの注意点があります。

- 無効なバイト列が Symbol を表現するために使用される内部フォーマットに一致する場合、その値は ECMAScript コードに対して文字列ではなく Symbol として表示されます。例えば、typeof val は symbol となる。
- 無効なバイト列に対する文字列操作の挙動は十分に定義されておらず、結果は様々で、Duktapeのマイナーバージョンアップでも変更される可能性があります。


### オブジェクト

オブジェクト型には、ECMAScript のオブジェクトや配列、関数、スレッド（コルーチン）、バッファ・オブジェクトが含まれます。言い換えれば、プロパティを持つものはすべてオブジェクトです。プロパティは、文字列のキーと任意の値（未定義を含む）を持つキーと値のペアである。

オブジェクトはガベージコレクションのファイナライゼーションに参加することができます。


### バッファ

プレーン バッファ タイプは、ユーザー データ用の生のバッファです。Uint8Array や Node.js Buffer のような標準的なバッファ・オブジェクト・タイプよりもメモリ効率がよいです。プレーンバッファーのサブタイプは3つあります。



| Buffer sub-type | Data pointer | Resizable | Memory managed by | Description |
| ---- | ---- | ---- | ---- | ---- |
| Fixed | Stable, non-NULL | No | Duktape | バッファのサイズは作成時に固定され、メモリはDuktapeによって自動的に管理されます。固定バッファは、不変の（安定した）非NULLデータポインタを持ちます。 |
| Dynamic | Unstable, may be NULL | Yes | Duktape | バッファサイズは作成後に変更可能、メモリはDuktapeが自動管理。サイズ変更を可能にするために、内部で2つのメモリ割り当てが必要。バッファのサイズを変更すると、データ・ポインタが変更される可能性があります。ゼロ・サイズのバッファは、NULLデータ・ポインタを持つ可能性があります。 |
| External | Unstable, may be NULL | Yes | Duktape and user code | バッファ・データは外部で確保されます。Duktapeはヒープに割り当てられたバッファ・ヘッダ構造を割り当て、管理し ます。一方、データ領域のポインタと長さはユーザー・コードによって明示的に設定 されます。外部バッファは、バッファが Duktape ヒープ外のデータ構造（例えば、グラフィック・ライブラリによって割り当てられたフレーム・バッファ）を指すようにするのに便利です。ゼロ・サイズのバッファは、NULLデータ・ポインタを持つ可能性があります。 |


文字列とは異なり、バッファのデータ領域は自動的にNUL終端とならないため、呼び出し側のコードは現在割り当てられているバッファのサイズを超えるバイトにアクセスしてはいけません。ゼロサイズの動的バッファや外部バッファのデータポインタは NULL である可能性がありますが、固定バッファは常に NULL でないデータポインタを持ちます。

固定バッファと動的バッファは自動的にガベージコレクションされます。これはまた、Cコードが、バッファがDuktapeから到達可能でない限り、バッファ・データ・ポインタを保持してはならないことを意味します（例えば、アクティブな値スタックに存在する場合など）。外部バッファのデータ領域は自動的にガベージ・コレクトされないため、ユーザー・コードにはそのライフ・サイクルを管理する責任があります。また、ユーザー・コードは、外部バッファがもはや有効でない（あるいはまだ有効でない）ときに、外部バッファの値がアクセスされないようにする必要があります。

プレーンなバッファは Uint8Array オブジェクトを大きく模倣しており、ArrayBuffer や型付き配列などを扱う際の、非標準的でメモリ効率の良い代替手段となっています。標準のバッファオブジェクトはプレーンバッファの上に実装されており、例えば ArrayBuffer はプレーンバッファにバックアップされています。より詳細な説明は Buffer objects を参照してください。


いくつかの注意点があります。

バッファのインデックスに書き込まれる値は番号強制なので、一文字の値を代入しても期待通りにはいかないことが多い。例えば、 buf[123] = 'x' とすると、 ToNumber('x') = 0 としてバッファに 0 が書き込まれる。分かりやすくするために、 buf[123] = 0x78 のような数値のみを代入すると良い。

例えば、x = buf[123] または buf[123] = x のように、プレーンバッファの値の数値インデックスの読み書きのための高速なパスが存在します。

バッファの仮想プロパティは現在 defineProperty() に実装されていませんので、 defineProperty() でバッファのインデックスやバッファの長さを書き込むことはできません (書き込もうとすると TypeError が発生します)。


### ポインター

ポインター型は生の、解釈されないCポインターで、本質的にはvoid *です。ポインターはネイティブ・オブジェクト（メモリ割り当て、ハンドルなど）を指すために使用できますが、Duktapeはその用途を知らないので、自動的にガベージ・コレクトされることはありません。しかし、1つ以上のポインターをオブジェクトの中に入れて、オブジェクト・ファイナライザーを使って、ポインターに関連するネイティブ・リソースを解放することができます。


### Lightfunc（軽量関数）

lightfunc 型は、Duktape/C の関数ポインタと小さな制御フラグのセットを、ヒープを個別に割り当てる必要のない単一のタグ付き値にパックしたものです。制御フラグ(現在16ビット)は、以下のものをコード化します。(1) Duktape/C関数が期待するスタック引数の数（0～14またはvarargs）、 (2) 仮想長プロパティ値（0～15）、および (3) マジック値（-128～127）です。

Lightfuncsは、Duktape C APIでは別のタグ付きタイプですが、ECMAScriptコードでは、ほとんどFunctionオブジェクトのように振る舞います。通常のFunctionオブジェクトと比較すると、大きな制限があります。

- Lightfuncs は、独自のプロパティを保持することができません。Lightfuncs には、トレースバックに表示される固定の仮想 .name プロパティと、仮想 .length プロパティがあります。その他のプロパティは Function.prototype から継承されます。
- Lightfuncs はコンストラクタ関数として使用できますが、.prototype プロパティを持つことはできません。Object.prototype （デフォルト）を継承しないオブジェクトを構築する必要がある場合は、（a）コンストラクタで明示的にインスタンスを構築して返すか、（b）コンストラクタでデフォルト インスタンスの内部プロトタイプを明示的にオーバーライドする必要があります。
- Lightfunc はアクセサ・プロパティ（ゲッター/セッター）として使用できますが、実際の関数に変換されるため、メモリの利点が失われます。test-dev-lightfunc-accessor.js を参照してください。
- Lightfunc はプリミティブな型なのでファイナライザを持つことができず、参照カウントフィールドを持たず、ガベージコレクションにも参加しません。test-dev-lightfunc-finalizer.js を参照してください。

Lightfuncs は、通常の Function オブジェクトのメモリへの影響が問題となるような、非常に低メモリの環境で有用です。詳しくは Function objects を見てください。


## API の C 型

Duktape API は、エキゾチックなプラットフォームへの移植性を確保するために、 duk_int_t, duk_idx_t, duk_ret_t のような typedef-wrapped C 型をほぼ独占的に使用しています。ほとんどのプラットフォームでは、これらは符号付きまたは符号なしintに直接対応します。ラッパーは、通常の型の仮定（32ビットintを持つような）が保持されないプラットフォームをサポートすることを可能にします。詳細な議論はWikiのAPI C typesを参照してください。

ベストプラクティスのまとめ。

- 変数の宣言時には、移植性を高めるために、duk_idx_tやduk_ret_tのようなDuktape API型を使ってください。あるいは、（longのような）普通の型を使うこともできますが、コードの移植性は低下し、警告を避けるためにキャストを使用する必要があるかもしれません。
- printf()とduk_push_sprintf()のフォーマットでは、Duktape型をワイド整数型にキャストし、標準的なフォーマット指定子を使用します。例： printf("Result: %ld\n", (long) duk_get_int(ctx, -3));.
- 移植性を高めるため、16ビット以上の定数にはL（またはUL）接尾辞を使用します。int型と同様に、接尾辞のない整数型定数は16ビット幅しか保証されません。サフィックス L をつけると、最低でも 32 ビット幅の定数が保証されます。例： duk_push_int(ctx, 1234567L);.


## タイプ・アルゴリズム

このセクションでは、比較や強制などの型に関連するECMAScriptアルゴリズムが、どのようにDuktapeカスタム型に拡張されるかについて説明します。Duktape特有の型アルゴリズム（ToBuffer()とToPointer()）も説明します。


### 表記方法

値がどのように比較されるかを示すために、次のような省略記法が使われます。

| 値 | 説明 |
| ---- | ---- |
| t | 真と比較する |
| f | 偽と比較する |
| s | 単純比較：ブーリアン同士、文字列同士（文字列の内容を比較する）|
| n | 数値の比較。NaN 値は偽を比較し、0 は符号に関係なく真を比較します (例: +0 == -0)。 |
| N | SameValue での数値比較。NaN 値は真を比較し、0 は符号に関係なく比較します (例: SameValue(+0,-0) は偽) |
| p | ヒープポインタの比較 |
| L | lightfuncの比較： Duktape/Cの関数ポインタと内部制御フラグ（「マジック」値を含む）が等しいと見なすには、一致する必要があります。 |
| 1 | string vs. number: ToNumber()で文字列を強制し、比較を再試行。 |
| 2 | boolean vs. any: ToNumber() で boolean を 0 または 1 に固定し、比較を再試行。 |
| 3 | object vs. string/number: ToPrimitive() で object を強制し、比較を再試行。 |

> Booleanオブジェクト、Stringオブジェクト、Numberオブジェクトは、自動的にアンボックスされるのではなく、他のオブジェクトと同様に比較されることに注意してください。例えば、非厳格な等式では、プレーンな文字列の値をバイト単位で比較しますが、Stringオブジェクトはオブジェクト参照で比較します（他のオブジェクトと同様）。


### 等価性（非厳格）

非厳格な等式比較は、標準型についてはThe Abstract Equality Comparison Algorithmで規定されています。カスタム型の動作は以下の通りです。

- Buffer: プレーンバッファーはヒープポインタ（参照）によって比較され、内容の比較は行われません。これはUint8Arrayの動作と一致します。
- ポインター：他の型との比較はfalseを返します。ポインタとの比較は、ポインタの値が同じ場合にのみ、真を返します。特に、数値とポインタの比較はfalseを返すことに注意してください。これは少し直感的でないように思えますが、数値は 64 ポインターを正確に表すことができないので、数値とポインターを比較するとエラーが発生しやすくなる可能性があります。
- Lightfunc: 他の型と比較すると、false が返されます。lightfuncとの比較は、Duktape/C関数ポインタと内部制御フラグ（「マジック」値を含む）の両方が一致する場合にのみ、真を返します。たとえ、Functionオブジェクトがlightfuncをオブジェクトに強制することによって作成されたとしても、lightfuncは通常のFunctionオブジェクトと等しく比較されないことに注意してください。

標準的な動作とDuktapeカスタム・タイプの動作は、以下の表にまとめられています。


|  | und | nul | boo | num | str | obj | buf | ptr | lfn |
| ---- | ---- | ---- | ---- | ---- | ---- | ----| ---- | ---- | ---- |
| und | t | t | f | f | f | f | f | f | f |
| nul |   | t | f | f | f | f | f | f | f |
| boo |   |   | s | 2 | 2 | 2 | f | f | f |
| num |   |   |   | n | 1 | 3 | f | f | f |
| str |   |   |   |   | s | 3 | f | f | f |
| obj |   |   |   |   |   | p | f | f | f |
| buf |   |   |   |   |   |   | p | f | f |
| ptr |   |   |   |   |   |   |   | s | f |
| lfn |   |   |   |   |   |   |   |   | L |


### 厳密な等価性

厳密な等式はより単純で、単純さとパフォーマンスのために可能な限り望ましいものです。これは、標準的な型のための厳密な等式比較のアルゴリズムで説明されています。カスタム型の動作は以下の通りです。

- バッファ: 非厳格な等式と同様です。
- ポインタ：非厳格な等価性のようなもの。
- Lightfunc: 非厳格な等価性のようなものです。

標準の動作とDuktapeカスタム型の動作は、以下の表にまとめられています。

|  | und | nul | boo | num | str | obj | buf | ptr | lfn |
| ---- | ---- | ---- | ---- | ---- | ---- | ----| ---- | ---- | ---- |
| und | t | f | f | f | f | f | f | f | f |
| nul |   | t | f | f | f | f | f | f | f |
| boo |   |   | s | f | f | f | f | f | f |
| num |   |   |   | n | f | f | f | f | f |
| str |   |   |   |   | s | f | f | f | f |
| obj |   |   |   |   |   | p | f | f | f |
| buf |   |   |   |   |   |   | p | f | f |
| ptr |   |   |   |   |   |   |   | s | f |
| lfn |   |   |   |   |   |   |   |   | L |


### セイムバリュー

SameValue アルゴリズムは、ユーザー・コードから呼び出すのは簡単ではありません。これは、例えば Object.defineProperty() で、プロパティの値が変更されようとしているかどうかをチェックするときに使用されます。SameValue は厳密な等値比較よりもさらに厳しく、最も顕著なのは数値の比較方法が異なることです。これは、The SameValue algorithm for standard typesで規定されています。カスタム型の動作は以下の通りです。

- バッファ：非厳格（および厳密）等値のようなものです。
- ポインター：非厳格な（および厳密な）等価性のようなものです。
- Lightfunc: 非厳格な(および厳密な)等式と同じです。

標準の動作とDuktapeカスタム型の動作は、以下の表にまとめられています。


|  | und | nul | boo | num | str | obj | buf | ptr | lfn |
| ---- | ---- | ---- | ---- | ---- | ---- | ----| ---- | ---- | ---- |
| und | t | f | f | f | f | f | f | f | f |
| nul |   | t | f | f | f | f | f | f | f |
| boo |   |   | s | f | f | f | f | f | f |
| num |   |   |   | N | f | f | f | f | f |
| str |   |   |   |   | s | f | f | f | f |
| obj |   |   |   |   |   | p | f | f | f |
| buf |   |   |   |   |   |   | p | f | f |
| ptr |   |   |   |   |   |   |   | s | f |
| lfn |   |   |   |   |   |   |   |   | L |


### 型の変換とテスト

カスタム型は、型変換とテストについて説明したECMAScriptの強制力に対して、以下のように動作します（すでに上で説明したSameValueは除く）。

|  | buffer | pointer | lightfunc |
| ---- | ---- | ---- | ---- | ---- |
| DefaultValue | Usually "[object Uint8Array]"; like Uint8Array | TypeError | "light_<PTR>_<FLAGS>" (toString/valueOf) |
| ToPrimitive  | Usually "[object Uint8Array]"; like Uint8Array | identity | "light_<PTR>_<FLAGS>" (toString/valueOf) |
| ToBoolean    | true | false for NULL pointer, true otherwise | true |
| ToNumber     | ToNumber(String(buffer)), usually ToNumber("[object Uint8Array]") = NaN | 0 for NULL pointer, 1 otherwise | NaN |
| ToInteger    | same as ToNumber; usually 0 | same as ToNumber | 0 |
| ToInt32      | same as ToNumber; usually 0 | same as ToNumber | 0 |
| ToUint32     | same as ToNumber; usually 0 | same as ToNumber | 0 |
| ToUint16     | same as ToNumber; usually 0 | same as ToNumber | 0 |
| ToString     | Usually [object Uint8Array]; like Uint8Array | sprintf() with %p format (platform specific) | "light_<PTR>_<FLAGS>" |
| ToObject     | Uint8Array object (backs to argument plain buffer) | Pointer object | Function object |
| CheckObjectCoercible | allow (no error) | allow (no error) | allow (no error) |
| IsCallable   | false | false | true | 
| SameValue    | (covered above) | (covered above) | (covered above) |


バッファが文字列強制されると、Uint8Arrayのように振る舞い、その結果は通常"[object Uint8Array]"となります。この動作はDuktape 2.0で変更されました。バッファの内容から文字列を生成するには、Node.jsのBufferバインディングやEncoding APIなどを使用します。

バッファがオブジェクト強制されると、新しい Uint8Array オブジェクトが作成され、新しい ArrayBuffer がプレーン バッファにバックアップされます (コピーは作成されません)。

Lightfunc が ToPrimitive() で強制されると、普通の関数のように動作します。それは Function.prototype.toString() で強制され、結果は（通常） ToString() 強制と同じになります。

lightfunc がオブジェクト強制されると、新しい Function オブジェクトが作成され、仮想プロパティ (name と length) と内部の "magic" 値が Function オブジェクトにコピーされます。


### カスタム強制（ToBuffer, ToPointer）

ToBuffer() は、例えば duk_to_buffer() API 呼び出しで、値がバッファ型に強制されるときに使用されます。強制は以下の通りです。

- バッファはそれ自身に強制される(identity)。同じバッファの値が返されます。
- その他の型（ポインタと lightfunc を含む）は、まず ToString で文字列強制され、次に結果の文字列がバイト単位で固定サイズのバッファにコピーされます。

ToPointer() の強制は、例えば、duk_to_pointer() の呼び出しで使用されます。この強制は次のようなものです。

- ポインタはそれ自身に強制される。
- ヒープで確保された型(文字列、オブジェクト、バッファ)は、その内部ヒープヘッダーを指すポインタ値に強制されます。このポインタは診断値のみを持つ。特に、バッファや文字列に対して返されるポインタは、バッファや文字列のデータ領域を指さないことに注意してください。(この強制はマイナーバージョンでも変更される可能性がありますので、依存しないようにしてください）。
- その他の型 (数値を含む) は、NULL ポインタを指すように強制されます。
- Lightfunc は NULL ポインタに強制されます。これは、C 関数ポインターを移植可能な方法で void * に強制できないためです。

オブジェクトが作成され、仮想プロパティ（名前と長さ、および内部の「マジック」値）が Function オブジェクトにコピーされます。


|  | ToBuffer | ToPointer |
| ---- | ---- | ---- |
|undefined | buffer with "undefined" | NULL |
|null | buffer with "null" | NULL |
|boolean | buffer with "true" or "false" | NULL |
|number | buffer with string coerced number | NULL |
|string | buffer with copy of string data | ptr to heap hdr |
|object | buffer with ToString(value) | ptr to heap hdr |
|buffer | identity | ptr to heap hdr |
|pointer | sprintf() with %p format (platform specific) | identity |
|lightfunc | buffer with ToString(value) | NULL |

> 現在、ToLightFunc()の強制はありません。Lightfuncは、Duktape C APIを使ってのみ作成することができます。


### 加算演算子

ECMAScript の加算演算子は The Addition operator (+) で指定されています。加算は、どちらかの引数が文字列である場合に特別な動作をします：もう一方の引数は文字列に強制され、その後文字列は連結されます。この動作は、以下のようにカスタム型にも拡張されます。

- 標準の型では、オブジェクトの値は最初に ToPrimitive() で強制され、プレーン バッファと lightfuncs は通常 ToString() で強制されます。プレーン バッファの場合、結果は通常 "[object Uint8Array]" になり、lightfuncs の場合は "[object Function]" になります。
- ポインタの値は、デフォルトの数値加算のケースに該当します。これらは ToNumber() で強制された後、数値として追加されます。NULL ポインタは 0 に、NULL 以外は 1 になります。

加算は、一般にカスタム型には有用ではありません。たとえば、2 つのプレーンなバッファを加算すると、結果は通常 "[object Uint8Array] [object Uint8Array]" となり、これは 2 つの Uint8Array インスタンスに対する標準的な加算の動作と同じになります。


### プロパティ・アクセス

プロパティ・アクセスのベース値としてプレーン・バッファまたはポインタが使用 される場合、プロパティは（初期の）組み込みプロトタイプ・オブジェクト（Uint8Array.prototype または Duktape.Pointer.prototype）から検索されることになります。これは、標準的な型の動作を模倣しています。

例えば

```sh
duk> buf = Duktape.dec('hex', '414243');  // plain buffer
= ABC
duk> buf.subarray();
= function subarray() {"native"}
duk> typeof buf.toString();
= string
```

Lightfuncs は、設定や書き込みができない仮想プロパティ（name と length）をいくつか持ち、残りのプロパティは Function.prototype を継承し、継承された通常の Function メソッドを呼び出すことができるようになっています。

```javascript
var bound = myLightFunc.bind('dummy', 123);
```


## Duktapeのビルトイン

このセクションでは、Duktape 固有の、そして ECMAScript 以外の組み込みオブジェクト、メソッド、および値についてまとめます。


### グローバルオブジェクトプロパティの追加

| プロパティ | 説明 |
| ---- | ---- |
| globalThis | グローバル・オブジェクト自体を参照します。proposal-global を参照してください。 |
| Duktape | Duktape組み込みオブジェクト。雑多な実装固有のものが含まれています。 |
| CBOR | cbor-jsをベースにしたCBOR実験用API。 |
| TextEncoder | WHATWG Encoding API の TextEncoder()。UTF-8エンコーディングで文字列をバッファに変換します。 |
| TextDecoder | TextDecoder() WHATWG Encoding APIより。UTF-8エンコーディングを使って、バッファを文字列に変換します。 |
| performance | High Resolution Time Level 2のperformance.now()。Navigation Timing の performance.timing のようなバインディングはサポートされていません。 |


### globalThis

グローバルオブジェクトそのものを参照します（proposal-globalを参照）。(バインディングは当初'global'という名前でしたが、いくつかのWebサイトが壊れたため変更されました。)。


### Duktapeオブジェクト

| プロパティ | 説明 |
| ----  | ---- |
| version | Duktapeのバージョン番号：(メジャー * 10000) + (マイナー * 100) + patch. |
| env | エンディアンとアーキテクチャのような最も重要で効果的なオプションのバージョン依存の要約。 |
| fin | オブジェクトのファイナライザーを設定または取得する。 |
| enc | 値をエンコードする(hex, base-64, JX, JC)。Duktape.enc('hex', 'foo')。 |
| dec | 値（hex、base-64、JX、JC）をデコードする。Duktape.dec('base64', 'Zm9v')。 |
| info | 値の内部情報（ヒープアドレスやアロックサイズなど）をバージョン固有のフォーマットで取得する。C API の同等品は duk_inspect_value() である。 |
| act | コールスタックエントリに関する情報を取得する。C APIでは、duk_inspect_callstack_entry()がこれに相当する。 |
| gc | マーク・アンド・スイープ・ガベージ・コレクションをトリガする。 |
| compact | 値（オブジェクト）に割り当てられたメモリをコンパクトにする。 |
| errCreate | 作成されたエラーを修正/置換するためのコールバック。 |
| errThrow | スローされようとしているエラーを修正／置換するためのコールバック。 |
| Pointer | ポインタのコンストラクタ(関数)。 |
| Thread | スレッド コンストラクタ（関数）。 |


#### version

versionプロパティは、バージョンに基づく機能の検出と動作を可能にします。バージョン番号は直接比較することができます：論理的に高いバージョンは、数値的にも高くなります。例えば

```javascript
if (typeof Duktape !== 'object') {
    print('not Duktape');
} else if (Duktape.version >= 20403) {
    print('Duktape 2.4.3 or higher');
} else if (Duktape.version >= 10500) {
    print('Duktape 1.5.0 or higher (but lower than 2.4.3)');
} else {
    print('Duktape lower than 1.5.0');
}
```


プレリリースのバージョンの値は、実際のリリースより1つ少なくなります。例えば、0.12.0プレリリースは1199、1.3.0プレリリースは10299となります。バージョニングを参照してください。

機能検出を行う際には、Duktapeが存在するかどうかを確認することを忘れないでください。あなたのコードは通常、できるだけ多くのエンジンで動作するはずです。チェックの際に、識別子の直接参照を使うというよくある落とし穴は避けてください。

```javascript
// Bad idea: ReferenceError if missing
if (!Duktape) {
    print('not Duktape');
}

// Better: check through 'this' (bound to global)
if (!this.Duktape) {
    print('not Duktape');
}

// Better: use typeof to check also type explicitly
if (typeof Duktape !== 'object') {
    print('not Duktape');
}
```


#### env

envは、最も重要で効果的なコンパイルオプションを、バージョン固有の、かなり不可解な方法で要約したものです。この形式はバージョンに依存し、プログラム的に解析することは意図されていません。これは主に開発者のために役立ちます（値を設定するコードについては duk_hthread_builtins.c を参照してください）。

Duktape 1.1.0 の例です。

```c
ll u n p2 a4 x64 linux gcc     // l|b|m integer endianness, l|b|m IEEE double endianness
                               // p|u packed/unpacked tval
                               // n|various, memory optimization options (n = none)
                               // p1|p2|p3 prop memory layout
                               // a1|a4|a8: align target
                               // x64|x86|arm|etc: architecture
                               // linux|windows|etc: operating system
                               // gcc|clang|msvc|etc: compiler
```


エンディアンは、lがリトルエンディアン、bがビッグエンディアン、mがミックスエンディアン（レガシーARMデバイス、The FPAアーキテクチャなど参照）を表わします。


#### fin()

単一の引数で呼び出された場合、オブジェクトの現在のファイナライザを取得します。

```javascript
var currFin = Duktape.fin(o);
```


2つの引数で呼ばれた場合、オブジェクトのファイナライザを設定する（未定義を返す）。

```javascript
Duktape.fin(o, function(x) { print('finalizer called'); });
Duktape.fin(o, undefined);  // disable
```

#### enc

enc() は、その引数の値を選択されたフォーマットにエンコードします。最初の引数はフォーマット（現在サポートされているのは "hex", "base64", "jx", "jc"）、2番目の引数はエンコードする値、それ以降の引数はフォーマットに依存するものである。

hex "と "base64 "の場合、バッファの値はそのままエンコードされ、その他の値は文字列強制された後、内部バイト表現（拡張UTF-8）がエンコードされる。その結果が文字列となる。例えば、ある文字列をbase64にエンコードする場合。

```javascript
var result = Duktape.enc('base64', 'foo');
print(result);  // prints 'Zm9v'
```


jx"、"jc "の場合、フォーマット名に続く引数リストは、JSON.stringify()と同様、value、replacer（オプション）、スペース（オプション）である。たとえば

```javascript
var result = Duktape.enc('jx', { foo: 123 }, null, 4);
print(result);  // prints JX encoded {foo:123} with 4-space indent
```


#### dec()

dec() は enc() の逆機能を提供します。

hex" と "base64" については、入力値はまず文字列強制されます (文字列をデコードすることにのみ意味があります)。結果は常にプレーンなバッファとなります。たとえば

```javascript
var result = Duktape.dec('base64', 'Zm9v');
print(typeof result, result);  // prints 'object foo'
```


もし、プレーンなバッファよりも完全なUint8Arrayを好むのであれば、以下のように結果を強制することができます。

```javascript
var result = Object(Duktape.dec('base64', 'Zm9v'));
print(typeof result, result);  // prints 'object foo'
```


文字列の値を取得したい場合は、以下のようにプレーンバッファを文字列に変換することができます。

```javascript
// Use TextDecoder which decodes the input as UTF-8.  You can also use
// the Node.js Buffer binding to achieve a similar result.

var result = new TextDecoder().decode(Duktape.dec('base64', 'Zm9v'));
print(typeof result, result);  // prints 'string foo'
```


jx"、"jc "の場合、フォーマット名に続く引数リストは、JSON.parse()と同様、text、reviver（オプション）である。例えば

```javascript
var result = Duktape.dec('jx', "{foo:123}");
print(result.foo);  // prints 123
```


#### info()

Duktape.info()は、その引数値に関連する内部情報を公開するオブジェクトを返します。現在のフィールドの説明については、 duk_inspect_value() を参照してください。

> 結果オブジェクトのプロパティはバージョン保証の対象外であり、マイナーバージョン（パッチバージョンは除く）であっても互換性のない形で変更される可能性があります。


#### act()

コールスタックのエントリに関する情報を取得します。1 は最上位 (最内周) のエントリ、-2 はその下のエントリなどです。コールスタックエントリを記述したオブジェクトを返すか、エントリが存在しない場合は未定義を返す。現在のフィールドの説明については、 duk_inspect_callstack_entry() を参照してください。

> 結果オブジェクトのプロパティはバージョン保証の対象外であり、マイナーバージョンでも互換性のない形で変更される可能性がある（パッチバージョンは不可）。

例:

```javascript
function dump() {
    var i, t;
    for (i = -1; ; i--) {
        t = Duktape.act(i);
        if (!t) { break; }
        print(i, t.lineNumber, t.function.name, Duktape.enc('jx', t));
    }
}

dump();
```


この例をコマンドラインツールで実行すると、現在、次のようなものが表示されます。

```javascript
-1 0 act {lineNumber:0,pc:0,function:{_func:true}}
-2 4 dump {lineNumber:4,pc:16,function:{_func:true}}
-3 10 global {lineNumber:10,pc:5,function:{_func:true}}
```


興味深い項目は lineNumber と function で、これは例えば関数名などを提供します。

Duktape.act() を使って、現在の行番号を取得するヘルパーを実装することも可能です。

```javascript
function getCurrentLine() {
    'use duk notail';

    /* Tail calls are prevented to ensure calling activation exists.
     * Call stack indices: -1 = Duktape.act, -2 = getCurrentLine, -3 = caller
     */

    var a = Duktape.act(-3) || {};
    return a.lineNumber;
}
print('running on line:', getCurrentLine());
```


#### gc()

強制的なマーク＆スイープ収集のトリガーをかける。この呼び出しは、オプションで整数の flags フィールドを取る。定数については、 duktape.h を参照のこと。


#### compact()

ターゲットオブジェクトに割り当てられたメモリを最小にする。C API コール duk_compact() と同じですが、ECMAScript コードからアクセス可能です。オブジェクト以外の引数で呼び出された場合、この呼び出しはノー・オペレーションです。引数の値は関数によって返され、これにより、以下のようなコードが可能になります。

```javascript
var obj = {
    foo: Duktape.compact({ bar: 123 })
}
```


この呼び出しは、オブジェクトが新しいプロパティを獲得する可能性が低いことがわかっているが、万が一獲得した場合にオブジェクトを封印またはフリーズしたくない場合に有用である。


#### errCreate() と errThrow()

これらは、ユーザーコードによって設定され、エラー作成時（errCreate）またはエラースロー時（errThrow）に処理/置換することができる。どちらの値も初期状態では存在しません。

詳細はエラーハンドラ(errCreateとerrThrow)を参照してください。


### Duktape.Pointer (コンストラクタ) 

| プロパティ | 説明 |
| ---- | ---- |
| prototype | Pointer オブジェクトのプロトタイプ |


Pointer コンストラクタは、通常の関数としてもコンストラクタとしても呼び出すことができる関数です。

- 関数として呼び出された場合は、カスタムの ToPointer クラスタを使って最初の引数をポインタに変換します。戻り値は普通のポインタです（Pointerオブジェクトではありません）。
- コンストラクタとして呼び出された場合、カスタムのToPointer強制を使って最初の引数をポインタに強制変換します。内部値は、強制終了の結果得られたポインタである Pointer オブジェクトを返す。新しく作成されたPointerの内部プロトタイプはDuktape.Pointer.prototypeオブジェクトになります。


### Duktape.Pointer.prototype

| プロパティ | 説明 |
| ---- | ---- |
| toString | Pointer を印字可能な文字列に変換する |
| valueOf | Pointer が保持するプリミティブポインタの値を返す |


toString() と valueOf は、プレーンなポインタと Pointer オブジェクトの両方をこのバインディングとして受け付けます。これにより、次のようなコードが可能になります。

```javascript
var plain_ptr = Duktape.Pointer({ test: 'object' });
print(plain_ptr.toString());
```


### Duktape.Thread (コンストラクタ)

| プロパティ | 説明 |
| ---- | ---- |
| prototype | Thread オブジェクトのプロトタイプ |
| resume | 値またはエラーでターゲットスレッドを再開する。引数： ターゲットスレッド、値、値を投げるかどうかを示すフラグ（オプション、デフォルトfalse） |
| yield | 現在のスレッドから値またはエラーを投げる。引数： value、value を投げるかどうかのフラグ（オプション、デフォルトfalse） |
| current | 現在実行中のスレッドオブジェクト |


Threadコンストラクタは、通常の関数としてもコンストラクタとしても呼び出すことができる関数です。動作はどちらの場合も同じです。

最初の引数は関数であるかどうかチェックされます（もしそうでなければ TypeError が投げられます）。この関数は ECMAScript の関数でなければなりません（バインドまたは非バインド）。戻り値は、初期関数が引数関数であると記録された新しいスレッドである（この関数は新しいスレッドが最初に再開されたときに実行を開始する）。新しく作られたスレッドの内部プロトタイプは、Duktape.Thread.prototypeオブジェクトになります。


### Duktape.Thread.prototype

| Property | Description |
| ---- | ---- |
| No properties at the moment. | |


### CBOR

CBOR (Concise Binary Object Representation) は、任意の構造化された値のためのコンパクトなバイナリ符号化方式です。JSONよりも高速で、一部のECMAScriptの値をより正確に符号化することができる。JSONの代替として、状態のシリアライゼーションやIPCなどに適している。参照。

CBOR - Concise Binary Object Representation (cbor.io) を参照。
コンサイスバイナリオブジェクト表現(CBOR) (RFC 7049)
CBORオブジェクトは、任意のECMAScriptの値をCBORに、またはその逆に変換するエンコード/デコード関数を提供します。公式のCBOR APIはまだないので、今のところAPIはcbor-jsをベースにしています。また、CBORのためのC言語のAPIもあります。

> このバインディングは現在実験的なものであり、詳細は時間の経過とともに変更される可能性があります。例えば、ECMAScript の値をより正確にシリアライズするためのカスタム CBOR タグが登録されつつあります。

例:

```javascript
var enc = CBOR.encode([ 'foo', 'bar', { quux: true } ]);
print(Duktape.enc('hex', enc));  // = 8363666f6f63626172a16471757578f5
var dec = CBOR.decode(enc);
print(Duktape.enc('jx', dec));   // = ["foo","bar",{quux:true}]
```


### TextEncoder

TextEncoder() は WHATWG エンコーディング API の一部で、 文字列を UTF-8 エンコーディングでバッファ (Uint8Array) に格納するためのクリーンな方法を提供します。サロゲートペアは処理中に結合されます。例えば

```javascript
var str = '\u{1f4a9}';                   // non-BMP codepoint
print(str.length);                       // length is 2, represented as a surrogate pair
var u8 = new TextEncoder().encode(str);
print(u8.length);                        // length is 4, a single UTF-8 codepoint
print(Duktape.enc('jx', u8));            // |f09f92a9|, UTF-8 bytes F0 9F 92 A9
```


# TextDecoder

TextDecoder() は WHATWG エンコーディング API の一部で、バッファを UTF-8 エンコーディングの文字列にデコードするためのすっきりした方法を提供します。BMP 以外のコードポイントは、結果の文字列の中でサロゲートペアとして表現されます。例えば

```javascript
var u8 = new Uint8Array([ 0xf0, 0x9f, 0x92, 0xa9 ]);  // a single non-BMP codepoint
var str = new TextDecoder().decode(u8);
print(str.length);                       // length is 2, represented as a surrogate pair
print(str.charCodeAt(0));                // 55357, high surrogate
print(str.charCodeAt(1));                // 56489, low surrogate
```


### performance

performance.now() は、指定されない原点からのミリ秒単位の単調時間 (利用可能な場合は端数を含む) を提供します。返り値は DUK_USE_GET_MONOTONIC_TIME() のもので、 DUK_USE_DATE_GET_NOW() にフォールバックしています。実際のモノトニック時間プロバイダが利用可能な場合、戻り値は日付/時間の調整による「タイムジャンプ」なしでリアルタイムで進むことが保証されます。これは、パフォーマンス測定、壁時計時間ではなく現在時刻を基準としたイベントのスケジューリング、レート制限などに有用です。例

```javascript
function testFunction() {
    for (var i = 0; i < 1e6; i++) {}
}

var t1 = performance.now();
testFunction();
var t2 = performance.now();
print('test took:', (t2 - t1), 'milliseconds');
```


performance.timeOriginは、現在（Duktape 2.2.0）、Duktapeでのセマンティクスが決定されるまで、意図的に欠落させています。

performance.timingのようなNavigation Timingバインディングは、現在サポートされていません。


## ポストES5の特徴

DuktapeはES2015（ES6）、ES2016（ES7）、およびそれ以降の仕様ドラフトからの機能を実装しています。現在の状況については、Wikiの記事「Post-ES5 features」を参照してください。

Duktapeのステータスはkangax/compat-tableの新しいリリースでも更新されます。


## カスタム動作

E5.1やその他の関連仕様から逸脱したDuktapeの動作についてまとめます。


### Duktapeビルトインとカスタム・タイプ 

Duktape組み込みは（もちろん）非標準であり、Duktape固有の機能へのアクセスを提供します。また、バッファ、ポインター、lightfunc タイプはカスタムです。


### 隠しシンボル

オブジェクトは、隠された Symbol キーを持つプロパティを持つことができます。これらは ES2015 Symbols に似ていますが、列挙されたり、Object.getOwnPropertySymbols()からも返されません。キーが意図的に無効な (拡張) UTF-8 表現を使用しているため、通常の ECMAScript コードはこのようなプロパティを参照することができません。


### "use duk notail" ディレクティブ

use duk notail" 指令は非標準です。これは、関数がテールコールされるのを防ぐものです。

### "const" はほとんど "var" のように扱われます

const キーワードは、最小限の非標準のセマンティクスでサポートされています (ECMAScript 6 で公式に定義されています)。詳しくは Const 変数を参照してください。

### Error オブジェクトと Function オブジェクトの追加プロパティ

Error オブジェクトと Function オブジェクトを参照してください。

非厳格な関数インスタンスは、E5/E5.1 仕様では呼び出し元のプロパティを持ちません。現実のコードではこのプロパティを期待するものがありますので、 DUK_USE_NONSTD_FUNC_CALLER_PROPERTY という設定オプションで有効にすることができます。

### 関数文

E5.1では、関数宣言がプログラムまたは関数のトップレベル表現の外側に現れることを許可していません。

```javascript
function test() {
    // point A
    try {
        throw new Error('test');
    } catch (e) {
        // This is a SyntaxError in E5.1
        function func() {
            print(typeof e);
        }
        // point B
    }
    // point C
}
```


これらの宣言は「関数文」とも呼ばれ、実世界のコード（test262テスト・スイートを含む）では非常に頻繁に登場するので、Duktapeでは許可しています。残念ながら、Javascriptエンジンによって使用されるセマンティクスがいくつかあります（ES2015では、残念ながら関数文のセマンティクスは指定されていません）。Duktapeは、V8の関数文の挙動に従います。

- Strict function: SyntaxErrorが投げられます（標準的な動作）。
- 非厳格な関数：関数文を通常の関数宣言のように扱い、概念的には関数の先頭に「持ち上げる」。
例として、上記の例では以下のような挙動となります。

```javascript
function test() {
    function func() {
        print(typeof e);
    }
 
    try {
        throw new Error('test');
    } catch (e) {
    }
}
```

上記の例のfunc()は、すでにポイントAで宣言され、呼び出し可能であり、ポイントA、B、Cのいずれにおいてもeバインディングにアクセスすることはできないだろう。


### RegExpのリニエンシー

ほとんどの ECMAScript エンジンは ECMAScript E5.1 仕様 (セクション 15.10.1 パターン) で保証されているよりも多くの構文をサポートしています。その結果、厳密な ECMAScript E5.1 正規表現構文では動作しないコードがかなり多くなっています。ウェブブラウザエンジンに期待される追加構文の多くは、ES2015 Annex B.1.4 Regular Expression Patterns に記載されています。しかし、Annex B Additional ECMAScript Features for Web Browsers の機能は、新しいコードには推奨されないことに注意してください。「これらの機能は、ECMAScript のコア言語の一部とはみなされません。プログラマは新しい ECMAScript コードを書くときに、これらの機能や動作を使用したり仮定したりしてはいけません。ECMAScript の実装は、その実装が Web ブラウザの一部であるか、または Web ブラウザが遭遇するのと同じレガシー ECMAScript コードを実行する必要がある場合を除いて、これらの機能を実装しないように推奨されています。"

Duktapeは、既存のコードをより良くサポートするために、一部のES2015 Annex Bの構文も許可しています。この非標準的な動作は、必要に応じて設定オプションでオフにすることができます。サポートされる追加構文の例をいくつか挙げます。

```javascript
  /{(\d+)}/    // unescaped left curly, digits, unescaped right curly; ES2015 Annex B
  /\{(\d+)\}/  // same, ES5 compliant

  /]/          // unescaped right bracket; ES2015 Annex B
  /\]/         // same, ES5 compliant

  /\$/         // literal dollar using escape; ES2015 Annex B
  /\u0024/     // same, ES5 compliant
```


### Setter/getter key 引数

ECMAScript の標準的な動作は、セッターとゲッターにはアクセスされるプロパティの名前を与えないことです。このため、複数のプロパティに対して一つのセッターやゲッターを再利用することができません。各プロパティに対して別々の関数が必要となり、不便であったり、メモリを浪費したりします。

Duktapeでは、プロパティ・キー名をセッターやゲッター関数への非標準の追加引数として提供しています。詳しくは、test-dev-nonstd-setget-key-argument.jsとProperty virtualizationを参照してください。DUK_USE_NONSTD_GETTER_KEY_ARGUMENT と DUK_USE_NONSTD_SETTER_KEY_ARGUMENT という設定オプションを無効にすると、標準に準拠した厳格な動作が可能になります。


### Object.setPrototypeOf and Object.prototype.__proto__ (ES2015)

[Object.setPrototypeOf and Object.prototype.\_\_proto\_\_]() を参照


### プロキシオブジェクト(ES2015)

Proxyオブジェクト（サブセット）を参照。


### JSON.stringify() は U+2028 と U+2029 をエスケープする

JSON.stringify()の標準的な動作は、U+2028とU+2029をエスケープせずに出力することです。これは、出力がウェブ・ページで使われたり、eval()で解析されたりしたときに、直感に反する動作につながります：U+2028とU+2029文字は行末とみなされ、構文エラー（終端がない文字列）につながります。Duktapeはこの問題を避けるために、デフォルトでU+2028とU+2029をエスケープします。設定オプションDUK_USE_NONSTD_JSON_ESC_U2028_U2029を無効にすると、準拠した動作をオンにすることができます。


### String.fromCharCode()は32ビットコードポイントを受け付けます

String.fromCharCode() の標準的な動作は、コードポイント値に対して ToUInt16() 強制を使用することです。DuktapeはデフォルトでToUint32()を使用し、非BMP文字列をより良くサポートします。DUK_USE_NONSTD_STRING_FROMCHARCODE_32BIT という設定項目を無効にすれば、強制的に準拠した動作をさせることが可能です。

### 配列インスタンスの数値インデックスの書き込み

デフォルトでは、Duktapeは、Arrayインスタンスへの書き込みに高速パスを提供します。高速パスは、数値インデックスが使用され（例： arr[7] = 'foo'）、いくつかの内部条件が満たされたときに有効になります。高速パスが採用された場合、DuktapeはArray.prototypeに矛盾するプロパティがないかチェックしません（実際のコードでは非常に稀です）。これにより、一般的な配列の書き込みが高速になります。この動作は非準拠ですが、Array.prototypeが数値キーを持つプロパティを持たない限り、外見上の差はありません。DUK_USE_NONSTD_ARRAY_WRITE と DUK_USE_ARRAY_PROP_FASTPATH という設定オプションを無効にすると、準拠した挙動をオンにすることができます。高速パスの動作の詳細については、以下を参照してください： test-misc-array-fast-write.js.


### TypedArrayバインディング

DuktapeはES2015 TypedArrayバインディングを提供しますが、いくつかの詳細はまだ修正されていません。例えば、オフセットと長さの値に対する引数の強制の小さな違いなどです。

プレーンバッファーのカスタムタイプは、ECMAScriptコードではUint8Arrayオブジェクトのように振る舞いますが、Duktape C APIでは別のタイプを持っています。


### Node.jsのBufferバインディング §。

DuktapeはNode.jsライクなBufferバインディングを提供します。Node.jsの動作とDuktapeの動作には、いくつかの違いがあります。これらの違いは以下の通りです。

- 他のバッファ・タイプとの相互運用性。ArrayBuffer、DataView、または型付き配列（Uint8Arrayなど）は、Node.jsのBufferが許されるところであれば、通常どこでも許されます。
^ バッファのデータは、割り当て時および連結時の totalLength が入力バッファの合計サイズを超えたときに、常にゼロになります。
- 読み込み/書き込みのオフセットと長さの引数は、noAssert が真であっても、メモリセーフな動作を保証するために常に検証されます。読み出しに失敗した場合はNaNを、書き込みに失敗した場合は0を返す。
- 部分的な読み込み/書き込みは決して行われない: 読み込み/書き込みの一部が有効なバッファの外にある場合、それは拒否される。
- オフセットや長さなどの引数の強制に若干の違いがある。
- 例えば、writeUInt8()を使って0x100を書き込む場合、TypeErrorを投げるのではなく、0x00に静かに強制されます。
- Duktapeは "utf8 "エンコーディングのみをサポートします（そして、スペリングのバリエーションは一切受け付けません）。ほとんどのAPIコールはエンコーディングの引数を無視し、文字列からバッファへの強制変換に暗黙のうちにUTF-8を使用します。
- UTF-8デコードの置換文字のアプローチは、Unicode Technical Committee Recommended Practice for Replacement Charactersに従っており、WHATWG Encoding API仕様と一致していますが、Node.js（少なくともバージョンv6.9.1まで）とは異なっています。


### Shebang コメントのサポート

duk_compile() フラグ DUK_COMPILE_SHEBANG により、shebang コメントのパースが可能になります。最初の行の最初のカラムに #!を付けると、その行はコメントとして扱われます。例えば

```ruby
#!/usr/bin/duk
print('Hello world!');
```


この機能は、DUK_USE_SHEBANG_COMMENTS の定義を解除することで無効にすることができます。


## 